[
  {
    "name": "aws2-lambda",
    "title": "AWS Lambda",
    "description": "Manage and invoke AWS Lambda functions using AWS SDK version 2.x.",
    "iconUrl": "https://tst-ipaas-public-assets.s3.us-east-1.amazonaws.com/images/components/aws2-lambda.svg",
    "syntax": "aws2-lambda:function",
    "properties": {
      "function": {
        "title": "Function",
        "description": "Name of the Lambda function.",
        "datatype": "string",
        "secret": false,
        "group": "producer"
      },
      "required": [
        "function"
      ],
      "operation": {
        "title": "Operation",
        "description": "The operation to perform. It can be listFunctions, getFunction, createFunction, deleteFunction or invokeFunction",
        "datatype": "string",
        "defaultValue": "invokeFunction",
        "secret": false,
        "required": false,
        "group": "producer",
        "enum": [
          "listFunctions",
          "getFunction",
          "createAlias",
          "deleteAlias",
          "getAlias",
          "listAliases",
          "createFunction",
          "deleteFunction",
          "invokeFunction",
          "updateFunction",
          "createEventSourceMapping",
          "deleteEventSourceMapping",
          "listEventSourceMapping",
          "listTags",
          "tagResource",
          "untagResource",
          "publishVersion",
          "listVersions"
        ]
      },
      "overrideEndpoint": {
        "title": "Override Endpoint",
        "description": "Set the need for overidding the endpoint. This option needs to be used in combination with uriEndpointOverride option",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "pojoRequest": {
        "title": "Pojo Request",
        "description": "If we want to use a POJO request as body or not",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "region": {
        "title": "Region",
        "description": "The region in which Lambda client needs to work. When using this parameter, the configuration will expect the lowercase name of the region (for example ap-east-1) You'll need to use the name Region.EU_WEST_1.id()",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "uriEndpointOverride": {
        "title": "Uri Endpoint Override",
        "description": "Set the overriding uri endpoint. This option needs to be used in combination with overrideEndpoint option",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "lazyStartProducer": {
        "title": "Lazy Start Producer",
        "description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "autowiredEnabled": {
        "title": "Autowired Enabled",
        "description": "Whether autowiring is enabled. This is used for automatic autowiring options (the option must be marked as autowired) by looking up in the registry to find if there is a single instance of matching type, which then gets configured on the component. This can be used for automatic configuring JDBC data sources, JMS connection factories, AWS Clients, etc.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "proxyHost": {
        "title": "Proxy Host",
        "description": "To define a proxy host when instantiating the Lambda client",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "proxy"
      },
      "proxyPort": {
        "title": "Proxy Port",
        "description": "To define a proxy port when instantiating the Lambda client",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "proxy"
      },
      "proxyProtocol": {
        "title": "Proxy Protocol",
        "description": "To define a proxy protocol when instantiating the Lambda client",
        "datatype": "string",
        "defaultValue": "HTTPS",
        "secret": false,
        "required": false,
        "group": "proxy",
        "enum": [
          "HTTP",
          "HTTPS"
        ]
      },
      "accessKey": {
        "title": "Access Key",
        "description": "Amazon AWS Access Key",
        "datatype": "string",
        "secret": true,
        "required": false,
        "group": "security"
      },
      "profileCredentialsName": {
        "title": "Profile Credentials Name",
        "description": "If using a profile credentials provider this parameter will set the profile name",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "security"
      },
      "secretKey": {
        "title": "Secret Key",
        "description": "Amazon AWS Secret Key",
        "datatype": "string",
        "secret": true,
        "required": false,
        "group": "security"
      },
      "trustAllCertificates": {
        "title": "Trust All Certificates",
        "description": "If we want to trust all certificates in case of overriding the endpoint",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "security"
      },
      "useDefaultCredentialsProvider": {
        "title": "Use Default Credentials Provider",
        "description": "Set whether the Lambda client should expect to load credentials through a default credentials provider or to expect static credentials to be passed in.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "security"
      },
      "useProfileCredentialsProvider": {
        "title": "Use Profile Credentials Provider",
        "description": "Set whether the Lambda client should expect to load credentials through a profile credentials provider.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "security"
      }
    },
    "pathProperties": {
      "function": {
        "title": "Function",
        "description": "Name of the Lambda function.",
        "datatype": "string",
        "secret": false,
        "required": true
      }
    },
    "producer": true,
    "consumer": false
  },
  {
    "name": "aws2-s3",
    "title": "AWS S3 Storage Service",
    "description": "Store and retrieve objects from AWS S3 Storage Service using AWS SDK version 2.x.",
    "iconUrl": "https://tst-ipaas-public-assets.s3.us-east-1.amazonaws.com/images/components/aws2-s3.svg",
    "syntax": "aws2-s3://bucketNameOrArn",
    "properties": {
      "bucketNameOrArn": {
        "title": "Bucket Name Or Arn",
        "description": "Bucket name or ARN",
        "datatype": "string",
        "secret": false,
        "group": "common"
      },
      "autoCreateBucket": {
        "title": "Auto Create Bucket",
        "description": "Setting the autocreation of the S3 bucket bucketName. This will apply also in case of moveAfterRead option enabled and it will create the destinationBucket if it doesn't exist already.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "common"
      },
      "delimiter": {
        "title": "Delimiter",
        "description": "The delimiter which is used in the com.amazonaws.services.s3.model.ListObjectsRequest to only consume objects we are interested in.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "common"
      },
      "forcePathStyle": {
        "title": "Force Path Style",
        "description": "Set whether the S3 client should use path-style URL instead of virtual-hosted-style",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "common"
      },
      "overrideEndpoint": {
        "title": "Override Endpoint",
        "description": "Set the need for overidding the endpoint. This option needs to be used in combination with uriEndpointOverride option",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "common"
      },
      "pojoRequest": {
        "title": "Pojo Request",
        "description": "If we want to use a POJO request as body or not",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "common"
      },
      "policy": {
        "title": "Policy",
        "description": "The policy for this queue to set in the com.amazonaws.services.s3.AmazonS3#setBucketPolicy() method.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "common"
      },
      "prefix": {
        "title": "Prefix",
        "description": "The prefix which is used in the com.amazonaws.services.s3.model.ListObjectsRequest to only consume objects we are interested in.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "common"
      },
      "region": {
        "title": "Region",
        "description": "The region in which S3 client needs to work. When using this parameter, the configuration will expect the lowercase name of the region (for example ap-east-1) You'll need to use the name Region.EU_WEST_1.id()",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "common"
      },
      "uriEndpointOverride": {
        "title": "Uri Endpoint Override",
        "description": "Set the overriding uri endpoint. This option needs to be used in combination with overrideEndpoint option",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "common"
      },
      "customerAlgorithm": {
        "title": "Customer Algorithm",
        "description": "Define the customer algorithm to use in case CustomerKey is enabled",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "common (advanced)"
      },
      "customerKeyId": {
        "title": "Customer Key Id",
        "description": "Define the id of Customer key to use in case CustomerKey is enabled",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "common (advanced)"
      },
      "customerKeyMD5": {
        "title": "Customer Key MD5",
        "description": "Define the MD5 of Customer key to use in case CustomerKey is enabled",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "common (advanced)"
      },
      "deleteAfterRead": {
        "title": "Delete After Read",
        "description": "Delete objects from S3 after they have been retrieved. The delete is only performed if the Exchange is committed. If a rollback occurs, the object is not deleted. If this option is false, then the same objects will be retrieve over and over again on the polls. Therefore you need to use the Idempotent Consumer EIP in the route to filter out duplicates. You can filter using the AWS2S3Constants#BUCKET_NAME and AWS2S3Constants#KEY headers, or only the AWS2S3Constants#KEY header.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "destinationBucket": {
        "title": "Destination Bucket",
        "description": "Define the destination bucket where an object must be moved when moveAfterRead is set to true.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "destinationBucketPrefix": {
        "title": "Destination Bucket Prefix",
        "description": "Define the destination bucket prefix to use when an object must be moved and moveAfterRead is set to true.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "destinationBucketSuffix": {
        "title": "Destination Bucket Suffix",
        "description": "Define the destination bucket suffix to use when an object must be moved and moveAfterRead is set to true.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "doneFileName": {
        "title": "Done File Name",
        "description": "If provided, Camel will only consume files if a done file exists.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "fileName": {
        "title": "File Name",
        "description": "To get the object from the bucket with the given file name",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "ignoreBody": {
        "title": "Ignore Body",
        "description": "If it is true, the S3 Object Body will be ignored completely, if it is set to false the S3 Object will be put in the body. Setting this to true, will override any behavior defined by includeBody option.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "includeBody": {
        "title": "Include Body",
        "description": "If it is true, the S3Object exchange will be consumed and put into the body and closed. If false the S3Object stream will be put raw into the body and the headers will be set with the S3 object metadata. This option is strongly related to autocloseBody option. In case of setting includeBody to true because the S3Object stream will be consumed then it will also be closed, while in case of includeBody false then it will be up to the caller to close the S3Object stream. However setting autocloseBody to true when includeBody is false it will schedule to close the S3Object stream automatically on exchange completion.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "includeFolders": {
        "title": "Include Folders",
        "description": "If it is true, the folders/directories will be consumed. If it is false, they will be ignored, and Exchanges will not be created for those",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "maxConnections": {
        "title": "Max Connections",
        "description": "Set the maxConnections parameter in the S3 client configuration",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 60,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "maxMessagesPerPoll": {
        "title": "Max Messages Per Poll",
        "description": "Gets the maximum number of messages as a limit to poll at each polling. Gets the maximum number of messages as a limit to poll at each polling. The default value is 10. Use 0 or a negative number to set it as unlimited.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 10,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "moveAfterRead": {
        "title": "Move After Read",
        "description": "Move objects from S3 bucket to a different bucket after they have been retrieved. To accomplish the operation the destinationBucket option must be set. The copy bucket operation is only performed if the Exchange is committed. If a rollback occurs, the object is not moved.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "sendEmptyMessageWhenIdle": {
        "title": "Send Empty Message When Idle",
        "description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "autocloseBody": {
        "title": "Autoclose Body",
        "description": "If this option is true and includeBody is false, then the S3Object.close() method will be called on exchange completion. This option is strongly related to includeBody option. In case of setting includeBody to false and autocloseBody to false, it will be up to the caller to close the S3Object stream. Setting autocloseBody to true, will close the S3Object stream automatically.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "bridgeErrorHandler": {
        "title": "Bridge Error Handler",
        "description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "exchangePattern": {
        "title": "Exchange Pattern",
        "description": "Sets the exchange pattern when the consumer creates an exchange.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer (advanced)",
        "enum": [
          "InOnly",
          "InOut"
        ]
      },
      "batchMessageNumber": {
        "title": "Batch Message Number",
        "description": "The number of messages composing a batch in streaming upload mode",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 10,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "batchSize": {
        "title": "Batch Size",
        "description": "The batch size (in bytes) in streaming upload mode",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 1000000,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "deleteAfterWrite": {
        "title": "Delete After Write",
        "description": "Delete file object after the S3 file has been uploaded",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "keyName": {
        "title": "Key Name",
        "description": "Setting the key name for an element in the bucket through endpoint parameter",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "multiPartUpload": {
        "title": "Multi Part Upload",
        "description": "If it is true, camel will upload the file with multi part format, the part size is decided by the option of partSize",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "namingStrategy": {
        "title": "Naming Strategy",
        "description": "The naming strategy to use in streaming upload mode",
        "datatype": "string",
        "defaultValue": "progressive",
        "secret": false,
        "required": false,
        "group": "producer",
        "enum": [
          "progressive",
          "random"
        ]
      },
      "operation": {
        "title": "Operation",
        "description": "The operation to do in case the user don't want to do only an upload",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer",
        "enum": [
          "copyObject",
          "listObjects",
          "deleteObject",
          "deleteBucket",
          "listBuckets",
          "getObject",
          "getObjectRange",
          "createDownloadLink"
        ]
      },
      "partSize": {
        "title": "Part Size",
        "description": "Setup the partSize which is used in multi part upload, the default size is 25M.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 26214400,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "restartingPolicy": {
        "title": "Restarting Policy",
        "description": "The restarting policy to use in streaming upload mode",
        "datatype": "string",
        "defaultValue": "override",
        "secret": false,
        "required": false,
        "group": "producer",
        "enum": [
          "override",
          "lastPart"
        ]
      },
      "storageClass": {
        "title": "Storage Class",
        "description": "The storage class to set in the com.amazonaws.services.s3.model.PutObjectRequest request.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "streamingUploadMode": {
        "title": "Streaming Upload Mode",
        "description": "When stream mode is true the upload to bucket will be done in streaming",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "streamingUploadTimeout": {
        "title": "Streaming Upload Timeout",
        "description": "While streaming upload mode is true, this option set the timeout to complete upload",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "awsKMSKeyId": {
        "title": "Aws KMSKey Id",
        "description": "Define the id of KMS key to use in case KMS is enabled",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "lazyStartProducer": {
        "title": "Lazy Start Producer",
        "description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "useAwsKMS": {
        "title": "Use Aws KMS",
        "description": "Define if KMS must be used or not",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "useCustomerKey": {
        "title": "Use Customer Key",
        "description": "Define if Customer Key must be used or not",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "useSSES3": {
        "title": "Use SSES3",
        "description": "Define if SSE S3 must be used or not",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "proxyHost": {
        "title": "Proxy Host",
        "description": "To define a proxy host when instantiating the SQS client",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "proxy"
      },
      "proxyPort": {
        "title": "Proxy Port",
        "description": "Specify a proxy port to be used inside the client definition.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "proxy"
      },
      "proxyProtocol": {
        "title": "Proxy Protocol",
        "description": "To define a proxy protocol when instantiating the S3 client",
        "datatype": "string",
        "defaultValue": "HTTPS",
        "secret": false,
        "required": false,
        "group": "proxy",
        "enum": [
          "HTTP",
          "HTTPS"
        ]
      },
      "backoffErrorThreshold": {
        "title": "Backoff Error Threshold",
        "description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "backoffIdleThreshold": {
        "title": "Backoff Idle Threshold",
        "description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "backoffMultiplier": {
        "title": "Backoff Multiplier",
        "description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "delay": {
        "title": "Delay",
        "description": "Milliseconds before the next poll.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 500,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "greedy": {
        "title": "Greedy",
        "description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "initialDelay": {
        "title": "Initial Delay",
        "description": "Milliseconds before the first poll starts.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 1000,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "repeatCount": {
        "title": "Repeat Count",
        "description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 0,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "runLoggingLevel": {
        "title": "Run Logging Level",
        "description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
        "datatype": "string",
        "defaultValue": "TRACE",
        "secret": false,
        "required": false,
        "group": "scheduler",
        "enum": [
          "TRACE",
          "DEBUG",
          "INFO",
          "WARN",
          "ERROR",
          "OFF"
        ]
      },
      "startScheduler": {
        "title": "Start Scheduler",
        "description": "Whether the scheduler should be auto started.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "timeUnit": {
        "title": "Time Unit",
        "description": "Time unit for initialDelay and delay options.",
        "datatype": "string",
        "defaultValue": "MILLISECONDS",
        "secret": false,
        "required": false,
        "group": "scheduler",
        "enum": [
          "NANOSECONDS",
          "MICROSECONDS",
          "MILLISECONDS",
          "SECONDS",
          "MINUTES",
          "HOURS",
          "DAYS"
        ]
      },
      "useFixedDelay": {
        "title": "Use Fixed Delay",
        "description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "accessKey": {
        "title": "Access Key",
        "description": "Amazon AWS Access Key",
        "datatype": "string",
        "secret": true,
        "required": false,
        "group": "security"
      },
      "profileCredentialsName": {
        "title": "Profile Credentials Name",
        "description": "If using a profile credentials provider this parameter will set the profile name",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "security"
      },
      "secretKey": {
        "title": "Secret Key",
        "description": "Amazon AWS Secret Key",
        "datatype": "string",
        "secret": true,
        "required": false,
        "group": "security"
      },
      "trustAllCertificates": {
        "title": "Trust All Certificates",
        "description": "If we want to trust all certificates in case of overriding the endpoint",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "security"
      },
      "useDefaultCredentialsProvider": {
        "title": "Use Default Credentials Provider",
        "description": "Set whether the S3 client should expect to load credentials through a default credentials provider.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "security"
      },
      "useProfileCredentialsProvider": {
        "title": "Use Profile Credentials Provider",
        "description": "Set whether the S3 client should expect to load credentials through a profile credentials provider.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "security"
      }
    },
    "required": [
      "bucketNameOrArn"
    ],
    "pathProperties": {
      "bucketNameOrArn": {
        "title": "Bucket Name Or Arn",
        "description": "Bucket name or ARN",
        "datatype": "string",
        "secret": false,
        "required": true
      }
    },
    "producer": true,
    "consumer": true
  },
  {
    "name": "aws2-sns",
    "title": "AWS Simple Notification System (SNS)",
    "description": "Send messages to an AWS Simple Notification Topic using AWS SDK version 2.x.",
    "iconUrl": "https://tst-ipaas-public-assets.s3.us-east-1.amazonaws.com/images/components/aws2-sns.svg",
    "syntax": "aws2-sns:topicNameOrArn",
    "properties": {
      "topicNameOrArn": {
        "title": "Topic Name Or Arn",
        "description": "Topic name or ARN",
        "datatype": "string",
        "secret": false,
        "group": "producer"
      },
      "autoCreateTopic": {
        "title": "Auto Create Topic",
        "description": "Setting the autocreation of the topic",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "kmsMasterKeyId": {
        "title": "Kms Master Key Id",
        "description": "The ID of an AWS-managed customer master key (CMK) for Amazon SNS or a custom CMK.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "messageDeduplicationIdStrategy": {
        "title": "Message Deduplication Id Strategy",
        "description": "Only for FIFO Topic. Strategy for setting the messageDeduplicationId on the message. Can be one of the following options: useExchangeId, useContentBasedDeduplication. For the useContentBasedDeduplication option, no messageDeduplicationId will be set on the message.",
        "datatype": "string",
        "defaultValue": "useExchangeId",
        "secret": false,
        "required": false,
        "group": "producer",
        "enum": [
          "useExchangeId",
          "useContentBasedDeduplication"
        ]
      },
      "messageGroupIdStrategy": {
        "title": "Message Group Id Strategy",
        "description": "Only for FIFO Topic. Strategy for setting the messageGroupId on the message. Can be one of the following options: useConstant, useExchangeId, usePropertyValue. For the usePropertyValue option, the value of property CamelAwsMessageGroupId will be used.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer",
        "enum": [
          "useConstant",
          "useExchangeId",
          "usePropertyValue"
        ]
      },
      "messageStructure": {
        "title": "Message Structure",
        "description": "The message structure to use such as json",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "overrideEndpoint": {
        "title": "Override Endpoint",
        "description": "Set the need for overidding the endpoint. This option needs to be used in combination with uriEndpointOverride option",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "policy": {
        "title": "Policy",
        "description": "The policy for this topic. Is loaded by default from classpath, but you can prefix with classpath:, file:, or http: to load the resource from different systems.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "queueUrl": {
        "title": "Queue Url",
        "description": "The queueUrl to subscribe to",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "region": {
        "title": "Region",
        "description": "The region in which SNS client needs to work. When using this parameter, the configuration will expect the lowercase name of the region (for example ap-east-1) You'll need to use the name Region.EU_WEST_1.id()",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "serverSideEncryptionEnabled": {
        "title": "Server Side Encryption Enabled",
        "description": "Define if Server Side Encryption is enabled or not on the topic",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "subject": {
        "title": "Subject",
        "description": "The subject which is used if the message header 'CamelAwsSnsSubject' is not present.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "subscribeSNStoSQS": {
        "title": "Subscribe SNSto SQS",
        "description": "Define if the subscription between SNS Topic and SQS must be done or not",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "uriEndpointOverride": {
        "title": "Uri Endpoint Override",
        "description": "Set the overriding uri endpoint. This option needs to be used in combination with overrideEndpoint option",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "lazyStartProducer": {
        "title": "Lazy Start Producer",
        "description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "autowiredEnabled": {
        "title": "Autowired Enabled",
        "description": "Whether autowiring is enabled. This is used for automatic autowiring options (the option must be marked as autowired) by looking up in the registry to find if there is a single instance of matching type, which then gets configured on the component. This can be used for automatic configuring JDBC data sources, JMS connection factories, AWS Clients, etc.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "proxyHost": {
        "title": "Proxy Host",
        "description": "To define a proxy host when instantiating the SNS client",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "proxy"
      },
      "proxyPort": {
        "title": "Proxy Port",
        "description": "To define a proxy port when instantiating the SNS client",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "proxy"
      },
      "proxyProtocol": {
        "title": "Proxy Protocol",
        "description": "To define a proxy protocol when instantiating the SNS client",
        "datatype": "string",
        "defaultValue": "HTTPS",
        "secret": false,
        "required": false,
        "group": "proxy",
        "enum": [
          "HTTP",
          "HTTPS"
        ]
      },
      "accessKey": {
        "title": "Access Key",
        "description": "Amazon AWS Access Key",
        "datatype": "string",
        "secret": true,
        "required": false,
        "group": "security"
      },
      "profileCredentialsName": {
        "title": "Profile Credentials Name",
        "description": "If using a profile credentials provider this parameter will set the profile name",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "security"
      },
      "secretKey": {
        "title": "Secret Key",
        "description": "Amazon AWS Secret Key",
        "datatype": "string",
        "secret": true,
        "required": false,
        "group": "security"
      },
      "trustAllCertificates": {
        "title": "Trust All Certificates",
        "description": "If we want to trust all certificates in case of overriding the endpoint",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "security"
      },
      "useDefaultCredentialsProvider": {
        "title": "Use Default Credentials Provider",
        "description": "Set whether the SNS client should expect to load credentials on an AWS infra instance or to expect static credentials to be passed in.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "security"
      },
      "useProfileCredentialsProvider": {
        "title": "Use Profile Credentials Provider",
        "description": "Set whether the SNS client should expect to load credentials through a profile credentials provider.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "security"
      }
    },
    "required": [
      "topicNameOrArn"
    ],
    "pathProperties": {
      "topicNameOrArn": {
        "title": "Topic Name Or Arn",
        "description": "Topic name or ARN",
        "datatype": "string",
        "secret": false,
        "required": true
      }
    },
    "producer": true,
    "consumer": false
  },
  {
    "name": "aws2-sqs",
    "title": "AWS Simple Queue Service (SQS)",
    "description": "Send and receive messages to/from AWS SQS service using AWS SDK version 2.x.",
    "iconUrl": "https://tst-ipaas-public-assets.s3.us-east-1.amazonaws.com/images/components/aws2-sqs.svg",
    "syntax": "aws2-sqs:queueNameOrArn",
    "properties": {
      "queueNameOrArn": {
        "title": "Queue Name Or Arn",
        "description": "Queue name or ARN",
        "datatype": "string",
        "secret": false,
        "required": true,
        "group": "common"
      },
      "amazonAWSHost": {
        "title": "Amazon AWSHost",
        "description": "The hostname of the Amazon AWS cloud.",
        "datatype": "string",
        "defaultValue": "amazonaws.com",
        "secret": false,
        "required": false,
        "group": "common"
      },
      "autoCreateQueue": {
        "title": "Auto Create Queue",
        "description": "Setting the autocreation of the queue",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "common"
      },
      "overrideEndpoint": {
        "title": "Override Endpoint",
        "description": "Set the need for overriding the endpoint. This option needs to be used in combination with uriEndpointOverride option",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "common"
      },
      "protocol": {
        "title": "Protocol",
        "description": "The underlying protocol used to communicate with SQS",
        "datatype": "string",
        "defaultValue": "https",
        "secret": false,
        "required": false,
        "group": "common"
      },
      "queueOwnerAWSAccountId": {
        "title": "Queue Owner AWSAccount Id",
        "description": "Specify the queue owner aws account id when you need to connect the queue with different account owner.",
        "datatype": "string",
        "secret": true,
        "required": false,
        "group": "common"
      },
      "region": {
        "title": "Region",
        "description": "The region in which SQS client needs to work. When using this parameter, the configuration will expect the lowercase name of the region (for example ap-east-1) You'll need to use the name Region.EU_WEST_1.id()",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "common"
      },
      "uriEndpointOverride": {
        "title": "Uri Endpoint Override",
        "description": "Set the overriding uri endpoint. This option needs to be used in combination with overrideEndpoint option",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "common"
      },
      "attributeNames": {
        "title": "Attribute Names",
        "description": "A list of attribute names to receive when consuming. Multiple names can be separated by comma.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "concurrentConsumers": {
        "title": "Concurrent Consumers",
        "description": "Allows you to use multiple threads to poll the sqs queue to increase throughput",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 1,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "defaultVisibilityTimeout": {
        "title": "Default Visibility Timeout",
        "description": "The default visibility timeout (in seconds)",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "deleteAfterRead": {
        "title": "Delete After Read",
        "description": "Delete message from SQS after it has been read",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "deleteIfFiltered": {
        "title": "Delete If Filtered",
        "description": "Whether or not to send the DeleteMessage to the SQS queue if the exchange has property with key Sqs2Constants#SQS_DELETE_FILTERED (CamelAwsSqsDeleteFiltered) set to true.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "extendMessageVisibility": {
        "title": "Extend Message Visibility",
        "description": "If enabled then a scheduled background task will keep extending the message visibility on SQS. This is needed if it takes a long time to process the message. If set to true defaultVisibilityTimeout must be set. See details at Amazon docs.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "kmsDataKeyReusePeriodSeconds": {
        "title": "Kms Data Key Reuse Period Seconds",
        "description": "The length of time, in seconds, for which Amazon SQS can reuse a data key to encrypt or decrypt messages before calling AWS KMS again. An integer representing seconds, between 60 seconds (1 minute) and 86,400 seconds (24 hours). Default: 300 (5 minutes).",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "kmsMasterKeyId": {
        "title": "Kms Master Key Id",
        "description": "The ID of an AWS-managed customer master key (CMK) for Amazon SQS or a custom CMK.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "maxMessagesPerPoll": {
        "title": "Max Messages Per Poll",
        "description": "Gets the maximum number of messages as a limit to poll at each polling. Is default unlimited, but use 0 or negative number to disable it as unlimited.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "messageAttributeNames": {
        "title": "Message Attribute Names",
        "description": "A list of message attribute names to receive when consuming. Multiple names can be separated by comma.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "sendEmptyMessageWhenIdle": {
        "title": "Send Empty Message When Idle",
        "description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "serverSideEncryptionEnabled": {
        "title": "Server Side Encryption Enabled",
        "description": "Define if Server Side Encryption is enabled or not on the queue",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "visibilityTimeout": {
        "title": "Visibility Timeout",
        "description": "The duration (in seconds) that the received messages are hidden from subsequent retrieve requests after being retrieved by a ReceiveMessage request to set in the com.amazonaws.services.sqs.model.SetQueueAttributesRequest. This only make sense if its different from defaultVisibilityTimeout. It changes the queue visibility timeout attribute permanently.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "waitTimeSeconds": {
        "title": "Wait Time Seconds",
        "description": "Duration in seconds (0 to 20) that the ReceiveMessage action call will wait until a message is in the queue to include in the response.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "bridgeErrorHandler": {
        "title": "Bridge Error Handler",
        "description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "exchangePattern": {
        "title": "Exchange Pattern",
        "description": "Sets the exchange pattern when the consumer creates an exchange.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer (advanced)",
        "enum": [
          "InOnly",
          "InOut"
        ]
      },
      "batchSeparator": {
        "title": "Batch Separator",
        "description": "Set the separator when passing a String to send batch message operation",
        "datatype": "string",
        "defaultValue": ",",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "delaySeconds": {
        "title": "Delay Seconds",
        "description": "Delay sending messages for a number of seconds.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "messageDeduplicationIdStrategy": {
        "title": "Message Deduplication Id Strategy",
        "description": "Only for FIFO queues. Strategy for setting the messageDeduplicationId on the message. Can be one of the following options: useExchangeId, useContentBasedDeduplication. For the useContentBasedDeduplication option, no messageDeduplicationId will be set on the message.",
        "datatype": "string",
        "defaultValue": "useExchangeId",
        "secret": false,
        "required": false,
        "group": "producer",
        "enum": [
          "useExchangeId",
          "useContentBasedDeduplication"
        ]
      },
      "messageGroupIdStrategy": {
        "title": "Message Group Id Strategy",
        "description": "Only for FIFO queues. Strategy for setting the messageGroupId on the message. Can be one of the following options: useConstant, useExchangeId, usePropertyValue. For the usePropertyValue option, the value of property CamelAwsMessageGroupId will be used.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer",
        "enum": [
          "useConstant",
          "useExchangeId",
          "usePropertyValue"
        ]
      },
      "messageHeaderExceededLimit": {
        "title": "Message Header Exceeded Limit",
        "description": "What to do if sending to AWS SQS has more messages than AWS allows (currently only maximum 10 message headers is allowed). WARN will log a WARN about the limit is for each additional header, so the message can be sent to AWS. WARN_ONCE will only log one time a WARN about the limit is hit, and drop additional headers, so the message can be sent to AWS. IGNORE will ignore (no logging) and drop additional headers, so the message can be sent to AWS. FAIL will cause an exception to be thrown and the message is not sent to AWS.",
        "datatype": "string",
        "defaultValue": "WARN",
        "secret": false,
        "required": false,
        "group": "producer",
        "enum": [
          "WARN",
          "WARN_ONCE",
          "IGNORE",
          "FAIL"
        ]
      },
      "operation": {
        "title": "Operation",
        "description": "The operation to do in case the user don't want to send only a message",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer",
        "enum": [
          "sendBatchMessage",
          "deleteMessage",
          "listQueues",
          "purgeQueue",
          "deleteQueue"
        ]
      },
      "lazyStartProducer": {
        "title": "Lazy Start Producer",
        "description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "delayQueue": {
        "title": "Delay Queue",
        "description": "Define if you want to apply delaySeconds option to the queue or on single messages",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "proxyHost": {
        "title": "Proxy Host",
        "description": "To define a proxy host when instantiating the SQS client",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "proxy"
      },
      "proxyPort": {
        "title": "Proxy Port",
        "description": "To define a proxy port when instantiating the SQS client",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "proxy"
      },
      "proxyProtocol": {
        "title": "Proxy Protocol",
        "description": "To define a proxy protocol when instantiating the SQS client",
        "datatype": "string",
        "defaultValue": "HTTPS",
        "secret": false,
        "required": false,
        "group": "proxy",
        "enum": [
          "HTTP",
          "HTTPS"
        ]
      },
      "maximumMessageSize": {
        "title": "Maximum Message Size",
        "description": "The maximumMessageSize (in bytes) an SQS message can contain for this queue.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "queue"
      },
      "messageRetentionPeriod": {
        "title": "Message Retention Period",
        "description": "The messageRetentionPeriod (in seconds) a message will be retained by SQS for this queue.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "queue"
      },
      "policy": {
        "title": "Policy",
        "description": "The policy for this queue. It can be loaded by default from classpath, but you can prefix with classpath:, file:, or http: to load the resource from different systems.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "queue"
      },
      "queueUrl": {
        "title": "Queue Url",
        "description": "To define the queueUrl explicitly. All other parameters, which would influence the queueUrl, are ignored. This parameter is intended to be used, to connect to a mock implementation of SQS, for testing purposes.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "queue"
      },
      "receiveMessageWaitTimeSeconds": {
        "title": "Receive Message Wait Time Seconds",
        "description": "If you do not specify WaitTimeSeconds in the request, the queue attribute ReceiveMessageWaitTimeSeconds is used to determine how long to wait.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "queue"
      },
      "redrivePolicy": {
        "title": "Redrive Policy",
        "description": "Specify the policy that send message to DeadLetter queue. See detail at Amazon docs.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "queue"
      },
      "backoffErrorThreshold": {
        "title": "Backoff Error Threshold",
        "description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "backoffIdleThreshold": {
        "title": "Backoff Idle Threshold",
        "description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "backoffMultiplier": {
        "title": "Backoff Multiplier",
        "description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "delay": {
        "title": "Delay",
        "description": "Milliseconds before the next poll.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 500,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "greedy": {
        "title": "Greedy",
        "description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "initialDelay": {
        "title": "Initial Delay",
        "description": "Milliseconds before the first poll starts.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 1000,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "repeatCount": {
        "title": "Repeat Count",
        "description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 0,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "runLoggingLevel": {
        "title": "Run Logging Level",
        "description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
        "datatype": "string",
        "defaultValue": "TRACE",
        "secret": false,
        "required": false,
        "group": "scheduler",
        "enum": [
          "TRACE",
          "DEBUG",
          "INFO",
          "WARN",
          "ERROR",
          "OFF"
        ]
      },
      "startScheduler": {
        "title": "Start Scheduler",
        "description": "Whether the scheduler should be auto started.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "timeUnit": {
        "title": "Time Unit",
        "description": "Time unit for initialDelay and delay options.",
        "datatype": "string",
        "defaultValue": "MILLISECONDS",
        "secret": false,
        "required": false,
        "group": "scheduler",
        "enum": [
          "NANOSECONDS",
          "MICROSECONDS",
          "MILLISECONDS",
          "SECONDS",
          "MINUTES",
          "HOURS",
          "DAYS"
        ]
      },
      "useFixedDelay": {
        "title": "Use Fixed Delay",
        "description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "accessKey": {
        "title": "Access Key",
        "description": "Amazon AWS Access Key",
        "datatype": "string",
        "secret": true,
        "required": false,
        "group": "security"
      },
      "profileCredentialsName": {
        "title": "Profile Credentials Name",
        "description": "If using a profile credentials provider this parameter will set the profile name",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "security"
      },
      "secretKey": {
        "title": "Secret Key",
        "description": "Amazon AWS Secret Key",
        "datatype": "string",
        "secret": true,
        "required": false,
        "group": "security"
      },
      "trustAllCertificates": {
        "title": "Trust All Certificates",
        "description": "If we want to trust all certificates in case of overriding the endpoint",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "security"
      },
      "useDefaultCredentialsProvider": {
        "title": "Use Default Credentials Provider",
        "description": "Set whether the SQS client should expect to load credentials on an AWS infra instance or to expect static credentials to be passed in.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "security"
      },
      "useProfileCredentialsProvider": {
        "title": "Use Profile Credentials Provider",
        "description": "Set whether the SQS client should expect to load credentials through a profile credentials provider.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "security"
      }
    },
    "pathProperties": {
      "queueNameOrArn": {
        "title": "Queue Name Or Arn",
        "description": "Queue name or ARN",
        "datatype": "string",
        "secret": false,
        "required": true
      }
    },
    "producer": true,
    "consumer": true
  },
  {
    "name": "azure-key-vault",
    "title": "Azure Key Vault",
    "description": "Manage secrets and keys in Azure Key Vault Service",
    "iconUrl": "https://tst-ipaas-public-assets.s3.us-east-1.amazonaws.com/images/components/azure-key-vault.svg",
    "syntax": "azure-key-vault:vaultName",
    "properties": {
      "vaultName": {
        "title": "Vault Name",
        "description": "Vault Name to be used",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "operation": {
        "title": "Operation",
        "description": "Operation to be performed",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer",
        "enum": [
          "createSecret",
          "getSecret",
          "deleteSecret",
          "purgeDeletedSecret"
        ]
      },
      "lazyStartProducer": {
        "title": "Lazy Start Producer",
        "description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "clientId": {
        "title": "Client Id",
        "description": "Client Id to be used",
        "datatype": "string",
        "secret": true,
        "required": false,
        "group": "security"
      },
      "clientSecret": {
        "title": "Client Secret",
        "description": "Client Secret to be used",
        "datatype": "string",
        "secret": true,
        "required": false,
        "group": "security"
      },
      "tenantId": {
        "title": "Tenant Id",
        "description": "Tenant Id to be used",
        "datatype": "string",
        "secret": true,
        "required": false,
        "group": "security"
      }
    },
    "pathProperties": {
      "vaultName": {
        "title": "Vault Name",
        "description": "Vault Name to be used",
        "datatype": "string",
        "secret": false,
        "required": false
      }
    },
    "producer": true,
    "consumer": false
  },
  {
    "name": "azure-storage-blob",
    "title": "Azure Storage Blob Service",
    "description": "Store and retrieve blobs from Azure Storage Blob Service.",
    "iconUrl": "https://tst-ipaas-public-assets.s3.us-east-1.amazonaws.com/images/components/azure-storage-blob.svg",
    "syntax": "azure-storage-blob:accountName/containerName",
    "properties": {
      "accountName": {
        "title": "Account Name",
        "description": "Azure account name to be used for authentication with azure blob services",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "common"
      },
      "containerName": {
        "title": "Container Name",
        "description": "The blob container name",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "common"
      },
      "blobName": {
        "title": "Blob Name",
        "description": "The blob name, to consume specific blob from a container. However, on producer it is only required for the operations on the blob level",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "common"
      },
      "blobOffset": {
        "title": "Blob Offset",
        "description": "Set the blob offset for the upload or download operations, default is 0",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 0,
        "secret": false,
        "required": false,
        "group": "common"
      },
      "blobType": {
        "title": "Blob Type",
        "description": "The blob type in order to initiate the appropriate settings for each blob type",
        "datatype": "string",
        "defaultValue": "blockblob",
        "secret": false,
        "required": false,
        "group": "common",
        "enum": [
          "blockblob",
          "appendblob",
          "pageblob"
        ]
      },
      "closeStreamAfterRead": {
        "title": "Close Stream After Read",
        "description": "Close the stream after read or keep it open, default is true",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "common"
      },
      "credentialType": {
        "title": "Credential Type",
        "description": "Determines the credential strategy to adopt",
        "datatype": "string",
        "defaultValue": "AZURE_IDENTITY",
        "secret": false,
        "required": false,
        "group": "common",
        "enum": [
          "SHARED_ACCOUNT_KEY",
          "SHARED_KEY_CREDENTIAL",
          "AZURE_IDENTITY"
        ]
      },
      "dataCount": {
        "title": "Data Count",
        "description": "How many bytes to include in the range. Must be greater than or equal to 0 if specified.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "common"
      },
      "fileDir": {
        "title": "File Dir",
        "description": "The file directory where the downloaded blobs will be saved to, this can be used in both, producer and consumer",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "common"
      },
      "maxResultsPerPage": {
        "title": "Max Results Per Page",
        "description": "Specifies the maximum number of blobs to return, including all BlobPrefix elements. If the request does not specify maxResultsPerPage or specifies a value greater than 5,000, the server will return up to 5,000 items.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "common"
      },
      "maxRetryRequests": {
        "title": "Max Retry Requests",
        "description": "Specifies the maximum number of additional HTTP Get requests that will be made while reading the data from a response body.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 0,
        "secret": false,
        "required": false,
        "group": "common"
      },
      "prefix": {
        "title": "Prefix",
        "description": "Filters the results to return only blobs whose names begin with the specified prefix. May be null to return all blobs.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "common"
      },
      "regex": {
        "title": "Regex",
        "description": "Filters the results to return only blobs whose names match the specified regular expression. May be null to return all if both prefix and regex are set, regex takes the priority and prefix is ignored.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "common"
      },
      "sendEmptyMessageWhenIdle": {
        "title": "Send Empty Message When Idle",
        "description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "bridgeErrorHandler": {
        "title": "Bridge Error Handler",
        "description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "exchangePattern": {
        "title": "Exchange Pattern",
        "description": "Sets the exchange pattern when the consumer creates an exchange.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer (advanced)",
        "enum": [
          "InOnly",
          "InOut"
        ]
      },
      "blobSequenceNumber": {
        "title": "Blob Sequence Number",
        "description": "A user-controlled value that you can use to track requests. The value of the sequence number must be between 0 and 263 - 1.The default value is 0.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 0,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "blockListType": {
        "title": "Block List Type",
        "description": "Specifies which type of blocks to return.",
        "datatype": "string",
        "defaultValue": "COMMITTED",
        "secret": false,
        "required": false,
        "group": "producer",
        "enum": [
          "committed",
          "uncommitted",
          "all"
        ]
      },
      "closeStreamAfterWrite": {
        "title": "Close Stream After Write",
        "description": "Close the stream after write or keep it open, default is true",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "commitBlockListLater": {
        "title": "Commit Block List Later",
        "description": "When is set to true, the staged blocks will not be committed directly.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "createAppendBlob": {
        "title": "Create Append Blob",
        "description": "When is set to true, the append blocks will be created when committing append blocks.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "createPageBlob": {
        "title": "Create Page Blob",
        "description": "When is set to true, the page blob will be created when uploading page blob.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "downloadLinkExpiration": {
        "title": "Download Link Expiration",
        "description": "Override the default expiration (millis) of URL download link.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "operation": {
        "title": "Operation",
        "description": "The blob operation that can be used with this component on the producer",
        "datatype": "string",
        "defaultValue": "listBlobContainers",
        "secret": false,
        "required": false,
        "group": "producer",
        "enum": [
          "listBlobContainers",
          "createBlobContainer",
          "deleteBlobContainer",
          "listBlobs",
          "getBlob",
          "deleteBlob",
          "downloadBlobToFile",
          "downloadLink",
          "uploadBlockBlob",
          "stageBlockBlobList",
          "commitBlobBlockList",
          "getBlobBlockList",
          "createAppendBlob",
          "commitAppendBlob",
          "createPageBlob",
          "uploadPageBlob",
          "resizePageBlob",
          "clearPageBlob",
          "getPageBlobRanges"
        ]
      },
      "pageBlobSize": {
        "title": "Page Blob Size",
        "description": "Specifies the maximum size for the page blob, up to 8 TB. The page blob size must be aligned to a 512-byte boundary.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 512,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "lazyStartProducer": {
        "title": "Lazy Start Producer",
        "description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "backoffErrorThreshold": {
        "title": "Backoff Error Threshold",
        "description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "backoffIdleThreshold": {
        "title": "Backoff Idle Threshold",
        "description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "backoffMultiplier": {
        "title": "Backoff Multiplier",
        "description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "delay": {
        "title": "Delay",
        "description": "Milliseconds before the next poll.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 500,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "greedy": {
        "title": "Greedy",
        "description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "initialDelay": {
        "title": "Initial Delay",
        "description": "Milliseconds before the first poll starts.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 1000,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "repeatCount": {
        "title": "Repeat Count",
        "description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 0,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "runLoggingLevel": {
        "title": "Run Logging Level",
        "description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
        "datatype": "string",
        "defaultValue": "TRACE",
        "secret": false,
        "required": false,
        "group": "scheduler",
        "enum": [
          "TRACE",
          "DEBUG",
          "INFO",
          "WARN",
          "ERROR",
          "OFF"
        ]
      },
      "startScheduler": {
        "title": "Start Scheduler",
        "description": "Whether the scheduler should be auto started.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "timeUnit": {
        "title": "Time Unit",
        "description": "Time unit for initialDelay and delay options.",
        "datatype": "string",
        "defaultValue": "MILLISECONDS",
        "secret": false,
        "required": false,
        "group": "scheduler",
        "enum": [
          "NANOSECONDS",
          "MICROSECONDS",
          "MILLISECONDS",
          "SECONDS",
          "MINUTES",
          "HOURS",
          "DAYS"
        ]
      },
      "useFixedDelay": {
        "title": "Use Fixed Delay",
        "description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "accessKey": {
        "title": "Access Key",
        "description": "Access key for the associated azure account name to be used for authentication with azure blob services",
        "datatype": "string",
        "secret": true,
        "required": false,
        "group": "security"
      },
      "sourceBlobAccessKey": {
        "title": "Source Blob Access Key",
        "description": "Source Blob Access Key: for copyblob operation, sadly, we need to have an accessKey for the source blob we want to copy Passing an accessKey as header, it's unsafe so we could set as key.",
        "datatype": "string",
        "secret": true,
        "required": false,
        "group": "security"
      }
    },
    "pathProperties": {
      "accountName": {
        "title": "Account Name",
        "description": "Azure account name to be used for authentication with azure blob services",
        "datatype": "string",
        "secret": false,
        "required": false
      },
      "containerName": {
        "title": "Container Name",
        "description": "The blob container name",
        "datatype": "string",
        "secret": false,
        "required": false
      }
    },
    "producer": true,
    "consumer": true
  },
  {
    "name": "cron",
    "title": "Cron",
    "description": "A generic interface for triggering events at times specified through the Unix cron syntax.",
    "iconUrl": "https://tst-ipaas-public-assets.s3.us-east-1.amazonaws.com/images/components/cron.svg",
    "syntax": "cron:name",
    "properties": {
      "name": {
        "title": "Name",
        "description": "The name of the cron trigger",
        "datatype": "string",
        "secret": false,
        "required": true,
        "group": "consumer"
      },
      "schedule": {
        "title": "Schedule",
        "description": "A cron expression that will be used to generate events",
        "datatype": "string",
        "secret": false,
        "required": true,
        "group": "consumer"
      },
      "bridgeErrorHandler": {
        "title": "Bridge Error Handler",
        "description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "exchangePattern": {
        "title": "Exchange Pattern",
        "description": "Sets the exchange pattern when the consumer creates an exchange.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer (advanced)",
        "enum": [
          "InOnly",
          "InOut"
        ]
      }
    },
    "pathProperties": {
      "name": {
        "title": "Name",
        "description": "The name of the cron trigger",
        "datatype": "string",
        "secret": false,
        "required": true
      }
    },
    "producer": false,
    "consumer": true
  },
  {
    "name": "dataformat",
    "title": "Data Format",
    "description": "Use a Camel Data Format as a regular Camel Component.",
    "iconUrl": "https://tst-ipaas-public-assets.s3.us-east-1.amazonaws.com/images/components/dataformat.svg",
    "syntax": "dataformat:name:operation",
    "properties": {
      "name": {
        "title": "Name",
        "description": "Name of data format",
        "datatype": "string",
        "secret": false,
        "required": true,
        "group": "producer"
      },
      "operation": {
        "title": "Operation",
        "description": "Operation to use either marshal or unmarshal",
        "datatype": "string",
        "secret": false,
        "required": true,
        "group": "producer",
        "enum": [
          "marshal",
          "unmarshal"
        ]
      },
      "lazyStartProducer": {
        "title": "Lazy Start Producer",
        "description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      }
    },
    "pathProperties": {
      "name": {
        "title": "Name",
        "description": "Name of data format",
        "datatype": "string",
        "secret": false,
        "required": true
      },
      "operation": {
        "title": "Operation",
        "description": "Operation to use either marshal or unmarshal",
        "datatype": "string",
        "secret": false,
        "required": true,
        "enum": [
          "marshal",
          "unmarshal"
        ]
      }
    },
    "producer": true,
    "consumer": false
  },
  {
    "name": "direct",
    "title": "Direct",
    "description": "Call another endpoint from the same Camel Context synchronously.",
    "iconUrl": "https://tst-ipaas-public-assets.s3.us-east-1.amazonaws.com/images/components/direct.svg",
    "syntax": "direct:name",
    "properties": {
      "name": {
        "title": "Name",
        "description": "Name of direct endpoint",
        "datatype": "string",
        "secret": false,
        "required": true,
        "group": "common"
      },
      "bridgeErrorHandler": {
        "title": "Bridge Error Handler",
        "description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "exchangePattern": {
        "title": "Exchange Pattern",
        "description": "Sets the exchange pattern when the consumer creates an exchange.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer (advanced)",
        "enum": [
          "InOnly",
          "InOut"
        ]
      },
      "block": {
        "title": "Block",
        "description": "If sending a message to a direct endpoint which has no active consumer, then we can tell the producer to block and wait for the consumer to become active.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "failIfNoConsumers": {
        "title": "Fail If No Consumers",
        "description": "Whether the producer should fail by throwing an exception, when sending to a DIRECT endpoint with no active consumers.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "timeout": {
        "title": "Timeout",
        "description": "The timeout value to use if block is enabled.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 30000,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "lazyStartProducer": {
        "title": "Lazy Start Producer",
        "description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "synchronous": {
        "title": "Synchronous",
        "description": "Whether synchronous processing is forced. If enabled then the producer thread, will be forced to wait until the message has been completed before the same thread will continue processing. If disabled (default) then the producer thread may be freed and can do other work while the message is continued processed by other threads (reactive).",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "advanced"
      }
    },
    "pathProperties": {
      "name": {
        "title": "Name",
        "description": "Name of direct endpoint",
        "datatype": "string",
        "secret": false,
        "required": true
      }
    },
    "producer": true,
    "consumer": true
  },
  {
    "name": "fhir",
    "title": "FHIR",
    "description": "Exchange information in the healthcare domain using the FHIR (Fast Healthcare Interoperability Resources) standard.",
    "iconUrl": "https://tst-ipaas-public-assets.s3.us-east-1.amazonaws.com/images/components/fhir.svg",
    "syntax": "fhir:apiName/methodName",
    "properties": {
      "apiName": {
        "title": "Api Name",
        "description": "What kind of operation to perform",
        "datatype": "string",
        "secret": false,
        "required": true,
        "group": "common",
        "enum": [
          "CAPABILITIES",
          "CREATE",
          "DELETE",
          "HISTORY",
          "LOAD_PAGE",
          "META",
          "OPERATION",
          "PATCH",
          "READ",
          "SEARCH",
          "TRANSACTION",
          "UPDATE",
          "VALIDATE"
        ]
      },
      "methodName": {
        "title": "Method Name",
        "description": "What sub operation to use for the selected operation",
        "datatype": "string",
        "secret": false,
        "required": true,
        "group": "common"
      },
      "encoding": {
        "title": "Encoding",
        "description": "Encoding to use for all request",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "common",
        "enum": [
          "JSON",
          "XML"
        ]
      },
      "fhirVersion": {
        "title": "Fhir Version",
        "description": "The FHIR Version to use",
        "datatype": "string",
        "defaultValue": "R4",
        "secret": false,
        "required": false,
        "group": "common",
        "enum": [
          "DSTU2",
          "DSTU2_HL7ORG",
          "DSTU2_1",
          "DSTU3",
          "R4",
          "R4B",
          "R5"
        ]
      },
      "inBody": {
        "title": "In Body",
        "description": "Sets the name of a parameter to be passed in the exchange In Body",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "common"
      },
      "log": {
        "title": "Log",
        "description": "Will log every requests and responses",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "common"
      },
      "prettyPrint": {
        "title": "Pretty Print",
        "description": "Pretty print all request",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "common"
      },
      "serverUrl": {
        "title": "Server Url",
        "description": "The FHIR server base URL",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "common"
      },
      "sendEmptyMessageWhenIdle": {
        "title": "Send Empty Message When Idle",
        "description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "bridgeErrorHandler": {
        "title": "Bridge Error Handler",
        "description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "exchangePattern": {
        "title": "Exchange Pattern",
        "description": "Sets the exchange pattern when the consumer creates an exchange.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer (advanced)",
        "enum": [
          "InOnly",
          "InOut"
        ]
      },
      "lazyStartProducer": {
        "title": "Lazy Start Producer",
        "description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "compress": {
        "title": "Compress",
        "description": "Compresses outgoing (POST/PUT) contents to the GZIP format",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "connectionTimeout": {
        "title": "Connection Timeout",
        "description": "How long to try and establish the initial TCP connection (in ms)",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 10000,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "deferModelScanning": {
        "title": "Defer Model Scanning",
        "description": "When this option is set, model classes will not be scanned for children until the child list for the given type is actually accessed.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "forceConformanceCheck": {
        "title": "Force Conformance Check",
        "description": "Force conformance check",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "sessionCookie": {
        "title": "Session Cookie",
        "description": "HTTP session cookie to add to every request",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "socketTimeout": {
        "title": "Socket Timeout",
        "description": "How long to block for individual read/write operations (in ms)",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 10000,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "summary": {
        "title": "Summary",
        "description": "Request that the server modify the response using the _summary param",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "advanced",
        "enum": [
          "COUNT",
          "TEXT",
          "DATA",
          "TRUE",
          "FALSE"
        ]
      },
      "validationMode": {
        "title": "Validation Mode",
        "description": "When should Camel validate the FHIR Server's conformance statement",
        "datatype": "string",
        "defaultValue": "ONCE",
        "secret": false,
        "required": false,
        "group": "advanced",
        "enum": [
          "NEVER",
          "ONCE"
        ]
      },
      "proxyHost": {
        "title": "Proxy Host",
        "description": "The proxy host",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "proxy"
      },
      "proxyPassword": {
        "title": "Proxy Password",
        "description": "The proxy password",
        "datatype": "string",
        "secret": true,
        "required": false,
        "group": "proxy"
      },
      "proxyPort": {
        "title": "Proxy Port",
        "description": "The proxy port",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "proxy"
      },
      "proxyUser": {
        "title": "Proxy User",
        "description": "The proxy username",
        "datatype": "string",
        "secret": true,
        "required": false,
        "group": "proxy"
      },
      "backoffErrorThreshold": {
        "title": "Backoff Error Threshold",
        "description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "backoffIdleThreshold": {
        "title": "Backoff Idle Threshold",
        "description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "backoffMultiplier": {
        "title": "Backoff Multiplier",
        "description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "delay": {
        "title": "Delay",
        "description": "Milliseconds before the next poll.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 500,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "greedy": {
        "title": "Greedy",
        "description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "initialDelay": {
        "title": "Initial Delay",
        "description": "Milliseconds before the first poll starts.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 1000,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "repeatCount": {
        "title": "Repeat Count",
        "description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 0,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "runLoggingLevel": {
        "title": "Run Logging Level",
        "description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
        "datatype": "string",
        "defaultValue": "TRACE",
        "secret": false,
        "required": false,
        "group": "scheduler",
        "enum": [
          "TRACE",
          "DEBUG",
          "INFO",
          "WARN",
          "ERROR",
          "OFF"
        ]
      },
      "startScheduler": {
        "title": "Start Scheduler",
        "description": "Whether the scheduler should be auto started.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "timeUnit": {
        "title": "Time Unit",
        "description": "Time unit for initialDelay and delay options.",
        "datatype": "string",
        "defaultValue": "MILLISECONDS",
        "secret": false,
        "required": false,
        "group": "scheduler",
        "enum": [
          "NANOSECONDS",
          "MICROSECONDS",
          "MILLISECONDS",
          "SECONDS",
          "MINUTES",
          "HOURS",
          "DAYS"
        ]
      },
      "useFixedDelay": {
        "title": "Use Fixed Delay",
        "description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "accessToken": {
        "title": "Access Token",
        "description": "OAuth access token",
        "datatype": "string",
        "secret": true,
        "required": false,
        "group": "security"
      },
      "password": {
        "title": "Password",
        "description": "Password to use for basic authentication",
        "datatype": "string",
        "secret": true,
        "required": false,
        "group": "security"
      },
      "username": {
        "title": "Username",
        "description": "Username to use for basic authentication",
        "datatype": "string",
        "secret": true,
        "required": false,
        "group": "security"
      }
    },
    "pathProperties": {
      "apiName": {
        "title": "Api Name",
        "description": "What kind of operation to perform",
        "datatype": "string",
        "secret": false,
        "required": true,
        "enum": [
          "CAPABILITIES",
          "CREATE",
          "DELETE",
          "HISTORY",
          "LOAD_PAGE",
          "META",
          "OPERATION",
          "PATCH",
          "READ",
          "SEARCH",
          "TRANSACTION",
          "UPDATE",
          "VALIDATE"
        ]
      },
      "methodName": {
        "title": "Method Name",
        "description": "What sub operation to use for the selected operation",
        "datatype": "string",
        "secret": false,
        "required": true
      }
    },
    "producer": true,
    "consumer": true
  },
  {
    "name": "ftp",
    "title": "FTP",
    "description": "Upload and download files to/from FTP servers.",
    "iconUrl": "https://tst-ipaas-public-assets.s3.us-east-1.amazonaws.com/images/components/ftp.svg",
    "syntax": "ftp:host:port/directoryName",
    "properties": {
      "host": {
        "title": "Host",
        "description": "Hostname of the FTP server",
        "datatype": "string",
        "secret": false,
        "required": true,
        "group": "common"
      },
      "port": {
        "title": "Port",
        "description": "Port of the FTP server",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "common"
      },
      "directoryName": {
        "title": "Directory Name",
        "description": "The starting directory",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "common"
      },
      "binary": {
        "title": "Binary",
        "description": "Specifies the file transfer mode, BINARY or ASCII. Default is ASCII (false).",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "common"
      },
      "charset": {
        "title": "Charset",
        "description": "This option is used to specify the encoding of the file. You can use this on the consumer, to specify the encodings of the files, which allow Camel to know the charset it should load the file content in case the file content is being accessed. Likewise when writing a file, you can use this option to specify which charset to write the file as well. Do mind that when writing the file Camel may have to read the message content into memory to be able to convert the data into the configured charset, so do not use this if you have big messages.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "common"
      },
      "disconnect": {
        "title": "Disconnect",
        "description": "Whether or not to disconnect from remote FTP server right after use. Disconnect will only disconnect the current connection to the FTP server. If you have a consumer which you want to stop, then you need to stop the consumer/route instead.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "common"
      },
      "doneFileName": {
        "title": "Done File Name",
        "description": "Producer: If provided, then Camel will write a 2nd done file when the original file has been written. The done file will be empty. This option configures what file name to use. Either you can specify a fixed name. Or you can use dynamic placeholders. The done file will always be written in the same folder as the original file. Consumer: If provided, Camel will only consume files if a done file exists. This option configures what file name to use. Either you can specify a fixed name. Or you can use dynamic placeholders.The done file is always expected in the same folder as the original file. Only ${file.name} and ${file.name.next} is supported as dynamic placeholders.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "common"
      },
      "fileName": {
        "title": "File Name",
        "description": "Use Expression such as File Language to dynamically set the filename. For consumers, it's used as a filename filter. For producers, it's used to evaluate the filename to write. If an expression is set, it take precedence over the CamelFileName header. (Note: The header itself can also be an Expression). The expression options support both String and Expression types. If the expression is a String type, it is always evaluated using the File Language. If the expression is an Expression type, the specified Expression type is used - this allows you, for instance, to use OGNL expressions. For the consumer, you can use it to filter filenames, so you can for instance consume today's file using the File Language syntax: mydata-${date:now:yyyyMMdd}.txt. The producers support the CamelOverruleFileName header which takes precedence over any existing CamelFileName header; the CamelOverruleFileName is a header that is used only once, and makes it easier as this avoids to temporary store CamelFileName and have to restore it afterwards.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "common"
      },
      "passiveMode": {
        "title": "Passive Mode",
        "description": "Sets passive mode connections. Default is active mode connections.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "common"
      },
      "separator": {
        "title": "Separator",
        "description": "Sets the path separator to be used. UNIX = Uses unix style path separator Windows = Uses windows style path separator Auto = (is default) Use existing path separator in file name",
        "datatype": "string",
        "defaultValue": "UNIX",
        "secret": false,
        "required": false,
        "group": "common",
        "enum": [
          "UNIX",
          "Windows",
          "Auto"
        ]
      },
      "transferLoggingIntervalSeconds": {
        "title": "Transfer Logging Interval Seconds",
        "description": "Configures the interval in seconds to use when logging the progress of upload and download operations that are in-flight. This is used for logging progress when operations takes longer time.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 5,
        "secret": false,
        "required": false,
        "group": "common"
      },
      "transferLoggingLevel": {
        "title": "Transfer Logging Level",
        "description": "Configure the logging level to use when logging the progress of upload and download operations.",
        "datatype": "string",
        "defaultValue": "DEBUG",
        "secret": false,
        "required": false,
        "group": "common",
        "enum": [
          "TRACE",
          "DEBUG",
          "INFO",
          "WARN",
          "ERROR",
          "OFF"
        ]
      },
      "transferLoggingVerbose": {
        "title": "Transfer Logging Verbose",
        "description": "Configures whether the perform verbose (fine grained) logging of the progress of upload and download operations.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "common"
      },
      "fastExistsCheck": {
        "title": "Fast Exists Check",
        "description": "If set this option to be true, camel-ftp will use the list file directly to check if the file exists. Since some FTP server may not support to list the file directly, if the option is false, camel-ftp will use the old way to list the directory and check if the file exists. This option also influences readLock=changed to control whether it performs a fast check to update file information or not. This can be used to speed up the process if the FTP server has a lot of files.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "common (advanced)"
      },
      "delete": {
        "title": "Delete",
        "description": "If true, the file will be deleted after it is processed successfully.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "moveFailed": {
        "title": "Move Failed",
        "description": "Sets the move failure expression based on Simple language. For example, to move files into a .error subdirectory use: .error. Note: When moving the files to the fail location Camel will handle the error and will not pick up the file again.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "noop": {
        "title": "Noop",
        "description": "If true, the file is not moved or deleted in any way. This option is good for readonly data, or for ETL type requirements. If noop=true, Camel will set idempotent=true as well, to avoid consuming the same files over and over again.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "preMove": {
        "title": "Pre Move",
        "description": "Expression (such as File Language) used to dynamically set the filename when moving it before processing. For example to move in-progress files into the order directory set this value to order.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "preSort": {
        "title": "Pre Sort",
        "description": "When pre-sort is enabled then the consumer will sort the file and directory names during polling, that was retrieved from the file system. You may want to do this in case you need to operate on the files in a sorted order. The pre-sort is executed before the consumer starts to filter, and accept files to process by Camel. This option is default=false meaning disabled.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "recursive": {
        "title": "Recursive",
        "description": "If a directory, will look for files in all the sub-directories as well.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "resumeDownload": {
        "title": "Resume Download",
        "description": "Configures whether resume download is enabled. This must be supported by the FTP server (almost all FTP servers support it). In addition the options localWorkDirectory must be configured so downloaded files are stored in a local directory, and the option binary must be enabled, which is required to support resuming of downloads.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "sendEmptyMessageWhenIdle": {
        "title": "Send Empty Message When Idle",
        "description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "streamDownload": {
        "title": "Stream Download",
        "description": "Sets the download method to use when not using a local working directory. If set to true, the remote files are streamed to the route as they are read. When set to false, the remote files are loaded into memory before being sent into the route. If enabling this option then you must set stepwise=false as both cannot be enabled at the same time.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "bridgeErrorHandler": {
        "title": "Bridge Error Handler",
        "description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "download": {
        "title": "Download",
        "description": "Whether the FTP consumer should download the file. If this option is set to false, then the message body will be null, but the consumer will still trigger a Camel Exchange that has details about the file such as file name, file size, etc. It's just that the file will not be downloaded.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "exchangePattern": {
        "title": "Exchange Pattern",
        "description": "Sets the exchange pattern when the consumer creates an exchange.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer (advanced)",
        "enum": [
          "InOnly",
          "InOut"
        ]
      },
      "handleDirectoryParserAbsoluteResult": {
        "title": "Handle Directory Parser Absolute Result",
        "description": "Allows you to set how the consumer will handle subfolders and files in the path if the directory parser results in with absolute paths The reason for this is that some FTP servers may return file names with absolute paths, and if so then the FTP component needs to handle this by converting the returned path into a relative path.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "ignoreFileNotFoundOrPermissionError": {
        "title": "Ignore File Not Found Or Permission Error",
        "description": "Whether to ignore when (trying to list files in directories or when downloading a file), which does not exist or due to permission error. By default when a directory or file does not exists or insufficient permission, then an exception is thrown. Setting this option to true allows to ignore that instead.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "localWorkDirectory": {
        "title": "Local Work Directory",
        "description": "When consuming, a local work directory can be used to store the remote file content directly in local files, to avoid loading the content into memory. This is beneficial, if you consume a very big remote file and thus can conserve memory.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "useList": {
        "title": "Use List",
        "description": "Whether to allow using LIST command when downloading a file. Default is true. In some use cases you may want to download a specific file and are not allowed to use the LIST command, and therefore you can set this option to false. Notice when using this option, then the specific file to download does not include meta-data information such as file size, timestamp, permissions etc, because those information is only possible to retrieve when LIST command is in use.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "fileExist": {
        "title": "File Exist",
        "description": "What to do if a file already exists with the same name. Override, which is the default, replaces the existing file. - Append - adds content to the existing file. - Fail - throws a GenericFileOperationException, indicating that there is already an existing file. - Ignore - silently ignores the problem and does not override the existing file, but assumes everything is okay. - Move - option requires to use the moveExisting option to be configured as well. The option eagerDeleteTargetFile can be used to control what to do if an moving the file, and there exists already an existing file, otherwise causing the move operation to fail. The Move option will move any existing files, before writing the target file. - TryRename is only applicable if tempFileName option is in use. This allows to try renaming the file from the temporary name to the actual name, without doing any exists check. This check may be faster on some file systems and especially FTP servers.",
        "datatype": "string",
        "defaultValue": "Override",
        "secret": false,
        "required": false,
        "group": "producer",
        "enum": [
          "Override",
          "Append",
          "Fail",
          "Ignore",
          "Move",
          "TryRename"
        ]
      },
      "flatten": {
        "title": "Flatten",
        "description": "Flatten is used to flatten the file name path to strip any leading paths, so it's just the file name. This allows you to consume recursively into sub-directories, but when you eg write the files to another directory they will be written in a single directory. Setting this to true on the producer enforces that any file name in CamelFileName header will be stripped for any leading paths.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "jailStartingDirectory": {
        "title": "Jail Starting Directory",
        "description": "Used for jailing (restricting) writing files to the starting directory (and sub) only. This is enabled by default to not allow Camel to write files to outside directories (to be more secured out of the box). You can turn this off to allow writing files to directories outside the starting directory, such as parent or root folders.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "moveExisting": {
        "title": "Move Existing",
        "description": "Expression (such as File Language) used to compute file name to use when fileExist=Move is configured. To move files into a backup subdirectory just enter backup. This option only supports the following File Language tokens: file:name, file:name.ext, file:name.noext, file:onlyname, file:onlyname.noext, file:ext, and file:parent. Notice the file:parent is not supported by the FTP component, as the FTP component can only move any existing files to a relative directory based on current dir as base.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "tempFileName": {
        "title": "Temp File Name",
        "description": "The same as tempPrefix option but offering a more fine grained control on the naming of the temporary filename as it uses the File Language. The location for tempFilename is relative to the final file location in the option 'fileName', not the target directory in the base uri. For example if option fileName includes a directory prefix: dir/finalFilename then tempFileName is relative to that subdirectory dir.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "tempPrefix": {
        "title": "Temp Prefix",
        "description": "This option is used to write the file using a temporary name and then, after the write is complete, rename it to the real name. Can be used to identify files being written and also avoid consumers (not using exclusive read locks) reading in progress files. Is often used by FTP when uploading big files.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "allowNullBody": {
        "title": "Allow Null Body",
        "description": "Used to specify if a null body is allowed during file writing. If set to true then an empty file will be created, when set to false, and attempting to send a null body to the file component, a GenericFileWriteException of 'Cannot write null body to file.' will be thrown. If the fileExist option is set to 'Override', then the file will be truncated, and if set to append the file will remain unchanged.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "chmod": {
        "title": "Chmod",
        "description": "Allows you to set chmod on the stored file. For example chmod=640.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "disconnectOnBatchComplete": {
        "title": "Disconnect On Batch Complete",
        "description": "Whether or not to disconnect from remote FTP server right after a Batch upload is complete. disconnectOnBatchComplete will only disconnect the current connection to the FTP server.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "eagerDeleteTargetFile": {
        "title": "Eager Delete Target File",
        "description": "Whether or not to eagerly delete any existing target file. This option only applies when you use fileExists=Override and the tempFileName option as well. You can use this to disable (set it to false) deleting the target file before the temp file is written. For example you may write big files and want the target file to exists during the temp file is being written. This ensure the target file is only deleted until the very last moment, just before the temp file is being renamed to the target filename. This option is also used to control whether to delete any existing files when fileExist=Move is enabled, and an existing file exists. If this option copyAndDeleteOnRenameFails false, then an exception will be thrown if an existing file existed, if its true, then the existing file is deleted before the move operation.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "keepLastModified": {
        "title": "Keep Last Modified",
        "description": "Will keep the last modified timestamp from the source file (if any). Will use the FileConstants.FILE_LAST_MODIFIED header to located the timestamp. This header can contain either a java.util.Date or long with the timestamp. If the timestamp exists and the option is enabled it will set this timestamp on the written file. Note: This option only applies to the file producer. You cannot use this option with any of the ftp producers.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "lazyStartProducer": {
        "title": "Lazy Start Producer",
        "description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "sendNoop": {
        "title": "Send Noop",
        "description": "Whether to send a noop command as a pre-write check before uploading files to the FTP server. This is enabled by default as a validation of the connection is still valid, which allows to silently re-connect to be able to upload the file. However if this causes problems, you can turn this option off.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "activePortRange": {
        "title": "Active Port Range",
        "description": "Set the client side port range in active mode. The syntax is: minPort-maxPort Both port numbers are inclusive, eg 10000-19999 to include all 1xxxx ports.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "autoCreate": {
        "title": "Auto Create",
        "description": "Automatically create missing directories in the file's pathname. For the file consumer, that means creating the starting directory. For the file producer, it means the directory the files should be written to.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "bufferSize": {
        "title": "Buffer Size",
        "description": "Buffer size in bytes used for writing files (or in case of FTP for downloading and uploading files).",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 131072,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "connectTimeout": {
        "title": "Connect Timeout",
        "description": "Sets the connect timeout for waiting for a connection to be established Used by both FTPClient and JSCH",
        "datatype": "number",
        "format": "duration",
        "defaultValue": 10000,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "maximumReconnectAttempts": {
        "title": "Maximum Reconnect Attempts",
        "description": "Specifies the maximum reconnect attempts Camel performs when it tries to connect to the remote FTP server. Use 0 to disable this behavior.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "reconnectDelay": {
        "title": "Reconnect Delay",
        "description": "Delay in millis Camel will wait before performing a reconnect attempt.",
        "datatype": "number",
        "format": "duration",
        "defaultValue": 1000,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "siteCommand": {
        "title": "Site Command",
        "description": "Sets optional site command(s) to be executed after successful login. Multiple site commands can be separated using a new line character.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "soTimeout": {
        "title": "So Timeout",
        "description": "Sets the so timeout FTP and FTPS Is the SocketOptions.SO_TIMEOUT value in millis. Recommended option is to set this to 300000 so as not have a hanged connection. On SFTP this option is set as timeout on the JSCH Session instance.",
        "datatype": "number",
        "format": "duration",
        "defaultValue": 300000,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "stepwise": {
        "title": "Stepwise",
        "description": "Sets whether we should stepwise change directories while traversing file structures when downloading files, or as well when uploading a file to a directory. You can disable this if you for example are in a situation where you cannot change directory on the FTP server due security reasons. Stepwise cannot be used together with streamDownload.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "throwExceptionOnConnectFailed": {
        "title": "Throw Exception On Connect Failed",
        "description": "Should an exception be thrown if connection failed (exhausted)By default exception is not thrown and a WARN is logged. You can use this to enable exception being thrown and handle the thrown exception from the org.apache.camel.spi.PollingConsumerPollStrategy rollback method.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "timeout": {
        "title": "Timeout",
        "description": "Sets the data timeout for waiting for reply Used only by FTPClient",
        "datatype": "number",
        "format": "duration",
        "defaultValue": 30000,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "antExclude": {
        "title": "Ant Exclude",
        "description": "Ant style filter exclusion. If both antInclude and antExclude are used, antExclude takes precedence over antInclude. Multiple exclusions may be specified in comma-delimited format.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "filter"
      },
      "antFilterCaseSensitive": {
        "title": "Ant Filter Case Sensitive",
        "description": "Sets case sensitive flag on ant filter.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "filter"
      },
      "antInclude": {
        "title": "Ant Include",
        "description": "Ant style filter inclusion. Multiple inclusions may be specified in comma-delimited format.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "filter"
      },
      "eagerMaxMessagesPerPoll": {
        "title": "Eager Max Messages Per Poll",
        "description": "Allows for controlling whether the limit from maxMessagesPerPoll is eager or not. If eager then the limit is during the scanning of files. Where as false would scan all files, and then perform sorting. Setting this option to false allows for sorting all files first, and then limit the poll. Mind that this requires a higher memory usage as all file details are in memory to perform the sorting.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "filter"
      },
      "exclude": {
        "title": "Exclude",
        "description": "Is used to exclude files, if filename matches the regex pattern (matching is case in-sensitive). Notice if you use symbols such as plus sign and others you would need to configure this using the RAW() syntax if configuring this as an endpoint uri. See more details at configuring endpoint uris",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "filter"
      },
      "excludeExt": {
        "title": "Exclude Ext",
        "description": "Is used to exclude files matching file extension name (case insensitive). For example to exclude bak files, then use excludeExt=bak. Multiple extensions can be separated by comma, for example to exclude bak and dat files, use excludeExt=bak,dat. Note that the file extension includes all parts, for example having a file named mydata.tar.gz will have extension as tar.gz. For more flexibility then use the include/exclude options.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "filter"
      },
      "filterDirectory": {
        "title": "Filter Directory",
        "description": "Filters the directory based on Simple language. For example to filter on current date, you can use a simple date pattern such as ${date:now:yyyMMdd}",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "filter"
      },
      "filterFile": {
        "title": "Filter File",
        "description": "Filters the file based on Simple language. For example to filter on file size, you can use ${file:size} 5000",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "filter"
      },
      "idempotent": {
        "title": "Idempotent",
        "description": "Option to use the Idempotent Consumer EIP pattern to let Camel skip already processed files. Will by default use a memory based LRUCache that holds 1000 entries. If noop=true then idempotent will be enabled as well to avoid consuming the same files over and over again.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "filter"
      },
      "idempotentKey": {
        "title": "Idempotent Key",
        "description": "To use a custom idempotent key. By default the absolute path of the file is used. You can use the File Language, for example to use the file name and file size, you can do: idempotentKey=${file:name}-${file:size}",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "filter"
      },
      "include": {
        "title": "Include",
        "description": "Is used to include files, if filename matches the regex pattern (matching is case in-sensitive). Notice if you use symbols such as plus sign and others you would need to configure this using the RAW() syntax if configuring this as an endpoint uri. See more details at configuring endpoint uris",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "filter"
      },
      "includeExt": {
        "title": "Include Ext",
        "description": "Is used to include files matching file extension name (case insensitive). For example to include txt files, then use includeExt=txt. Multiple extensions can be separated by comma, for example to include txt and xml files, use includeExt=txt,xml. Note that the file extension includes all parts, for example having a file named mydata.tar.gz will have extension as tar.gz. For more flexibility then use the include/exclude options.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "filter"
      },
      "maxDepth": {
        "title": "Max Depth",
        "description": "The maximum depth to traverse when recursively processing a directory.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 2147483647,
        "secret": false,
        "required": false,
        "group": "filter"
      },
      "maxMessagesPerPoll": {
        "title": "Max Messages Per Poll",
        "description": "To define a maximum messages to gather per poll. By default no maximum is set. Can be used to set a limit of e.g. 1000 to avoid when starting up the server that there are thousands of files. Set a value of 0 or negative to disabled it. Notice: If this option is in use then the File and FTP components will limit before any sorting. For example if you have 100000 files and use maxMessagesPerPoll=500, then only the first 500 files will be picked up, and then sorted. You can use the eagerMaxMessagesPerPoll option and set this to false to allow to scan all files first and then sort afterwards.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "filter"
      },
      "minDepth": {
        "title": "Min Depth",
        "description": "The minimum depth to start processing when recursively processing a directory. Using minDepth=1 means the base directory. Using minDepth=2 means the first sub directory.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "filter"
      },
      "move": {
        "title": "Move",
        "description": "Expression (such as Simple Language) used to dynamically set the filename when moving it after processing. To move files into a .done subdirectory just enter .done.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "filter"
      },
      "readLock": {
        "title": "Read Lock",
        "description": "Used by consumer, to only poll the files if it has exclusive read-lock on the file (i.e. the file is not in-progress or being written). Camel will wait until the file lock is granted. This option provides the build in strategies: - none - No read lock is in use - markerFile - Camel creates a marker file (fileName.camelLock) and then holds a lock on it. This option is not available for the FTP component - changed - Changed is using file length/modification timestamp to detect whether the file is currently being copied or not. Will at least use 1 sec to determine this, so this option cannot consume files as fast as the others, but can be more reliable as the JDK IO API cannot always determine whether a file is currently being used by another process. The option readLockCheckInterval can be used to set the check frequency. - fileLock - is for using java.nio.channels.FileLock. This option is not avail for Windows OS and the FTP component. This approach should be avoided when accessing a remote file system via a mount/share unless that file system supports distributed file locks. - rename - rename is for using a try to rename the file as a test if we can get exclusive read-lock. - idempotent - (only for file component) idempotent is for using a idempotentRepository as the read-lock. This allows to use read locks that supports clustering if the idempotent repository implementation supports that. - idempotent-changed - (only for file component) idempotent-changed is for using a idempotentRepository and changed as the combined read-lock. This allows to use read locks that supports clustering if the idempotent repository implementation supports that. - idempotent-rename - (only for file component) idempotent-rename is for using a idempotentRepository and rename as the combined read-lock. This allows to use read locks that supports clustering if the idempotent repository implementation supports that.Notice: The various read locks is not all suited to work in clustered mode, where concurrent consumers on different nodes is competing for the same files on a shared file system. The markerFile using a close to atomic operation to create the empty marker file, but its not guaranteed to work in a cluster. The fileLock may work better but then the file system need to support distributed file locks, and so on. Using the idempotent read lock can support clustering if the idempotent repository supports clustering, such as Hazelcast Component or Infinispan.",
        "datatype": "string",
        "defaultValue": "none",
        "secret": false,
        "required": false,
        "group": "lock",
        "enum": [
          "none",
          "markerFile",
          "fileLock",
          "rename",
          "changed",
          "idempotent",
          "idempotent-changed",
          "idempotent-rename"
        ]
      },
      "readLockCheckInterval": {
        "title": "Read Lock Check Interval",
        "description": "Interval in millis for the read-lock, if supported by the read lock. This interval is used for sleeping between attempts to acquire the read lock. For example when using the changed read lock, you can set a higher interval period to cater for slow writes. The default of 1 sec. may be too fast if the producer is very slow writing the file. Notice: For FTP the default readLockCheckInterval is 5000. The readLockTimeout value must be higher than readLockCheckInterval, but a rule of thumb is to have a timeout that is at least 2 or more times higher than the readLockCheckInterval. This is needed to ensure that amble time is allowed for the read lock process to try to grab the lock before the timeout was hit.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 1000,
        "secret": false,
        "required": false,
        "group": "lock"
      },
      "readLockDeleteOrphanLockFiles": {
        "title": "Read Lock Delete Orphan Lock Files",
        "description": "Whether or not read lock with marker files should upon startup delete any orphan read lock files, which may have been left on the file system, if Camel was not properly shutdown (such as a JVM crash). If turning this option to false then any orphaned lock file will cause Camel to not attempt to pickup that file, this could also be due another node is concurrently reading files from the same shared directory.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "lock"
      },
      "readLockLoggingLevel": {
        "title": "Read Lock Logging Level",
        "description": "Logging level used when a read lock could not be acquired. By default a DEBUG is logged. You can change this level, for example to OFF to not have any logging. This option is only applicable for readLock of types: changed, fileLock, idempotent, idempotent-changed, idempotent-rename, rename.",
        "datatype": "string",
        "defaultValue": "DEBUG",
        "secret": false,
        "required": false,
        "group": "lock",
        "enum": [
          "TRACE",
          "DEBUG",
          "INFO",
          "WARN",
          "ERROR",
          "OFF"
        ]
      },
      "readLockMarkerFile": {
        "title": "Read Lock Marker File",
        "description": "Whether to use marker file with the changed, rename, or exclusive read lock types. By default a marker file is used as well to guard against other processes picking up the same files. This behavior can be turned off by setting this option to false. For example if you do not want to write marker files to the file systems by the Camel application.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "lock"
      },
      "readLockMinAge": {
        "title": "Read Lock Min Age",
        "description": "This option is applied only for readLock=changed. It allows to specify a minimum age the file must be before attempting to acquire the read lock. For example use readLockMinAge=300s to require the file is at last 5 minutes old. This can speedup the changed read lock as it will only attempt to acquire files which are at least that given age.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 0,
        "secret": false,
        "required": false,
        "group": "lock"
      },
      "readLockMinLength": {
        "title": "Read Lock Min Length",
        "description": "This option is applied only for readLock=changed. It allows you to configure a minimum file length. By default Camel expects the file to contain data, and thus the default value is 1. You can set this option to zero, to allow consuming zero-length files.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 1,
        "secret": false,
        "required": false,
        "group": "lock"
      },
      "readLockRemoveOnCommit": {
        "title": "Read Lock Remove On Commit",
        "description": "This option is applied only for readLock=idempotent. It allows to specify whether to remove the file name entry from the idempotent repository when processing the file is succeeded and a commit happens. By default the file is not removed which ensures that any race-condition do not occur so another active node may attempt to grab the file. Instead the idempotent repository may support eviction strategies that you can configure to evict the file name entry after X minutes - this ensures no problems with race conditions. See more details at the readLockIdempotentReleaseDelay option.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "lock"
      },
      "readLockRemoveOnRollback": {
        "title": "Read Lock Remove On Rollback",
        "description": "This option is applied only for readLock=idempotent. It allows to specify whether to remove the file name entry from the idempotent repository when processing the file failed and a rollback happens. If this option is false, then the file name entry is confirmed (as if the file did a commit).",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "lock"
      },
      "readLockTimeout": {
        "title": "Read Lock Timeout",
        "description": "Optional timeout in millis for the read-lock, if supported by the read-lock. If the read-lock could not be granted and the timeout triggered, then Camel will skip the file. At next poll Camel, will try the file again, and this time maybe the read-lock could be granted. Use a value of 0 or lower to indicate forever. Currently fileLock, changed and rename support the timeout. Notice: For FTP the default readLockTimeout value is 20000 instead of 10000. The readLockTimeout value must be higher than readLockCheckInterval, but a rule of thumb is to have a timeout that is at least 2 or more times higher than the readLockCheckInterval. This is needed to ensure that amble time is allowed for the read lock process to try to grab the lock before the timeout was hit.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 10000,
        "secret": false,
        "required": false,
        "group": "lock"
      },
      "backoffErrorThreshold": {
        "title": "Backoff Error Threshold",
        "description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "backoffIdleThreshold": {
        "title": "Backoff Idle Threshold",
        "description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "backoffMultiplier": {
        "title": "Backoff Multiplier",
        "description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "delay": {
        "title": "Delay",
        "description": "Milliseconds before the next poll.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 500,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "greedy": {
        "title": "Greedy",
        "description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "initialDelay": {
        "title": "Initial Delay",
        "description": "Milliseconds before the first poll starts.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 1000,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "repeatCount": {
        "title": "Repeat Count",
        "description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 0,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "runLoggingLevel": {
        "title": "Run Logging Level",
        "description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
        "datatype": "string",
        "defaultValue": "TRACE",
        "secret": false,
        "required": false,
        "group": "scheduler",
        "enum": [
          "TRACE",
          "DEBUG",
          "INFO",
          "WARN",
          "ERROR",
          "OFF"
        ]
      },
      "startScheduler": {
        "title": "Start Scheduler",
        "description": "Whether the scheduler should be auto started.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "timeUnit": {
        "title": "Time Unit",
        "description": "Time unit for initialDelay and delay options.",
        "datatype": "string",
        "defaultValue": "MILLISECONDS",
        "secret": false,
        "required": false,
        "group": "scheduler",
        "enum": [
          "NANOSECONDS",
          "MICROSECONDS",
          "MILLISECONDS",
          "SECONDS",
          "MINUTES",
          "HOURS",
          "DAYS"
        ]
      },
      "useFixedDelay": {
        "title": "Use Fixed Delay",
        "description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "account": {
        "title": "Account",
        "description": "Account to use for login",
        "datatype": "string",
        "secret": true,
        "required": false,
        "group": "security"
      },
      "password": {
        "title": "Password",
        "description": "Password to use for login",
        "datatype": "string",
        "secret": true,
        "required": false,
        "group": "security"
      },
      "username": {
        "title": "Username",
        "description": "Username to use for login",
        "datatype": "string",
        "secret": true,
        "required": false,
        "group": "security"
      },
      "shuffle": {
        "title": "Shuffle",
        "description": "To shuffle the list of files (sort in random order)",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "sort"
      },
      "sortBy": {
        "title": "Sort By",
        "description": "Built-in sort by using the File Language. Supports nested sorts, so you can have a sort by file name and as a 2nd group sort by modified date.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "sort"
      }
    },
    "pathProperties": {
      "host": {
        "title": "Host",
        "description": "Hostname of the FTP server",
        "datatype": "string",
        "secret": false,
        "required": true
      },
      "port": {
        "title": "Port",
        "description": "Port of the FTP server",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false
      },
      "directoryName": {
        "title": "Directory Name",
        "description": "The starting directory",
        "datatype": "string",
        "secret": false,
        "required": false
      }
    },
    "producer": true,
    "consumer": true
  },
  {
    "name": "ftps",
    "title": "FTPS",
    "description": "Upload and download files to/from FTP servers supporting the FTPS protocol.",
    "iconUrl": "https://tst-ipaas-public-assets.s3.us-east-1.amazonaws.com/images/components/ftps.svg",
    "syntax": "ftps:host:port/directoryName",
    "properties": {
      "host": {
        "title": "Host",
        "description": "Hostname of the FTP server",
        "datatype": "string",
        "secret": false,
        "required": true,
        "group": "common"
      },
      "port": {
        "title": "Port",
        "description": "Port of the FTP server",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "common"
      },
      "directoryName": {
        "title": "Directory Name",
        "description": "The starting directory",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "common"
      },
      "binary": {
        "title": "Binary",
        "description": "Specifies the file transfer mode, BINARY or ASCII. Default is ASCII (false).",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "common"
      },
      "charset": {
        "title": "Charset",
        "description": "This option is used to specify the encoding of the file. You can use this on the consumer, to specify the encodings of the files, which allow Camel to know the charset it should load the file content in case the file content is being accessed. Likewise when writing a file, you can use this option to specify which charset to write the file as well. Do mind that when writing the file Camel may have to read the message content into memory to be able to convert the data into the configured charset, so do not use this if you have big messages.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "common"
      },
      "disconnect": {
        "title": "Disconnect",
        "description": "Whether or not to disconnect from remote FTP server right after use. Disconnect will only disconnect the current connection to the FTP server. If you have a consumer which you want to stop, then you need to stop the consumer/route instead.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "common"
      },
      "doneFileName": {
        "title": "Done File Name",
        "description": "Producer: If provided, then Camel will write a 2nd done file when the original file has been written. The done file will be empty. This option configures what file name to use. Either you can specify a fixed name. Or you can use dynamic placeholders. The done file will always be written in the same folder as the original file. Consumer: If provided, Camel will only consume files if a done file exists. This option configures what file name to use. Either you can specify a fixed name. Or you can use dynamic placeholders.The done file is always expected in the same folder as the original file. Only ${file.name} and ${file.name.next} is supported as dynamic placeholders.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "common"
      },
      "fileName": {
        "title": "File Name",
        "description": "Use Expression such as File Language to dynamically set the filename. For consumers, it's used as a filename filter. For producers, it's used to evaluate the filename to write. If an expression is set, it take precedence over the CamelFileName header. (Note: The header itself can also be an Expression). The expression options support both String and Expression types. If the expression is a String type, it is always evaluated using the File Language. If the expression is an Expression type, the specified Expression type is used - this allows you, for instance, to use OGNL expressions. For the consumer, you can use it to filter filenames, so you can for instance consume today's file using the File Language syntax: mydata-${date:now:yyyyMMdd}.txt. The producers support the CamelOverruleFileName header which takes precedence over any existing CamelFileName header; the CamelOverruleFileName is a header that is used only once, and makes it easier as this avoids to temporary store CamelFileName and have to restore it afterwards.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "common"
      },
      "passiveMode": {
        "title": "Passive Mode",
        "description": "Sets passive mode connections. Default is active mode connections.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "common"
      },
      "separator": {
        "title": "Separator",
        "description": "Sets the path separator to be used. UNIX = Uses unix style path separator Windows = Uses windows style path separator Auto = (is default) Use existing path separator in file name",
        "datatype": "string",
        "defaultValue": "UNIX",
        "secret": false,
        "required": false,
        "group": "common",
        "enum": [
          "UNIX",
          "Windows",
          "Auto"
        ]
      },
      "transferLoggingIntervalSeconds": {
        "title": "Transfer Logging Interval Seconds",
        "description": "Configures the interval in seconds to use when logging the progress of upload and download operations that are in-flight. This is used for logging progress when operations takes longer time.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 5,
        "secret": false,
        "required": false,
        "group": "common"
      },
      "transferLoggingLevel": {
        "title": "Transfer Logging Level",
        "description": "Configure the logging level to use when logging the progress of upload and download operations.",
        "datatype": "string",
        "defaultValue": "DEBUG",
        "secret": false,
        "required": false,
        "group": "common",
        "enum": [
          "TRACE",
          "DEBUG",
          "INFO",
          "WARN",
          "ERROR",
          "OFF"
        ]
      },
      "transferLoggingVerbose": {
        "title": "Transfer Logging Verbose",
        "description": "Configures whether the perform verbose (fine grained) logging of the progress of upload and download operations.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "common"
      },
      "fastExistsCheck": {
        "title": "Fast Exists Check",
        "description": "If set this option to be true, camel-ftp will use the list file directly to check if the file exists. Since some FTP server may not support to list the file directly, if the option is false, camel-ftp will use the old way to list the directory and check if the file exists. This option also influences readLock=changed to control whether it performs a fast check to update file information or not. This can be used to speed up the process if the FTP server has a lot of files.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "common (advanced)"
      },
      "delete": {
        "title": "Delete",
        "description": "If true, the file will be deleted after it is processed successfully.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "moveFailed": {
        "title": "Move Failed",
        "description": "Sets the move failure expression based on Simple language. For example, to move files into a .error subdirectory use: .error. Note: When moving the files to the fail location Camel will handle the error and will not pick up the file again.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "noop": {
        "title": "Noop",
        "description": "If true, the file is not moved or deleted in any way. This option is good for readonly data, or for ETL type requirements. If noop=true, Camel will set idempotent=true as well, to avoid consuming the same files over and over again.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "preMove": {
        "title": "Pre Move",
        "description": "Expression (such as File Language) used to dynamically set the filename when moving it before processing. For example to move in-progress files into the order directory set this value to order.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "preSort": {
        "title": "Pre Sort",
        "description": "When pre-sort is enabled then the consumer will sort the file and directory names during polling, that was retrieved from the file system. You may want to do this in case you need to operate on the files in a sorted order. The pre-sort is executed before the consumer starts to filter, and accept files to process by Camel. This option is default=false meaning disabled.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "recursive": {
        "title": "Recursive",
        "description": "If a directory, will look for files in all the sub-directories as well.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "resumeDownload": {
        "title": "Resume Download",
        "description": "Configures whether resume download is enabled. This must be supported by the FTP server (almost all FTP servers support it). In addition the options localWorkDirectory must be configured so downloaded files are stored in a local directory, and the option binary must be enabled, which is required to support resuming of downloads.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "sendEmptyMessageWhenIdle": {
        "title": "Send Empty Message When Idle",
        "description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "streamDownload": {
        "title": "Stream Download",
        "description": "Sets the download method to use when not using a local working directory. If set to true, the remote files are streamed to the route as they are read. When set to false, the remote files are loaded into memory before being sent into the route. If enabling this option then you must set stepwise=false as both cannot be enabled at the same time.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "bridgeErrorHandler": {
        "title": "Bridge Error Handler",
        "description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "download": {
        "title": "Download",
        "description": "Whether the FTP consumer should download the file. If this option is set to false, then the message body will be null, but the consumer will still trigger a Camel Exchange that has details about the file such as file name, file size, etc. It's just that the file will not be downloaded.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "exchangePattern": {
        "title": "Exchange Pattern",
        "description": "Sets the exchange pattern when the consumer creates an exchange.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer (advanced)",
        "enum": [
          "InOnly",
          "InOut"
        ]
      },
      "handleDirectoryParserAbsoluteResult": {
        "title": "Handle Directory Parser Absolute Result",
        "description": "Allows you to set how the consumer will handle subfolders and files in the path if the directory parser results in with absolute paths The reason for this is that some FTP servers may return file names with absolute paths, and if so then the FTP component needs to handle this by converting the returned path into a relative path.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "ignoreFileNotFoundOrPermissionError": {
        "title": "Ignore File Not Found Or Permission Error",
        "description": "Whether to ignore when (trying to list files in directories or when downloading a file), which does not exist or due to permission error. By default when a directory or file does not exists or insufficient permission, then an exception is thrown. Setting this option to true allows to ignore that instead.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "localWorkDirectory": {
        "title": "Local Work Directory",
        "description": "When consuming, a local work directory can be used to store the remote file content directly in local files, to avoid loading the content into memory. This is beneficial, if you consume a very big remote file and thus can conserve memory.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "useList": {
        "title": "Use List",
        "description": "Whether to allow using LIST command when downloading a file. Default is true. In some use cases you may want to download a specific file and are not allowed to use the LIST command, and therefore you can set this option to false. Notice when using this option, then the specific file to download does not include meta-data information such as file size, timestamp, permissions etc, because those information is only possible to retrieve when LIST command is in use.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "fileExist": {
        "title": "File Exist",
        "description": "What to do if a file already exists with the same name. Override, which is the default, replaces the existing file. - Append - adds content to the existing file. - Fail - throws a GenericFileOperationException, indicating that there is already an existing file. - Ignore - silently ignores the problem and does not override the existing file, but assumes everything is okay. - Move - option requires to use the moveExisting option to be configured as well. The option eagerDeleteTargetFile can be used to control what to do if an moving the file, and there exists already an existing file, otherwise causing the move operation to fail. The Move option will move any existing files, before writing the target file. - TryRename is only applicable if tempFileName option is in use. This allows to try renaming the file from the temporary name to the actual name, without doing any exists check. This check may be faster on some file systems and especially FTP servers.",
        "datatype": "string",
        "defaultValue": "Override",
        "secret": false,
        "required": false,
        "group": "producer",
        "enum": [
          "Override",
          "Append",
          "Fail",
          "Ignore",
          "Move",
          "TryRename"
        ]
      },
      "flatten": {
        "title": "Flatten",
        "description": "Flatten is used to flatten the file name path to strip any leading paths, so it's just the file name. This allows you to consume recursively into sub-directories, but when you eg write the files to another directory they will be written in a single directory. Setting this to true on the producer enforces that any file name in CamelFileName header will be stripped for any leading paths.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "jailStartingDirectory": {
        "title": "Jail Starting Directory",
        "description": "Used for jailing (restricting) writing files to the starting directory (and sub) only. This is enabled by default to not allow Camel to write files to outside directories (to be more secured out of the box). You can turn this off to allow writing files to directories outside the starting directory, such as parent or root folders.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "moveExisting": {
        "title": "Move Existing",
        "description": "Expression (such as File Language) used to compute file name to use when fileExist=Move is configured. To move files into a backup subdirectory just enter backup. This option only supports the following File Language tokens: file:name, file:name.ext, file:name.noext, file:onlyname, file:onlyname.noext, file:ext, and file:parent. Notice the file:parent is not supported by the FTP component, as the FTP component can only move any existing files to a relative directory based on current dir as base.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "tempFileName": {
        "title": "Temp File Name",
        "description": "The same as tempPrefix option but offering a more fine grained control on the naming of the temporary filename as it uses the File Language. The location for tempFilename is relative to the final file location in the option 'fileName', not the target directory in the base uri. For example if option fileName includes a directory prefix: dir/finalFilename then tempFileName is relative to that subdirectory dir.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "tempPrefix": {
        "title": "Temp Prefix",
        "description": "This option is used to write the file using a temporary name and then, after the write is complete, rename it to the real name. Can be used to identify files being written and also avoid consumers (not using exclusive read locks) reading in progress files. Is often used by FTP when uploading big files.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "allowNullBody": {
        "title": "Allow Null Body",
        "description": "Used to specify if a null body is allowed during file writing. If set to true then an empty file will be created, when set to false, and attempting to send a null body to the file component, a GenericFileWriteException of 'Cannot write null body to file.' will be thrown. If the fileExist option is set to 'Override', then the file will be truncated, and if set to append the file will remain unchanged.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "chmod": {
        "title": "Chmod",
        "description": "Allows you to set chmod on the stored file. For example chmod=640.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "disconnectOnBatchComplete": {
        "title": "Disconnect On Batch Complete",
        "description": "Whether or not to disconnect from remote FTP server right after a Batch upload is complete. disconnectOnBatchComplete will only disconnect the current connection to the FTP server.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "eagerDeleteTargetFile": {
        "title": "Eager Delete Target File",
        "description": "Whether or not to eagerly delete any existing target file. This option only applies when you use fileExists=Override and the tempFileName option as well. You can use this to disable (set it to false) deleting the target file before the temp file is written. For example you may write big files and want the target file to exists during the temp file is being written. This ensure the target file is only deleted until the very last moment, just before the temp file is being renamed to the target filename. This option is also used to control whether to delete any existing files when fileExist=Move is enabled, and an existing file exists. If this option copyAndDeleteOnRenameFails false, then an exception will be thrown if an existing file existed, if its true, then the existing file is deleted before the move operation.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "keepLastModified": {
        "title": "Keep Last Modified",
        "description": "Will keep the last modified timestamp from the source file (if any). Will use the FileConstants.FILE_LAST_MODIFIED header to located the timestamp. This header can contain either a java.util.Date or long with the timestamp. If the timestamp exists and the option is enabled it will set this timestamp on the written file. Note: This option only applies to the file producer. You cannot use this option with any of the ftp producers.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "lazyStartProducer": {
        "title": "Lazy Start Producer",
        "description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "sendNoop": {
        "title": "Send Noop",
        "description": "Whether to send a noop command as a pre-write check before uploading files to the FTP server. This is enabled by default as a validation of the connection is still valid, which allows to silently re-connect to be able to upload the file. However if this causes problems, you can turn this option off.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "activePortRange": {
        "title": "Active Port Range",
        "description": "Set the client side port range in active mode. The syntax is: minPort-maxPort Both port numbers are inclusive, eg 10000-19999 to include all 1xxxx ports.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "autoCreate": {
        "title": "Auto Create",
        "description": "Automatically create missing directories in the file's pathname. For the file consumer, that means creating the starting directory. For the file producer, it means the directory the files should be written to.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "bufferSize": {
        "title": "Buffer Size",
        "description": "Buffer size in bytes used for writing files (or in case of FTP for downloading and uploading files).",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 131072,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "connectTimeout": {
        "title": "Connect Timeout",
        "description": "Sets the connect timeout for waiting for a connection to be established Used by both FTPClient and JSCH",
        "datatype": "number",
        "format": "duration",
        "defaultValue": 10000,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "maximumReconnectAttempts": {
        "title": "Maximum Reconnect Attempts",
        "description": "Specifies the maximum reconnect attempts Camel performs when it tries to connect to the remote FTP server. Use 0 to disable this behavior.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "reconnectDelay": {
        "title": "Reconnect Delay",
        "description": "Delay in millis Camel will wait before performing a reconnect attempt.",
        "datatype": "number",
        "format": "duration",
        "defaultValue": 1000,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "siteCommand": {
        "title": "Site Command",
        "description": "Sets optional site command(s) to be executed after successful login. Multiple site commands can be separated using a new line character.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "soTimeout": {
        "title": "So Timeout",
        "description": "Sets the so timeout FTP and FTPS Is the SocketOptions.SO_TIMEOUT value in millis. Recommended option is to set this to 300000 so as not have a hanged connection. On SFTP this option is set as timeout on the JSCH Session instance.",
        "datatype": "number",
        "format": "duration",
        "defaultValue": 300000,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "stepwise": {
        "title": "Stepwise",
        "description": "Sets whether we should stepwise change directories while traversing file structures when downloading files, or as well when uploading a file to a directory. You can disable this if you for example are in a situation where you cannot change directory on the FTP server due security reasons. Stepwise cannot be used together with streamDownload.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "throwExceptionOnConnectFailed": {
        "title": "Throw Exception On Connect Failed",
        "description": "Should an exception be thrown if connection failed (exhausted)By default exception is not thrown and a WARN is logged. You can use this to enable exception being thrown and handle the thrown exception from the org.apache.camel.spi.PollingConsumerPollStrategy rollback method.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "timeout": {
        "title": "Timeout",
        "description": "Sets the data timeout for waiting for reply Used only by FTPClient",
        "datatype": "number",
        "format": "duration",
        "defaultValue": 30000,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "antExclude": {
        "title": "Ant Exclude",
        "description": "Ant style filter exclusion. If both antInclude and antExclude are used, antExclude takes precedence over antInclude. Multiple exclusions may be specified in comma-delimited format.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "filter"
      },
      "antFilterCaseSensitive": {
        "title": "Ant Filter Case Sensitive",
        "description": "Sets case sensitive flag on ant filter.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "filter"
      },
      "antInclude": {
        "title": "Ant Include",
        "description": "Ant style filter inclusion. Multiple inclusions may be specified in comma-delimited format.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "filter"
      },
      "eagerMaxMessagesPerPoll": {
        "title": "Eager Max Messages Per Poll",
        "description": "Allows for controlling whether the limit from maxMessagesPerPoll is eager or not. If eager then the limit is during the scanning of files. Where as false would scan all files, and then perform sorting. Setting this option to false allows for sorting all files first, and then limit the poll. Mind that this requires a higher memory usage as all file details are in memory to perform the sorting.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "filter"
      },
      "exclude": {
        "title": "Exclude",
        "description": "Is used to exclude files, if filename matches the regex pattern (matching is case in-sensitive). Notice if you use symbols such as plus sign and others you would need to configure this using the RAW() syntax if configuring this as an endpoint uri. See more details at configuring endpoint uris",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "filter"
      },
      "excludeExt": {
        "title": "Exclude Ext",
        "description": "Is used to exclude files matching file extension name (case insensitive). For example to exclude bak files, then use excludeExt=bak. Multiple extensions can be separated by comma, for example to exclude bak and dat files, use excludeExt=bak,dat. Note that the file extension includes all parts, for example having a file named mydata.tar.gz will have extension as tar.gz. For more flexibility then use the include/exclude options.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "filter"
      },
      "filterDirectory": {
        "title": "Filter Directory",
        "description": "Filters the directory based on Simple language. For example to filter on current date, you can use a simple date pattern such as ${date:now:yyyMMdd}",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "filter"
      },
      "filterFile": {
        "title": "Filter File",
        "description": "Filters the file based on Simple language. For example to filter on file size, you can use ${file:size} 5000",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "filter"
      },
      "idempotent": {
        "title": "Idempotent",
        "description": "Option to use the Idempotent Consumer EIP pattern to let Camel skip already processed files. Will by default use a memory based LRUCache that holds 1000 entries. If noop=true then idempotent will be enabled as well to avoid consuming the same files over and over again.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "filter"
      },
      "idempotentKey": {
        "title": "Idempotent Key",
        "description": "To use a custom idempotent key. By default the absolute path of the file is used. You can use the File Language, for example to use the file name and file size, you can do: idempotentKey=${file:name}-${file:size}",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "filter"
      },
      "include": {
        "title": "Include",
        "description": "Is used to include files, if filename matches the regex pattern (matching is case in-sensitive). Notice if you use symbols such as plus sign and others you would need to configure this using the RAW() syntax if configuring this as an endpoint uri. See more details at configuring endpoint uris",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "filter"
      },
      "includeExt": {
        "title": "Include Ext",
        "description": "Is used to include files matching file extension name (case insensitive). For example to include txt files, then use includeExt=txt. Multiple extensions can be separated by comma, for example to include txt and xml files, use includeExt=txt,xml. Note that the file extension includes all parts, for example having a file named mydata.tar.gz will have extension as tar.gz. For more flexibility then use the include/exclude options.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "filter"
      },
      "maxDepth": {
        "title": "Max Depth",
        "description": "The maximum depth to traverse when recursively processing a directory.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 2147483647,
        "secret": false,
        "required": false,
        "group": "filter"
      },
      "maxMessagesPerPoll": {
        "title": "Max Messages Per Poll",
        "description": "To define a maximum messages to gather per poll. By default no maximum is set. Can be used to set a limit of e.g. 1000 to avoid when starting up the server that there are thousands of files. Set a value of 0 or negative to disabled it. Notice: If this option is in use then the File and FTP components will limit before any sorting. For example if you have 100000 files and use maxMessagesPerPoll=500, then only the first 500 files will be picked up, and then sorted. You can use the eagerMaxMessagesPerPoll option and set this to false to allow to scan all files first and then sort afterwards.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "filter"
      },
      "minDepth": {
        "title": "Min Depth",
        "description": "The minimum depth to start processing when recursively processing a directory. Using minDepth=1 means the base directory. Using minDepth=2 means the first sub directory.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "filter"
      },
      "move": {
        "title": "Move",
        "description": "Expression (such as Simple Language) used to dynamically set the filename when moving it after processing. To move files into a .done subdirectory just enter .done.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "filter"
      },
      "readLock": {
        "title": "Read Lock",
        "description": "Used by consumer, to only poll the files if it has exclusive read-lock on the file (i.e. the file is not in-progress or being written). Camel will wait until the file lock is granted. This option provides the build in strategies: - none - No read lock is in use - markerFile - Camel creates a marker file (fileName.camelLock) and then holds a lock on it. This option is not available for the FTP component - changed - Changed is using file length/modification timestamp to detect whether the file is currently being copied or not. Will at least use 1 sec to determine this, so this option cannot consume files as fast as the others, but can be more reliable as the JDK IO API cannot always determine whether a file is currently being used by another process. The option readLockCheckInterval can be used to set the check frequency. - fileLock - is for using java.nio.channels.FileLock. This option is not avail for Windows OS and the FTP component. This approach should be avoided when accessing a remote file system via a mount/share unless that file system supports distributed file locks. - rename - rename is for using a try to rename the file as a test if we can get exclusive read-lock. - idempotent - (only for file component) idempotent is for using a idempotentRepository as the read-lock. This allows to use read locks that supports clustering if the idempotent repository implementation supports that. - idempotent-changed - (only for file component) idempotent-changed is for using a idempotentRepository and changed as the combined read-lock. This allows to use read locks that supports clustering if the idempotent repository implementation supports that. - idempotent-rename - (only for file component) idempotent-rename is for using a idempotentRepository and rename as the combined read-lock. This allows to use read locks that supports clustering if the idempotent repository implementation supports that.Notice: The various read locks is not all suited to work in clustered mode, where concurrent consumers on different nodes is competing for the same files on a shared file system. The markerFile using a close to atomic operation to create the empty marker file, but its not guaranteed to work in a cluster. The fileLock may work better but then the file system need to support distributed file locks, and so on. Using the idempotent read lock can support clustering if the idempotent repository supports clustering, such as Hazelcast Component or Infinispan.",
        "datatype": "string",
        "defaultValue": "none",
        "secret": false,
        "required": false,
        "group": "lock",
        "enum": [
          "none",
          "markerFile",
          "fileLock",
          "rename",
          "changed",
          "idempotent",
          "idempotent-changed",
          "idempotent-rename"
        ]
      },
      "readLockCheckInterval": {
        "title": "Read Lock Check Interval",
        "description": "Interval in millis for the read-lock, if supported by the read lock. This interval is used for sleeping between attempts to acquire the read lock. For example when using the changed read lock, you can set a higher interval period to cater for slow writes. The default of 1 sec. may be too fast if the producer is very slow writing the file. Notice: For FTP the default readLockCheckInterval is 5000. The readLockTimeout value must be higher than readLockCheckInterval, but a rule of thumb is to have a timeout that is at least 2 or more times higher than the readLockCheckInterval. This is needed to ensure that amble time is allowed for the read lock process to try to grab the lock before the timeout was hit.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 1000,
        "secret": false,
        "required": false,
        "group": "lock"
      },
      "readLockDeleteOrphanLockFiles": {
        "title": "Read Lock Delete Orphan Lock Files",
        "description": "Whether or not read lock with marker files should upon startup delete any orphan read lock files, which may have been left on the file system, if Camel was not properly shutdown (such as a JVM crash). If turning this option to false then any orphaned lock file will cause Camel to not attempt to pickup that file, this could also be due another node is concurrently reading files from the same shared directory.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "lock"
      },
      "readLockLoggingLevel": {
        "title": "Read Lock Logging Level",
        "description": "Logging level used when a read lock could not be acquired. By default a DEBUG is logged. You can change this level, for example to OFF to not have any logging. This option is only applicable for readLock of types: changed, fileLock, idempotent, idempotent-changed, idempotent-rename, rename.",
        "datatype": "string",
        "defaultValue": "DEBUG",
        "secret": false,
        "required": false,
        "group": "lock",
        "enum": [
          "TRACE",
          "DEBUG",
          "INFO",
          "WARN",
          "ERROR",
          "OFF"
        ]
      },
      "readLockMarkerFile": {
        "title": "Read Lock Marker File",
        "description": "Whether to use marker file with the changed, rename, or exclusive read lock types. By default a marker file is used as well to guard against other processes picking up the same files. This behavior can be turned off by setting this option to false. For example if you do not want to write marker files to the file systems by the Camel application.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "lock"
      },
      "readLockMinAge": {
        "title": "Read Lock Min Age",
        "description": "This option is applied only for readLock=changed. It allows to specify a minimum age the file must be before attempting to acquire the read lock. For example use readLockMinAge=300s to require the file is at last 5 minutes old. This can speedup the changed read lock as it will only attempt to acquire files which are at least that given age.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 0,
        "secret": false,
        "required": false,
        "group": "lock"
      },
      "readLockMinLength": {
        "title": "Read Lock Min Length",
        "description": "This option is applied only for readLock=changed. It allows you to configure a minimum file length. By default Camel expects the file to contain data, and thus the default value is 1. You can set this option to zero, to allow consuming zero-length files.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 1,
        "secret": false,
        "required": false,
        "group": "lock"
      },
      "readLockRemoveOnCommit": {
        "title": "Read Lock Remove On Commit",
        "description": "This option is applied only for readLock=idempotent. It allows to specify whether to remove the file name entry from the idempotent repository when processing the file is succeeded and a commit happens. By default the file is not removed which ensures that any race-condition do not occur so another active node may attempt to grab the file. Instead the idempotent repository may support eviction strategies that you can configure to evict the file name entry after X minutes - this ensures no problems with race conditions. See more details at the readLockIdempotentReleaseDelay option.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "lock"
      },
      "readLockRemoveOnRollback": {
        "title": "Read Lock Remove On Rollback",
        "description": "This option is applied only for readLock=idempotent. It allows to specify whether to remove the file name entry from the idempotent repository when processing the file failed and a rollback happens. If this option is false, then the file name entry is confirmed (as if the file did a commit).",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "lock"
      },
      "readLockTimeout": {
        "title": "Read Lock Timeout",
        "description": "Optional timeout in millis for the read-lock, if supported by the read-lock. If the read-lock could not be granted and the timeout triggered, then Camel will skip the file. At next poll Camel, will try the file again, and this time maybe the read-lock could be granted. Use a value of 0 or lower to indicate forever. Currently fileLock, changed and rename support the timeout. Notice: For FTP the default readLockTimeout value is 20000 instead of 10000. The readLockTimeout value must be higher than readLockCheckInterval, but a rule of thumb is to have a timeout that is at least 2 or more times higher than the readLockCheckInterval. This is needed to ensure that amble time is allowed for the read lock process to try to grab the lock before the timeout was hit.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 10000,
        "secret": false,
        "required": false,
        "group": "lock"
      },
      "backoffErrorThreshold": {
        "title": "Backoff Error Threshold",
        "description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "backoffIdleThreshold": {
        "title": "Backoff Idle Threshold",
        "description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "backoffMultiplier": {
        "title": "Backoff Multiplier",
        "description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "delay": {
        "title": "Delay",
        "description": "Milliseconds before the next poll.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 500,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "greedy": {
        "title": "Greedy",
        "description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "initialDelay": {
        "title": "Initial Delay",
        "description": "Milliseconds before the first poll starts.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 1000,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "repeatCount": {
        "title": "Repeat Count",
        "description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 0,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "runLoggingLevel": {
        "title": "Run Logging Level",
        "description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
        "datatype": "string",
        "defaultValue": "TRACE",
        "secret": false,
        "required": false,
        "group": "scheduler",
        "enum": [
          "TRACE",
          "DEBUG",
          "INFO",
          "WARN",
          "ERROR",
          "OFF"
        ]
      },
      "startScheduler": {
        "title": "Start Scheduler",
        "description": "Whether the scheduler should be auto started.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "timeUnit": {
        "title": "Time Unit",
        "description": "Time unit for initialDelay and delay options.",
        "datatype": "string",
        "defaultValue": "MILLISECONDS",
        "secret": false,
        "required": false,
        "group": "scheduler",
        "enum": [
          "NANOSECONDS",
          "MICROSECONDS",
          "MILLISECONDS",
          "SECONDS",
          "MINUTES",
          "HOURS",
          "DAYS"
        ]
      },
      "useFixedDelay": {
        "title": "Use Fixed Delay",
        "description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "account": {
        "title": "Account",
        "description": "Account to use for login",
        "datatype": "string",
        "secret": true,
        "required": false,
        "group": "security"
      },
      "disableSecureDataChannelDefaults": {
        "title": "Disable Secure Data Channel Defaults",
        "description": "Use this option to disable default options when using secure data channel. This allows you to be in full control what the execPbsz and execProt setting should be used. Default is false",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "security"
      },
      "execPbsz": {
        "title": "Exec Pbsz",
        "description": "When using secure data channel you can set the exec protection buffer size",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "security"
      },
      "execProt": {
        "title": "Exec Prot",
        "description": "The exec protection level PROT command. C - Clear S - Safe(SSL protocol only) E - Confidential(SSL protocol only) P - Private",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "security"
      },
      "implicit": {
        "title": "Implicit",
        "description": "Set the security mode (Implicit/Explicit). true - Implicit Mode / False - Explicit Mode",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "security"
      },
      "password": {
        "title": "Password",
        "description": "Password to use for login",
        "datatype": "string",
        "secret": true,
        "required": false,
        "group": "security"
      },
      "securityProtocol": {
        "title": "Security Protocol",
        "description": "Set the underlying security protocol.",
        "datatype": "string",
        "defaultValue": "TLSv1.3",
        "secret": false,
        "required": false,
        "group": "security"
      },
      "username": {
        "title": "Username",
        "description": "Username to use for login",
        "datatype": "string",
        "secret": true,
        "required": false,
        "group": "security"
      },
      "shuffle": {
        "title": "Shuffle",
        "description": "To shuffle the list of files (sort in random order)",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "sort"
      },
      "sortBy": {
        "title": "Sort By",
        "description": "Built-in sort by using the File Language. Supports nested sorts, so you can have a sort by file name and as a 2nd group sort by modified date.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "sort"
      }
    },
    "pathProperties": {
      "host": {
        "title": "Host",
        "description": "Hostname of the FTP server",
        "datatype": "string",
        "secret": false,
        "required": true
      },
      "port": {
        "title": "Port",
        "description": "Port of the FTP server",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false
      },
      "directoryName": {
        "title": "Directory Name",
        "description": "The starting directory",
        "datatype": "string",
        "secret": false,
        "required": false
      }
    },
    "producer": true,
    "consumer": true
  },
  {
    "name": "google-bigquery",
    "title": "Google BigQuery",
    "description": "Google BigQuery data warehouse for analytics.",
    "iconUrl": "https://tst-ipaas-public-assets.s3.us-east-1.amazonaws.com/images/components/google-bigquery.svg",
    "syntax": "google-bigquery:projectId:datasetId:tableId",
    "properties": {
      "projectId": {
        "title": "Project Id",
        "description": "Google Cloud Project Id",
        "datatype": "string",
        "secret": false,
        "required": true,
        "group": "common"
      },
      "datasetId": {
        "title": "Dataset Id",
        "description": "BigQuery Dataset Id",
        "datatype": "string",
        "secret": false,
        "required": true,
        "group": "common"
      },
      "tableId": {
        "title": "Table Id",
        "description": "BigQuery table id",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "common"
      },
      "useAsInsertId": {
        "title": "Use As Insert Id",
        "description": "Field name to use as insert id",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "lazyStartProducer": {
        "title": "Lazy Start Producer",
        "description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "serviceAccountKey": {
        "title": "Service Account Key",
        "description": "Service account key in json format to authenticate an application as a service account to google cloud platform",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "security"
      }
    },
    "pathProperties": {
      "projectId": {
        "title": "Project Id",
        "description": "Google Cloud Project Id",
        "datatype": "string",
        "secret": false,
        "required": true
      },
      "datasetId": {
        "title": "Dataset Id",
        "description": "BigQuery Dataset Id",
        "datatype": "string",
        "secret": false,
        "required": true
      },
      "tableId": {
        "title": "Table Id",
        "description": "BigQuery table id",
        "datatype": "string",
        "secret": false,
        "required": false
      }
    },
    "producer": true,
    "consumer": false
  },
  {
    "name": "google-bigquery-sql",
    "title": "Google BigQuery Standard SQL",
    "description": "Access Google Cloud BigQuery service using SQL queries.",
    "iconUrl": "https://tst-ipaas-public-assets.s3.us-east-1.amazonaws.com/images/components/google-bigquery-sql.svg",
    "syntax": "google-bigquery-sql:projectId:queryString",
    "properties": {
      "projectId": {
        "title": "Project Id",
        "description": "Google Cloud Project Id",
        "datatype": "string",
        "secret": false,
        "required": true,
        "group": "common"
      },
      "queryString": {
        "title": "Query String",
        "description": "BigQuery standard SQL query",
        "datatype": "string",
        "secret": false,
        "required": true,
        "group": "common"
      },
      "lazyStartProducer": {
        "title": "Lazy Start Producer",
        "description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "serviceAccountKey": {
        "title": "Service Account Key",
        "description": "Service account key in json format to authenticate an application as a service account to google cloud platform",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "security"
      }
    },
    "pathProperties": {
      "projectId": {
        "title": "Project Id",
        "description": "Google Cloud Project Id",
        "datatype": "string",
        "secret": false,
        "required": true
      },
      "queryString": {
        "title": "Query String",
        "description": "BigQuery standard SQL query",
        "datatype": "string",
        "secret": false,
        "required": true
      }
    },
    "producer": true,
    "consumer": false
  },
  {
    "name": "google-pubsub",
    "title": "Google Pubsub",
    "description": "Send and receive messages to/from Google Cloud Platform PubSub Service.",
    "iconUrl": "https://tst-ipaas-public-assets.s3.us-east-1.amazonaws.com/images/components/google-pubsub.svg",
    "syntax": "google-pubsub:projectId:destinationName",
    "properties": {
      "projectId": {
        "title": "Project Id",
        "description": "The Google Cloud PubSub Project Id",
        "datatype": "string",
        "secret": false,
        "required": true,
        "group": "common"
      },
      "destinationName": {
        "title": "Destination Name",
        "description": "The Destination Name. For the consumer this will be the subscription name, while for the producer this will be the topic name.",
        "datatype": "string",
        "secret": false,
        "required": true,
        "group": "common"
      },
      "authenticate": {
        "title": "Authenticate",
        "description": "Use Credentials when interacting with PubSub service (no authentication is required when using emulator).",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "common"
      },
      "loggerId": {
        "title": "Logger Id",
        "description": "Logger ID to use when a match to the parent route required",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "common"
      },
      "serviceAccountKey": {
        "title": "Service Account Key",
        "description": "The Service account key that can be used as credentials for the PubSub publisher/subscriber. It can be loaded by default from classpath, but you can prefix with classpath:, file:, or http: to load the resource from different systems.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "common"
      },
      "ackMode": {
        "title": "Ack Mode",
        "description": "AUTO = exchange gets ack'ed/nack'ed on completion. NONE = downstream process has to ack/nack explicitly",
        "datatype": "string",
        "defaultValue": "AUTO",
        "secret": false,
        "required": false,
        "group": "consumer",
        "enum": [
          "AUTO",
          "NONE"
        ]
      },
      "concurrentConsumers": {
        "title": "Concurrent Consumers",
        "description": "The number of parallel streams consuming from the subscription",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 1,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "maxAckExtensionPeriod": {
        "title": "Max Ack Extension Period",
        "description": "Set the maximum period a message ack deadline will be extended. Value in seconds",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 3600,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "maxMessagesPerPoll": {
        "title": "Max Messages Per Poll",
        "description": "The max number of messages to receive from the server in a single API call",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 1,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "synchronousPull": {
        "title": "Synchronous Pull",
        "description": "Synchronously pull batches of messages",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "bridgeErrorHandler": {
        "title": "Bridge Error Handler",
        "description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "exchangePattern": {
        "title": "Exchange Pattern",
        "description": "Sets the exchange pattern when the consumer creates an exchange.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer (advanced)",
        "enum": [
          "InOnly",
          "InOut"
        ]
      },
      "lazyStartProducer": {
        "title": "Lazy Start Producer",
        "description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "messageOrderingEnabled": {
        "title": "Message Ordering Enabled",
        "description": "Should message ordering be enabled",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "pubsubEndpoint": {
        "title": "Pubsub Endpoint",
        "description": "Pub/Sub endpoint to use. Required when using message ordering, and ensures that messages are received in order even when multiple publishers are used",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      }
    },
    "pathProperties": {
      "projectId": {
        "title": "Project Id",
        "description": "The Google Cloud PubSub Project Id",
        "datatype": "string",
        "secret": false,
        "required": true
      },
      "destinationName": {
        "title": "Destination Name",
        "description": "The Destination Name. For the consumer this will be the subscription name, while for the producer this will be the topic name.",
        "datatype": "string",
        "secret": false,
        "required": true
      }
    },
    "producer": true,
    "consumer": true
  },
  {
    "name": "http",
    "title": "HTTP",
    "description": "Send requests to external HTTP servers using Apache HTTP Client 5.x.",
    "iconUrl": "https://tst-ipaas-public-assets.s3.us-east-1.amazonaws.com/images/components/http.svg",
    "syntax": "http://httpUri",
    "properties": {
      "httpUri": {
        "title": "Http Uri",
        "description": "The url of the HTTP endpoint to call.",
        "datatype": "string",
        "secret": false,
        "required": true,
        "group": "common"
      },
      "disableStreamCache": {
        "title": "Disable Stream Cache",
        "description": "Determines whether or not the raw input stream from Servlet is cached or not (Camel will read the stream into a in memory/overflow to file, Stream caching) cache. By default Camel will cache the Servlet input stream to support reading it multiple times to ensure it Camel can retrieve all data from the stream. However you can set this option to true when you for example need to access the raw stream, such as streaming it directly to a file or other persistent store. DefaultHttpBinding will copy the request input stream into a stream cache and put it into message body if this option is false to support reading the stream multiple times. If you use Servlet to bridge/proxy an endpoint then consider enabling this option to improve performance, in case you do not need to read the message payload multiple times. The http producer will by default cache the response body stream. If setting this option to true, then the producers will not cache the response body stream but use the response stream as-is as the message body.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "common"
      },
      "bridgeEndpoint": {
        "title": "Bridge Endpoint",
        "description": "If the option is true, HttpProducer will ignore the Exchange.HTTP_URI header, and use the endpoint's URI for request. You may also set the option throwExceptionOnFailure to be false to let the HttpProducer send all the fault response back.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "connectionClose": {
        "title": "Connection Close",
        "description": "Specifies whether a Connection Close header must be added to HTTP Request. By default connectionClose is false.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "followRedirects": {
        "title": "Follow Redirects",
        "description": "Whether to the HTTP request should follow redirects. By default the HTTP request does not follow redirects",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "httpMethod": {
        "title": "Http Method",
        "description": "Configure the HTTP method to use. The HttpMethod header cannot override this option if set.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer",
        "enum": [
          "GET",
          "POST",
          "PUT",
          "DELETE",
          "HEAD",
          "OPTIONS",
          "TRACE",
          "PATCH"
        ]
      },
      "throwExceptionOnFailure": {
        "title": "Throw Exception On Failure",
        "description": "Option to disable throwing the HttpOperationFailedException in case of failed responses from the remote server. This allows you to get all responses regardless of the HTTP status code.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "clearExpiredCookies": {
        "title": "Clear Expired Cookies",
        "description": "Whether to clear expired cookies before sending the HTTP request. This ensures the cookies store does not keep growing by adding new cookies which is newer removed when they are expired. If the component has disabled cookie management then this option is disabled too.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "automaticRetriesDisabled": {
        "title": "Automatic Retries Disabled",
        "description": "Disables automatic request recovery and re-execution",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "autowiredEnabled": {
        "title": "Autowired Enabled",
        "description": "Whether autowiring is enabled. This is used for automatic autowiring options (the option must be marked as autowired) by looking up in the registry to find if there is a single instance of matching type, which then gets configured on the component. This can be used for automatic configuring JDBC data sources, JMS connection factories, AWS Clients, etc.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "copyHeaders": {
        "title": "Copy Headers",
        "description": "If this option is true then IN exchange headers will be copied to OUT exchange headers according to copy strategy. Setting this to false, allows to only include the headers from the HTTP response (not propagating IN headers).",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "customHostHeader": {
        "title": "Custom Host Header",
        "description": "To use custom host header for producer. When not set in query will be ignored. When set will override host header derived from url.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "deleteWithBody": {
        "title": "Delete With Body",
        "description": "Whether the HTTP DELETE should include the message body or not. By default HTTP DELETE do not include any HTTP body. However in some rare cases users may need to be able to include the message body.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "getWithBody": {
        "title": "Get With Body",
        "description": "Whether the HTTP GET should include the message body or not. By default HTTP GET do not include any HTTP body. However in some rare cases users may need to be able to include the message body.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "ignoreResponseBody": {
        "title": "Ignore Response Body",
        "description": "If this option is true, The http producer won't read response body and cache the input stream",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "lazyStartProducer": {
        "title": "Lazy Start Producer",
        "description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "okStatusCodeRange": {
        "title": "Ok Status Code Range",
        "description": "The status codes which are considered a success response. The values are inclusive. Multiple ranges can be defined, separated by comma, e.g. 200-204,209,301-304. Each range must be a single number or from-to with the dash included.",
        "datatype": "string",
        "defaultValue": "200-299",
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "preserveHostHeader": {
        "title": "Preserve Host Header",
        "description": "If the option is true, HttpProducer will set the Host header to the value contained in the current exchange Host header, useful in reverse proxy applications where you want the Host header received by the downstream server to reflect the URL called by the upstream client, this allows applications which use the Host header to generate accurate URL's for a proxied service",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "skipRequestHeaders": {
        "title": "Skip Request Headers",
        "description": "Whether to skip mapping all the Camel headers as HTTP request headers. If there are no data from Camel headers needed to be included in the HTTP request then this can avoid parsing overhead with many object allocations for the JVM garbage collector.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "skipResponseHeaders": {
        "title": "Skip Response Headers",
        "description": "Whether to skip mapping all the HTTP response headers to Camel headers. If there are no data needed from HTTP headers then this can avoid parsing overhead with many object allocations for the JVM garbage collector.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "userAgent": {
        "title": "User Agent",
        "description": "To set a custom HTTP User-Agent request header",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "redirectHandlingDisabled": {
        "title": "Redirect Handling Disabled",
        "description": "Disables automatic redirect handling",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "connectionsPerRoute": {
        "title": "Connections Per Route",
        "description": "The maximum number of connections per route.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 20,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "maxTotalConnections": {
        "title": "Max Total Connections",
        "description": "The maximum number of connections.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 200,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "useSystemProperties": {
        "title": "Use System Properties",
        "description": "To use System Properties as fallback for configuration",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "proxyAuthDomain": {
        "title": "Proxy Auth Domain",
        "description": "Proxy authentication domain to use with NTML",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "proxy"
      },
      "proxyAuthHost": {
        "title": "Proxy Auth Host",
        "description": "Proxy authentication host",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "proxy"
      },
      "proxyAuthMethod": {
        "title": "Proxy Auth Method",
        "description": "Proxy authentication method to use",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "proxy",
        "enum": [
          "Basic",
          "Digest",
          "NTLM"
        ]
      },
      "proxyAuthNtHost": {
        "title": "Proxy Auth Nt Host",
        "description": "Proxy authentication domain (workstation name) to use with NTML",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "proxy"
      },
      "proxyAuthPassword": {
        "title": "Proxy Auth Password",
        "description": "Proxy authentication password",
        "datatype": "string",
        "secret": true,
        "required": false,
        "group": "proxy"
      },
      "proxyAuthPort": {
        "title": "Proxy Auth Port",
        "description": "Proxy authentication port",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "proxy"
      },
      "proxyAuthScheme": {
        "title": "Proxy Auth Scheme",
        "description": "Proxy authentication scheme to use",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "proxy",
        "enum": [
          "http",
          "https"
        ]
      },
      "proxyAuthUsername": {
        "title": "Proxy Auth Username",
        "description": "Proxy authentication username",
        "datatype": "string",
        "secret": true,
        "required": false,
        "group": "proxy"
      },
      "proxyHost": {
        "title": "Proxy Host",
        "description": "Proxy hostname to use",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "proxy"
      },
      "proxyPort": {
        "title": "Proxy Port",
        "description": "Proxy port to use",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "proxy"
      },
      "authDomain": {
        "title": "Auth Domain",
        "description": "Authentication domain to use with NTML",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "security"
      },
      "authenticationPreemptive": {
        "title": "Authentication Preemptive",
        "description": "If this option is true, camel-http sends preemptive basic authentication to the server.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "security"
      },
      "authHost": {
        "title": "Auth Host",
        "description": "Authentication host to use with NTML",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "security"
      },
      "authMethod": {
        "title": "Auth Method",
        "description": "Authentication methods allowed to use as a comma separated list of values Basic, Digest or NTLM.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "security"
      },
      "authMethodPriority": {
        "title": "Auth Method Priority",
        "description": "Which authentication method to prioritize to use, either as Basic, Digest or NTLM.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "security",
        "enum": [
          "Basic",
          "Digest",
          "NTLM"
        ]
      },
      "authPassword": {
        "title": "Auth Password",
        "description": "Authentication password",
        "datatype": "string",
        "secret": true,
        "required": false,
        "group": "security"
      },
      "authUsername": {
        "title": "Auth Username",
        "description": "Authentication username",
        "datatype": "string",
        "secret": true,
        "required": false,
        "group": "security"
      }
    },
    "pathProperties": {
      "httpUri": {
        "title": "Http Uri",
        "description": "The url of the HTTP endpoint to call.",
        "datatype": "string",
        "secret": false,
        "required": true
      }
    },
    "producer": true,
    "consumer": false
  },
  {
    "name": "https",
    "title": "HTTPS (Secure)",
    "description": "Send requests to external HTTP servers using Apache HTTP Client 5.x.",
    "iconUrl": "https://tst-ipaas-public-assets.s3.us-east-1.amazonaws.com/images/components/https.svg",
    "syntax": "https://httpUri",
    "properties": {
      "httpUri": {
        "title": "Http Uri",
        "description": "The url of the HTTP endpoint to call.",
        "datatype": "string",
        "secret": false,
        "required": true,
        "group": "common"
      },
      "disableStreamCache": {
        "title": "Disable Stream Cache",
        "description": "Determines whether or not the raw input stream from Servlet is cached or not (Camel will read the stream into a in memory/overflow to file, Stream caching) cache. By default Camel will cache the Servlet input stream to support reading it multiple times to ensure it Camel can retrieve all data from the stream. However you can set this option to true when you for example need to access the raw stream, such as streaming it directly to a file or other persistent store. DefaultHttpBinding will copy the request input stream into a stream cache and put it into message body if this option is false to support reading the stream multiple times. If you use Servlet to bridge/proxy an endpoint then consider enabling this option to improve performance, in case you do not need to read the message payload multiple times. The http producer will by default cache the response body stream. If setting this option to true, then the producers will not cache the response body stream but use the response stream as-is as the message body.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "common"
      },
      "bridgeEndpoint": {
        "title": "Bridge Endpoint",
        "description": "If the option is true, HttpProducer will ignore the Exchange.HTTP_URI header, and use the endpoint's URI for request. You may also set the option throwExceptionOnFailure to be false to let the HttpProducer send all the fault response back.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "connectionClose": {
        "title": "Connection Close",
        "description": "Specifies whether a Connection Close header must be added to HTTP Request. By default connectionClose is false.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "followRedirects": {
        "title": "Follow Redirects",
        "description": "Whether to the HTTP request should follow redirects. By default the HTTP request does not follow redirects",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "httpMethod": {
        "title": "Http Method",
        "description": "Configure the HTTP method to use. The HttpMethod header cannot override this option if set.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer",
        "enum": [
          "GET",
          "POST",
          "PUT",
          "DELETE",
          "HEAD",
          "OPTIONS",
          "TRACE",
          "PATCH"
        ]
      },
      "throwExceptionOnFailure": {
        "title": "Throw Exception On Failure",
        "description": "Option to disable throwing the HttpOperationFailedException in case of failed responses from the remote server. This allows you to get all responses regardless of the HTTP status code.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "clearExpiredCookies": {
        "title": "Clear Expired Cookies",
        "description": "Whether to clear expired cookies before sending the HTTP request. This ensures the cookies store does not keep growing by adding new cookies which is newer removed when they are expired. If the component has disabled cookie management then this option is disabled too.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "automaticRetriesDisabled": {
        "title": "Automatic Retries Disabled",
        "description": "Disables automatic request recovery and re-execution",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "autowiredEnabled": {
        "title": "Autowired Enabled",
        "description": "Whether autowiring is enabled. This is used for automatic autowiring options (the option must be marked as autowired) by looking up in the registry to find if there is a single instance of matching type, which then gets configured on the component. This can be used for automatic configuring JDBC data sources, JMS connection factories, AWS Clients, etc.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "copyHeaders": {
        "title": "Copy Headers",
        "description": "If this option is true then IN exchange headers will be copied to OUT exchange headers according to copy strategy. Setting this to false, allows to only include the headers from the HTTP response (not propagating IN headers).",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "customHostHeader": {
        "title": "Custom Host Header",
        "description": "To use custom host header for producer. When not set in query will be ignored. When set will override host header derived from url.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "deleteWithBody": {
        "title": "Delete With Body",
        "description": "Whether the HTTP DELETE should include the message body or not. By default HTTP DELETE do not include any HTTP body. However in some rare cases users may need to be able to include the message body.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "getWithBody": {
        "title": "Get With Body",
        "description": "Whether the HTTP GET should include the message body or not. By default HTTP GET do not include any HTTP body. However in some rare cases users may need to be able to include the message body.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "ignoreResponseBody": {
        "title": "Ignore Response Body",
        "description": "If this option is true, The http producer won't read response body and cache the input stream",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "lazyStartProducer": {
        "title": "Lazy Start Producer",
        "description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "okStatusCodeRange": {
        "title": "Ok Status Code Range",
        "description": "The status codes which are considered a success response. The values are inclusive. Multiple ranges can be defined, separated by comma, e.g. 200-204,209,301-304. Each range must be a single number or from-to with the dash included.",
        "datatype": "string",
        "defaultValue": "200-299",
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "preserveHostHeader": {
        "title": "Preserve Host Header",
        "description": "If the option is true, HttpProducer will set the Host header to the value contained in the current exchange Host header, useful in reverse proxy applications where you want the Host header received by the downstream server to reflect the URL called by the upstream client, this allows applications which use the Host header to generate accurate URL's for a proxied service",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "skipRequestHeaders": {
        "title": "Skip Request Headers",
        "description": "Whether to skip mapping all the Camel headers as HTTP request headers. If there are no data from Camel headers needed to be included in the HTTP request then this can avoid parsing overhead with many object allocations for the JVM garbage collector.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "skipResponseHeaders": {
        "title": "Skip Response Headers",
        "description": "Whether to skip mapping all the HTTP response headers to Camel headers. If there are no data needed from HTTP headers then this can avoid parsing overhead with many object allocations for the JVM garbage collector.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "userAgent": {
        "title": "User Agent",
        "description": "To set a custom HTTP User-Agent request header",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "redirectHandlingDisabled": {
        "title": "Redirect Handling Disabled",
        "description": "Disables automatic redirect handling",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "connectionsPerRoute": {
        "title": "Connections Per Route",
        "description": "The maximum number of connections per route.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 20,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "maxTotalConnections": {
        "title": "Max Total Connections",
        "description": "The maximum number of connections.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 200,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "useSystemProperties": {
        "title": "Use System Properties",
        "description": "To use System Properties as fallback for configuration",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "proxyAuthDomain": {
        "title": "Proxy Auth Domain",
        "description": "Proxy authentication domain to use with NTML",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "proxy"
      },
      "proxyAuthHost": {
        "title": "Proxy Auth Host",
        "description": "Proxy authentication host",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "proxy"
      },
      "proxyAuthMethod": {
        "title": "Proxy Auth Method",
        "description": "Proxy authentication method to use",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "proxy",
        "enum": [
          "Basic",
          "Digest",
          "NTLM"
        ]
      },
      "proxyAuthNtHost": {
        "title": "Proxy Auth Nt Host",
        "description": "Proxy authentication domain (workstation name) to use with NTML",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "proxy"
      },
      "proxyAuthPassword": {
        "title": "Proxy Auth Password",
        "description": "Proxy authentication password",
        "datatype": "string",
        "secret": true,
        "required": false,
        "group": "proxy"
      },
      "proxyAuthPort": {
        "title": "Proxy Auth Port",
        "description": "Proxy authentication port",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "proxy"
      },
      "proxyAuthScheme": {
        "title": "Proxy Auth Scheme",
        "description": "Proxy authentication scheme to use",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "proxy",
        "enum": [
          "http",
          "https"
        ]
      },
      "proxyAuthUsername": {
        "title": "Proxy Auth Username",
        "description": "Proxy authentication username",
        "datatype": "string",
        "secret": true,
        "required": false,
        "group": "proxy"
      },
      "proxyHost": {
        "title": "Proxy Host",
        "description": "Proxy hostname to use",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "proxy"
      },
      "proxyPort": {
        "title": "Proxy Port",
        "description": "Proxy port to use",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "proxy"
      },
      "authDomain": {
        "title": "Auth Domain",
        "description": "Authentication domain to use with NTML",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "security"
      },
      "authenticationPreemptive": {
        "title": "Authentication Preemptive",
        "description": "If this option is true, camel-http sends preemptive basic authentication to the server.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "security"
      },
      "authHost": {
        "title": "Auth Host",
        "description": "Authentication host to use with NTML",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "security"
      },
      "authMethod": {
        "title": "Auth Method",
        "description": "Authentication methods allowed to use as a comma separated list of values Basic, Digest or NTLM.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "security"
      },
      "authMethodPriority": {
        "title": "Auth Method Priority",
        "description": "Which authentication method to prioritize to use, either as Basic, Digest or NTLM.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "security",
        "enum": [
          "Basic",
          "Digest",
          "NTLM"
        ]
      },
      "authPassword": {
        "title": "Auth Password",
        "description": "Authentication password",
        "datatype": "string",
        "secret": true,
        "required": false,
        "group": "security"
      },
      "authUsername": {
        "title": "Auth Username",
        "description": "Authentication username",
        "datatype": "string",
        "secret": true,
        "required": false,
        "group": "security"
      }
    },
    "pathProperties": {
      "httpUri": {
        "title": "Http Uri",
        "description": "The url of the HTTP endpoint to call.",
        "datatype": "string",
        "secret": false,
        "required": true
      }
    },
    "producer": true,
    "consumer": false
  },
  {
    "name": "imap",
    "title": "IMAP",
    "description": "Send and receive emails using imap, pop3 and smtp protocols.",
    "iconUrl": "https://tst-ipaas-public-assets.s3.us-east-1.amazonaws.com/images/components/imap.svg",
    "syntax": "imap:host:port",
    "properties": {
      "host": {
        "title": "Host",
        "description": "The mail server host name",
        "datatype": "string",
        "secret": false,
        "required": true,
        "group": "common"
      },
      "port": {
        "title": "Port",
        "description": "The port number of the mail server",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "common"
      },
      "closeFolder": {
        "title": "Close Folder",
        "description": "Whether the consumer should close the folder after polling. Setting this option to false and having disconnect=false as well, then the consumer keep the folder open between polls.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "copyTo": {
        "title": "Copy To",
        "description": "After processing a mail message, it can be copied to a mail folder with the given name. You can override this configuration value, with a header with the key copyTo, allowing you to copy messages to folder names configured at runtime.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "decodeFilename": {
        "title": "Decode Filename",
        "description": "If set to true, the MimeUtility.decodeText method will be used to decode the filename. This is similar to setting JVM system property mail.mime.encodefilename.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "delete": {
        "title": "Delete",
        "description": "Deletes the messages after they have been processed. This is done by setting the DELETED flag on the mail message. If false, the SEEN flag is set instead. As of Camel 2.10 you can override this configuration option by setting a header with the key delete to determine if the mail should be deleted or not.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "disconnect": {
        "title": "Disconnect",
        "description": "Whether the consumer should disconnect after polling. If enabled this forces Camel to connect on each poll.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "handleFailedMessage": {
        "title": "Handle Failed Message",
        "description": "If the mail consumer cannot retrieve a given mail message, then this option allows to handle the caused exception by the consumer's error handler. By enable the bridge error handler on the consumer, then the Camel routing error handler can handle the exception instead. The default behavior would be the consumer throws an exception and no mails from the batch would be able to be routed by Camel.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "maxMessagesPerPoll": {
        "title": "Max Messages Per Poll",
        "description": "Specifies the maximum number of messages to gather per poll. By default, no maximum is set. Can be used to set a limit of e.g. 1000 to avoid downloading thousands of files when the server starts up. Set a value of 0 or negative to disable this option.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "mimeDecodeHeaders": {
        "title": "Mime Decode Headers",
        "description": "This option enables transparent MIME decoding and unfolding for mail headers.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "moveTo": {
        "title": "Move To",
        "description": "After processing a mail message, it can be moved to a mail folder with the given name. You can override this configuration value, with a header with the key moveTo, allowing you to move messages to folder names configured at runtime.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "peek": {
        "title": "Peek",
        "description": "Will mark the jakarta.mail.Message as peeked before processing the mail message. This applies to IMAPMessage messages types only. By using peek the mail will not be eager marked as SEEN on the mail server, which allows us to rollback the mail message if there is an error processing in Camel.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "sendEmptyMessageWhenIdle": {
        "title": "Send Empty Message When Idle",
        "description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "skipFailedMessage": {
        "title": "Skip Failed Message",
        "description": "If the mail consumer cannot retrieve a given mail message, then this option allows to skip the message and move on to retrieve the next mail message. The default behavior would be the consumer throws an exception and no mails from the batch would be able to be routed by Camel.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "unseen": {
        "title": "Unseen",
        "description": "Whether to limit by unseen mails only.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "bridgeErrorHandler": {
        "title": "Bridge Error Handler",
        "description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "exchangePattern": {
        "title": "Exchange Pattern",
        "description": "Sets the exchange pattern when the consumer creates an exchange.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer (advanced)",
        "enum": [
          "InOnly",
          "InOut"
        ]
      },
      "failOnDuplicateFileAttachment": {
        "title": "Fail On Duplicate File Attachment",
        "description": "Whether to fail processing the mail if the mail message contains attachments with duplicate file names. If set to false, then the duplicate attachment is skipped and a WARN is logged. If set to true then an exception is thrown failing to process the mail message.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "fetchSize": {
        "title": "Fetch Size",
        "description": "Sets the maximum number of messages to consume during a poll. This can be used to avoid overloading a mail server, if a mailbox folder contains a lot of messages. Default value of -1 means no fetch size and all messages will be consumed. Setting the value to 0 is a special corner case, where Camel will not consume any messages at all.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": -1,
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "folderName": {
        "title": "Folder Name",
        "description": "The folder to poll.",
        "datatype": "string",
        "defaultValue": "INBOX",
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "generateMissingAttachmentNames": {
        "title": "Generate Missing Attachment Names",
        "description": "Set this to 'uuid' to set a UUID for the filename of the attachment if no filename was set",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "handleDuplicateAttachmentNames": {
        "title": "Handle Duplicate Attachment Names",
        "description": "Set the strategy to handle duplicate filenames of attachments never: attachments that have a filename which is already present in the attachments will be ignored unless failOnDuplicateFileAttachment is set to true. uuidPrefix: this will prefix the duplicate attachment filenames each with a uuid and underscore (uuid_filename.fileextension). uuidSuffix: this will suffix the duplicate attachment filenames each with a underscore and uuid (filename_uuid.fileextension).",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "mapMailMessage": {
        "title": "Map Mail Message",
        "description": "Specifies whether Camel should map the received mail message to Camel body/headers/attachments. If set to true, the body of the mail message is mapped to the body of the Camel IN message, the mail headers are mapped to IN headers, and the attachments to Camel IN attachment message. If this option is set to false then the IN message contains a raw jakarta.mail.Message. You can retrieve this raw message by calling exchange.getIn().getBody(jakarta.mail.Message.class).",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "bcc": {
        "title": "Bcc",
        "description": "Sets the BCC email address. Separate multiple email addresses with comma.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "cc": {
        "title": "Cc",
        "description": "Sets the CC email address. Separate multiple email addresses with comma.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "from": {
        "title": "From",
        "description": "The from email address",
        "datatype": "string",
        "defaultValue": "camel@localhost",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "replyTo": {
        "title": "Reply To",
        "description": "The Reply-To recipients (the receivers of the response mail). Separate multiple email addresses with a comma.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "subject": {
        "title": "Subject",
        "description": "The Subject of the message being sent. Note: Setting the subject in the header takes precedence over this option.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "to": {
        "title": "To",
        "description": "Sets the To email address. Separate multiple email addresses with comma.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "lazyStartProducer": {
        "title": "Lazy Start Producer",
        "description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "alternativeBodyHeader": {
        "title": "Alternative Body Header",
        "description": "Specifies the key to an IN message header that contains an alternative email body. For example, if you send emails in text/html format and want to provide an alternative mail body for non-HTML email clients, set the alternative mail body with this key as a header.",
        "datatype": "string",
        "defaultValue": "CamelMailAlternativeBody",
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "connectionTimeout": {
        "title": "Connection Timeout",
        "description": "The connection timeout in milliseconds.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 30000,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "contentType": {
        "title": "Content Type",
        "description": "The mail message content type. Use text/html for HTML mails.",
        "datatype": "string",
        "defaultValue": "text/plain",
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "healthCheckConsumerEnabled": {
        "title": "Health Check Consumer Enabled",
        "description": "Used for enabling or disabling all consumer based health checks from this component",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "health"
      },
      "debugMode": {
        "title": "Debug Mode",
        "description": "Enable debug mode on the underlying mail framework. The SUN Mail framework logs the debug messages to System.out by default.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "ignoreUnsupportedCharset": {
        "title": "Ignore Unsupported Charset",
        "description": "Option to let Camel ignore unsupported charset in the local JVM when sending mails. If the charset is unsupported then charset=XXX (where XXX represents the unsupported charset) is removed from the content-type and it relies on the platform default instead.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "ignoreUriScheme": {
        "title": "Ignore Uri Scheme",
        "description": "Option to let Camel ignore unsupported charset in the local JVM when sending mails. If the charset is unsupported then charset=XXX (where XXX represents the unsupported charset) is removed from the content-type and it relies on the platform default instead.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "useInlineAttachments": {
        "title": "Use Inline Attachments",
        "description": "Whether to use disposition inline or attachment.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "idempotentRepositoryRemoveOnCommit": {
        "title": "Idempotent Repository Remove On Commit",
        "description": "When using idempotent repository, then when the mail message has been successfully processed and is committed, should the message id be removed from the idempotent repository (default) or be kept in the repository. By default its assumed the message id is unique and has no value to be kept in the repository, because the mail message will be marked as seen/moved or deleted to prevent it from being consumed again. And therefore having the message id stored in the idempotent repository has little value. However this option allows to store the message id, for whatever reason you may have.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "filter"
      },
      "backoffErrorThreshold": {
        "title": "Backoff Error Threshold",
        "description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "backoffIdleThreshold": {
        "title": "Backoff Idle Threshold",
        "description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "backoffMultiplier": {
        "title": "Backoff Multiplier",
        "description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "delay": {
        "title": "Delay",
        "description": "Milliseconds before the next poll.",
        "datatype": "number",
        "format": "duration",
        "defaultValue": 60000,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "greedy": {
        "title": "Greedy",
        "description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "initialDelay": {
        "title": "Initial Delay",
        "description": "Milliseconds before the first poll starts.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 1000,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "repeatCount": {
        "title": "Repeat Count",
        "description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 0,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "runLoggingLevel": {
        "title": "Run Logging Level",
        "description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
        "datatype": "string",
        "defaultValue": "TRACE",
        "secret": false,
        "required": false,
        "group": "scheduler",
        "enum": [
          "TRACE",
          "DEBUG",
          "INFO",
          "WARN",
          "ERROR",
          "OFF"
        ]
      },
      "startScheduler": {
        "title": "Start Scheduler",
        "description": "Whether the scheduler should be auto started.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "timeUnit": {
        "title": "Time Unit",
        "description": "Time unit for initialDelay and delay options.",
        "datatype": "string",
        "defaultValue": "MILLISECONDS",
        "secret": false,
        "required": false,
        "group": "scheduler",
        "enum": [
          "NANOSECONDS",
          "MICROSECONDS",
          "MILLISECONDS",
          "SECONDS",
          "MINUTES",
          "HOURS",
          "DAYS"
        ]
      },
      "useFixedDelay": {
        "title": "Use Fixed Delay",
        "description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "password": {
        "title": "Password",
        "description": "The password for login. See also setAuthenticator(MailAuthenticator).",
        "datatype": "string",
        "secret": true,
        "required": false,
        "group": "security"
      },
      "username": {
        "title": "Username",
        "description": "The username for login. See also setAuthenticator(MailAuthenticator).",
        "datatype": "string",
        "secret": true,
        "required": false,
        "group": "security"
      }
    },
    "pathProperties": {
      "host": {
        "title": "Host",
        "description": "The mail server host name",
        "datatype": "string",
        "secret": false,
        "required": true
      },
      "port": {
        "title": "Port",
        "description": "The port number of the mail server",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false
      }
    },
    "producer": true,
    "consumer": true
  },
  {
    "name": "imaps",
    "title": "IMAPS (Secure)",
    "description": "Send and receive emails using imap, pop3 and smtp protocols.",
    "iconUrl": "https://tst-ipaas-public-assets.s3.us-east-1.amazonaws.com/images/components/imaps.svg",
    "syntax": "imaps:host:port",
    "properties": {
      "host": {
        "title": "Host",
        "description": "The mail server host name",
        "datatype": "string",
        "secret": false,
        "required": true,
        "group": "common"
      },
      "port": {
        "title": "Port",
        "description": "The port number of the mail server",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "common"
      },
      "closeFolder": {
        "title": "Close Folder",
        "description": "Whether the consumer should close the folder after polling. Setting this option to false and having disconnect=false as well, then the consumer keep the folder open between polls.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "copyTo": {
        "title": "Copy To",
        "description": "After processing a mail message, it can be copied to a mail folder with the given name. You can override this configuration value, with a header with the key copyTo, allowing you to copy messages to folder names configured at runtime.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "decodeFilename": {
        "title": "Decode Filename",
        "description": "If set to true, the MimeUtility.decodeText method will be used to decode the filename. This is similar to setting JVM system property mail.mime.encodefilename.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "delete": {
        "title": "Delete",
        "description": "Deletes the messages after they have been processed. This is done by setting the DELETED flag on the mail message. If false, the SEEN flag is set instead. As of Camel 2.10 you can override this configuration option by setting a header with the key delete to determine if the mail should be deleted or not.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "disconnect": {
        "title": "Disconnect",
        "description": "Whether the consumer should disconnect after polling. If enabled this forces Camel to connect on each poll.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "handleFailedMessage": {
        "title": "Handle Failed Message",
        "description": "If the mail consumer cannot retrieve a given mail message, then this option allows to handle the caused exception by the consumer's error handler. By enable the bridge error handler on the consumer, then the Camel routing error handler can handle the exception instead. The default behavior would be the consumer throws an exception and no mails from the batch would be able to be routed by Camel.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "maxMessagesPerPoll": {
        "title": "Max Messages Per Poll",
        "description": "Specifies the maximum number of messages to gather per poll. By default, no maximum is set. Can be used to set a limit of e.g. 1000 to avoid downloading thousands of files when the server starts up. Set a value of 0 or negative to disable this option.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "mimeDecodeHeaders": {
        "title": "Mime Decode Headers",
        "description": "This option enables transparent MIME decoding and unfolding for mail headers.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "moveTo": {
        "title": "Move To",
        "description": "After processing a mail message, it can be moved to a mail folder with the given name. You can override this configuration value, with a header with the key moveTo, allowing you to move messages to folder names configured at runtime.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "peek": {
        "title": "Peek",
        "description": "Will mark the jakarta.mail.Message as peeked before processing the mail message. This applies to IMAPMessage messages types only. By using peek the mail will not be eager marked as SEEN on the mail server, which allows us to rollback the mail message if there is an error processing in Camel.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "sendEmptyMessageWhenIdle": {
        "title": "Send Empty Message When Idle",
        "description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "skipFailedMessage": {
        "title": "Skip Failed Message",
        "description": "If the mail consumer cannot retrieve a given mail message, then this option allows to skip the message and move on to retrieve the next mail message. The default behavior would be the consumer throws an exception and no mails from the batch would be able to be routed by Camel.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "unseen": {
        "title": "Unseen",
        "description": "Whether to limit by unseen mails only.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "bridgeErrorHandler": {
        "title": "Bridge Error Handler",
        "description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "exchangePattern": {
        "title": "Exchange Pattern",
        "description": "Sets the exchange pattern when the consumer creates an exchange.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer (advanced)",
        "enum": [
          "InOnly",
          "InOut"
        ]
      },
      "failOnDuplicateFileAttachment": {
        "title": "Fail On Duplicate File Attachment",
        "description": "Whether to fail processing the mail if the mail message contains attachments with duplicate file names. If set to false, then the duplicate attachment is skipped and a WARN is logged. If set to true then an exception is thrown failing to process the mail message.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "fetchSize": {
        "title": "Fetch Size",
        "description": "Sets the maximum number of messages to consume during a poll. This can be used to avoid overloading a mail server, if a mailbox folder contains a lot of messages. Default value of -1 means no fetch size and all messages will be consumed. Setting the value to 0 is a special corner case, where Camel will not consume any messages at all.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": -1,
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "folderName": {
        "title": "Folder Name",
        "description": "The folder to poll.",
        "datatype": "string",
        "defaultValue": "INBOX",
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "generateMissingAttachmentNames": {
        "title": "Generate Missing Attachment Names",
        "description": "Set this to 'uuid' to set a UUID for the filename of the attachment if no filename was set",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "handleDuplicateAttachmentNames": {
        "title": "Handle Duplicate Attachment Names",
        "description": "Set the strategy to handle duplicate filenames of attachments never: attachments that have a filename which is already present in the attachments will be ignored unless failOnDuplicateFileAttachment is set to true. uuidPrefix: this will prefix the duplicate attachment filenames each with a uuid and underscore (uuid_filename.fileextension). uuidSuffix: this will suffix the duplicate attachment filenames each with a underscore and uuid (filename_uuid.fileextension).",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "mapMailMessage": {
        "title": "Map Mail Message",
        "description": "Specifies whether Camel should map the received mail message to Camel body/headers/attachments. If set to true, the body of the mail message is mapped to the body of the Camel IN message, the mail headers are mapped to IN headers, and the attachments to Camel IN attachment message. If this option is set to false then the IN message contains a raw jakarta.mail.Message. You can retrieve this raw message by calling exchange.getIn().getBody(jakarta.mail.Message.class).",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "bcc": {
        "title": "Bcc",
        "description": "Sets the BCC email address. Separate multiple email addresses with comma.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "cc": {
        "title": "Cc",
        "description": "Sets the CC email address. Separate multiple email addresses with comma.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "from": {
        "title": "From",
        "description": "The from email address",
        "datatype": "string",
        "defaultValue": "camel@localhost",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "replyTo": {
        "title": "Reply To",
        "description": "The Reply-To recipients (the receivers of the response mail). Separate multiple email addresses with a comma.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "subject": {
        "title": "Subject",
        "description": "The Subject of the message being sent. Note: Setting the subject in the header takes precedence over this option.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "to": {
        "title": "To",
        "description": "Sets the To email address. Separate multiple email addresses with comma.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "lazyStartProducer": {
        "title": "Lazy Start Producer",
        "description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "alternativeBodyHeader": {
        "title": "Alternative Body Header",
        "description": "Specifies the key to an IN message header that contains an alternative email body. For example, if you send emails in text/html format and want to provide an alternative mail body for non-HTML email clients, set the alternative mail body with this key as a header.",
        "datatype": "string",
        "defaultValue": "CamelMailAlternativeBody",
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "connectionTimeout": {
        "title": "Connection Timeout",
        "description": "The connection timeout in milliseconds.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 30000,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "contentType": {
        "title": "Content Type",
        "description": "The mail message content type. Use text/html for HTML mails.",
        "datatype": "string",
        "defaultValue": "text/plain",
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "healthCheckConsumerEnabled": {
        "title": "Health Check Consumer Enabled",
        "description": "Used for enabling or disabling all consumer based health checks from this component",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "health"
      },
      "debugMode": {
        "title": "Debug Mode",
        "description": "Enable debug mode on the underlying mail framework. The SUN Mail framework logs the debug messages to System.out by default.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "ignoreUnsupportedCharset": {
        "title": "Ignore Unsupported Charset",
        "description": "Option to let Camel ignore unsupported charset in the local JVM when sending mails. If the charset is unsupported then charset=XXX (where XXX represents the unsupported charset) is removed from the content-type and it relies on the platform default instead.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "ignoreUriScheme": {
        "title": "Ignore Uri Scheme",
        "description": "Option to let Camel ignore unsupported charset in the local JVM when sending mails. If the charset is unsupported then charset=XXX (where XXX represents the unsupported charset) is removed from the content-type and it relies on the platform default instead.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "useInlineAttachments": {
        "title": "Use Inline Attachments",
        "description": "Whether to use disposition inline or attachment.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "idempotentRepositoryRemoveOnCommit": {
        "title": "Idempotent Repository Remove On Commit",
        "description": "When using idempotent repository, then when the mail message has been successfully processed and is committed, should the message id be removed from the idempotent repository (default) or be kept in the repository. By default its assumed the message id is unique and has no value to be kept in the repository, because the mail message will be marked as seen/moved or deleted to prevent it from being consumed again. And therefore having the message id stored in the idempotent repository has little value. However this option allows to store the message id, for whatever reason you may have.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "filter"
      },
      "backoffErrorThreshold": {
        "title": "Backoff Error Threshold",
        "description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "backoffIdleThreshold": {
        "title": "Backoff Idle Threshold",
        "description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "backoffMultiplier": {
        "title": "Backoff Multiplier",
        "description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "delay": {
        "title": "Delay",
        "description": "Milliseconds before the next poll.",
        "datatype": "number",
        "format": "duration",
        "defaultValue": 60000,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "greedy": {
        "title": "Greedy",
        "description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "initialDelay": {
        "title": "Initial Delay",
        "description": "Milliseconds before the first poll starts.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 1000,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "repeatCount": {
        "title": "Repeat Count",
        "description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 0,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "runLoggingLevel": {
        "title": "Run Logging Level",
        "description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
        "datatype": "string",
        "defaultValue": "TRACE",
        "secret": false,
        "required": false,
        "group": "scheduler",
        "enum": [
          "TRACE",
          "DEBUG",
          "INFO",
          "WARN",
          "ERROR",
          "OFF"
        ]
      },
      "startScheduler": {
        "title": "Start Scheduler",
        "description": "Whether the scheduler should be auto started.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "timeUnit": {
        "title": "Time Unit",
        "description": "Time unit for initialDelay and delay options.",
        "datatype": "string",
        "defaultValue": "MILLISECONDS",
        "secret": false,
        "required": false,
        "group": "scheduler",
        "enum": [
          "NANOSECONDS",
          "MICROSECONDS",
          "MILLISECONDS",
          "SECONDS",
          "MINUTES",
          "HOURS",
          "DAYS"
        ]
      },
      "useFixedDelay": {
        "title": "Use Fixed Delay",
        "description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "password": {
        "title": "Password",
        "description": "The password for login. See also setAuthenticator(MailAuthenticator).",
        "datatype": "string",
        "secret": true,
        "required": false,
        "group": "security"
      },
      "username": {
        "title": "Username",
        "description": "The username for login. See also setAuthenticator(MailAuthenticator).",
        "datatype": "string",
        "secret": true,
        "required": false,
        "group": "security"
      }
    },
    "pathProperties": {
      "host": {
        "title": "Host",
        "description": "The mail server host name",
        "datatype": "string",
        "secret": false,
        "required": true
      },
      "port": {
        "title": "Port",
        "description": "The port number of the mail server",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false
      }
    },
    "producer": true,
    "consumer": true
  },
  {
    "name": "jolt",
    "title": "JOLT",
    "description": "JSON to JSON transformation using JOLT.",
    "iconUrl": "https://tst-ipaas-public-assets.s3.us-east-1.amazonaws.com/images/components/jolt.svg",
    "syntax": "jolt:resourceUri",
    "properties": {
      "resourceUri": {
        "title": "Resource Uri",
        "description": "Path to the resource. You can prefix with: classpath, file, http, ref, or bean. classpath, file and http loads the resource using these protocols (classpath is default). ref will lookup the resource in the registry. bean will call a method on a bean to be used as the resource. For bean you can specify the method name after dot, eg bean:myBean.myMethod.",
        "datatype": "string",
        "secret": false,
        "required": true,
        "group": "producer"
      },
      "allowContextMapAll": {
        "title": "Allow Context Map All",
        "description": "Sets whether the context map should allow access to all details. By default only the message body and headers can be accessed. This option can be enabled for full access to the current Exchange and CamelContext. Doing so impose a potential security risk as this opens access to the full power of CamelContext API.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "allowTemplateFromHeader": {
        "title": "Allow Template From Header",
        "description": "Whether to allow to use resource template from header or not (default false). Enabling this allows to specify dynamic templates via message header. However this can be seen as a potential security vulnerability if the header is coming from a malicious user, so use this with care.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "contentCache": {
        "title": "Content Cache",
        "description": "Sets whether to use resource content cache or not",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "inputType": {
        "title": "Input Type",
        "description": "Specifies if the input is hydrated JSON or a JSON String.",
        "datatype": "string",
        "defaultValue": "Hydrated",
        "secret": false,
        "required": false,
        "group": "producer",
        "enum": [
          "Hydrated",
          "JsonString"
        ]
      },
      "outputType": {
        "title": "Output Type",
        "description": "Specifies if the output should be hydrated JSON or a JSON String.",
        "datatype": "string",
        "defaultValue": "Hydrated",
        "secret": false,
        "required": false,
        "group": "producer",
        "enum": [
          "Hydrated",
          "JsonString"
        ]
      },
      "transformDsl": {
        "title": "Transform Dsl",
        "description": "Specifies the Transform DSL of the endpoint resource. If none is specified Chainr will be used.",
        "datatype": "string",
        "defaultValue": "Chainr",
        "secret": false,
        "required": false,
        "group": "producer",
        "enum": [
          "Chainr",
          "Shiftr",
          "Defaultr",
          "Removr",
          "Sortr"
        ]
      },
      "lazyStartProducer": {
        "title": "Lazy Start Producer",
        "description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      }
    },
    "pathProperties": {
      "resourceUri": {
        "title": "Resource Uri",
        "description": "Path to the resource. You can prefix with: classpath, file, http, ref, or bean. classpath, file and http loads the resource using these protocols (classpath is default). ref will lookup the resource in the registry. bean will call a method on a bean to be used as the resource. For bean you can specify the method name after dot, eg bean:myBean.myMethod.",
        "datatype": "string",
        "secret": false,
        "required": true
      }
    },
    "producer": true,
    "consumer": false
  },
  {
    "name": "jslt",
    "title": "JSLT",
    "description": "Query or transform JSON payloads using an JSLT.",
    "iconUrl": "https://tst-ipaas-public-assets.s3.us-east-1.amazonaws.com/images/components/jslt.svg",
    "syntax": "jslt:resourceUri",
    "properties": {
      "resourceUri": {
        "title": "Resource Uri",
        "description": "Path to the resource. You can prefix with: classpath, file, http, ref, or bean. classpath, file and http loads the resource using these protocols (classpath is default). ref will lookup the resource in the registry. bean will call a method on a bean to be used as the resource. For bean you can specify the method name after dot, eg bean:myBean.myMethod.",
        "datatype": "string",
        "secret": false,
        "required": true,
        "group": "producer"
      },
      "allowContextMapAll": {
        "title": "Allow Context Map All",
        "description": "Sets whether the context map should allow access to all details. By default only the message body and headers can be accessed. This option can be enabled for full access to the current Exchange and CamelContext. Doing so impose a potential security risk as this opens access to the full power of CamelContext API.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "allowTemplateFromHeader": {
        "title": "Allow Template From Header",
        "description": "Whether to allow to use resource template from header or not (default false). Enabling this allows to specify dynamic templates via message header. However this can be seen as a potential security vulnerability if the header is coming from a malicious user, so use this with care.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "contentCache": {
        "title": "Content Cache",
        "description": "Sets whether to use resource content cache or not",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "mapBigDecimalAsFloats": {
        "title": "Map Big Decimal As Floats",
        "description": "If true, the mapper will use the USE_BIG_DECIMAL_FOR_FLOATS in serialization features",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "prettyPrint": {
        "title": "Pretty Print",
        "description": "If true, JSON in output message is pretty printed.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "common"
      },
      "lazyStartProducer": {
        "title": "Lazy Start Producer",
        "description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      }
    },
    "pathProperties": {
      "resourceUri": {
        "title": "Resource Uri",
        "description": "Path to the resource. You can prefix with: classpath, file, http, ref, or bean. classpath, file and http loads the resource using these protocols (classpath is default). ref will lookup the resource in the registry. bean will call a method on a bean to be used as the resource. For bean you can specify the method name after dot, eg bean:myBean.myMethod.",
        "datatype": "string",
        "secret": false,
        "required": true
      }
    },
    "producer": true,
    "consumer": false
  },
  {
    "name": "json-validator",
    "title": "JSON Schema Validator",
    "description": "Validate JSON payloads using NetworkNT JSON Schema.",
    "iconUrl": "https://tst-ipaas-public-assets.s3.us-east-1.amazonaws.com/images/components/json-validator.svg",
    "syntax": "json-validator:resourceUri",
    "properties": {
      "resourceUri": {
        "title": "Resource Uri",
        "description": "Path to the resource. You can prefix with: classpath, file, http, ref, or bean. classpath, file and http loads the resource using these protocols (classpath is default). ref will lookup the resource in the registry. bean will call a method on a bean to be used as the resource. For bean you can specify the method name after dot, eg bean:myBean.myMethod.",
        "datatype": "string",
        "secret": false,
        "required": true,
        "group": "producer"
      },
      "allowContextMapAll": {
        "title": "Allow Context Map All",
        "description": "Sets whether the context map should allow access to all details. By default only the message body and headers can be accessed. This option can be enabled for full access to the current Exchange and CamelContext. Doing so impose a potential security risk as this opens access to the full power of CamelContext API.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "contentCache": {
        "title": "Content Cache",
        "description": "Sets whether to use resource content cache or not",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "failOnNullBody": {
        "title": "Fail On Null Body",
        "description": "Whether to fail if no body exists.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "failOnNullHeader": {
        "title": "Fail On Null Header",
        "description": "Whether to fail if no header exists when validating against a header.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "headerName": {
        "title": "Header Name",
        "description": "To validate against a header instead of the message body.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "lazyStartProducer": {
        "title": "Lazy Start Producer",
        "description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      }
    },
    "pathProperties": {
      "resourceUri": {
        "title": "Resource Uri",
        "description": "Path to the resource. You can prefix with: classpath, file, http, ref, or bean. classpath, file and http loads the resource using these protocols (classpath is default). ref will lookup the resource in the registry. bean will call a method on a bean to be used as the resource. For bean you can specify the method name after dot, eg bean:myBean.myMethod.",
        "datatype": "string",
        "secret": false,
        "required": true
      }
    },
    "producer": true,
    "consumer": false
  },
  {
    "name": "jsonata",
    "title": "JSONata",
    "description": "Transforms JSON payload using JSONata transformation.",
    "iconUrl": "https://tst-ipaas-public-assets.s3.us-east-1.amazonaws.com/images/components/jsonata.svg",
    "syntax": "jsonata:resourceUri",
    "properties": {
      "resourceUri": {
        "title": "Resource Uri",
        "description": "Path to the resource. You can prefix with: classpath, file, http, ref, or bean. classpath, file and http loads the resource using these protocols (classpath is default). ref will lookup the resource in the registry. bean will call a method on a bean to be used as the resource. For bean you can specify the method name after dot, eg bean:myBean.myMethod.",
        "datatype": "string",
        "secret": false,
        "required": true,
        "group": "producer"
      },
      "allowContextMapAll": {
        "title": "Allow Context Map All",
        "description": "Sets whether the context map should allow access to all details. By default only the message body and headers can be accessed. This option can be enabled for full access to the current Exchange and CamelContext. Doing so impose a potential security risk as this opens access to the full power of CamelContext API.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "contentCache": {
        "title": "Content Cache",
        "description": "Sets whether to use resource content cache or not",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "inputType": {
        "title": "Input Type",
        "description": "Specifies if the input should be Jackson JsonNode or a JSON String.",
        "datatype": "string",
        "defaultValue": "Jackson",
        "secret": false,
        "required": false,
        "group": "producer",
        "enum": [
          "Jackson",
          "JsonString"
        ]
      },
      "outputType": {
        "title": "Output Type",
        "description": "Specifies if the output should be Jackson JsonNode or a JSON String.",
        "datatype": "string",
        "defaultValue": "Jackson",
        "secret": false,
        "required": false,
        "group": "producer",
        "enum": [
          "Jackson",
          "JsonString"
        ]
      },
      "lazyStartProducer": {
        "title": "Lazy Start Producer",
        "description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      }
    },
    "pathProperties": {
      "resourceUri": {
        "title": "Resource Uri",
        "description": "Path to the resource. You can prefix with: classpath, file, http, ref, or bean. classpath, file and http loads the resource using these protocols (classpath is default). ref will lookup the resource in the registry. bean will call a method on a bean to be used as the resource. For bean you can specify the method name after dot, eg bean:myBean.myMethod.",
        "datatype": "string",
        "secret": false,
        "required": true
      }
    },
    "producer": true,
    "consumer": false
  },
  {
    "name": "kafka",
    "title": "Kafka",
    "description": "Sent and receive messages to/from an Apache Kafka broker.",
    "iconUrl": "https://tst-ipaas-public-assets.s3.us-east-1.amazonaws.com/images/components/kafka.svg",
    "syntax": "kafka:topic",
    "properties": {
      "topic": {
        "title": "Topic",
        "description": "Name of the topic to use. On the consumer you can use comma to separate multiple topics. A producer can only send a message to a single topic.",
        "datatype": "string",
        "secret": false,
        "required": true,
        "group": "common"
      },
      "brokers": {
        "title": "Brokers",
        "description": "URL of the Kafka brokers to use. The format is host1:port1,host2:port2, and the list can be a subset of brokers or a VIP pointing to a subset of brokers. This option is known as bootstrap.servers in the Kafka documentation.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "common"
      },
      "clientId": {
        "title": "Client Id",
        "description": "The client id is a user-specified string sent in each request to help trace calls. It should logically identify the application making the request.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "common"
      },
      "reconnectBackoffMaxMs": {
        "title": "Reconnect Backoff Max Ms",
        "description": "The maximum amount of time in milliseconds to wait when reconnecting to a broker that has repeatedly failed to connect. If provided, the backoff per host will increase exponentially for each consecutive connection failure, up to this maximum. After calculating the backoff increase, 20% random jitter is added to avoid connection storms.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 1000,
        "secret": false,
        "required": false,
        "group": "common"
      },
      "shutdownTimeout": {
        "title": "Shutdown Timeout",
        "description": "Timeout in milliseconds to wait gracefully for the consumer or producer to shutdown and terminate its worker threads.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 30000,
        "secret": false,
        "required": false,
        "group": "common"
      },
      "allowManualCommit": {
        "title": "Allow Manual Commit",
        "description": "Whether to allow doing manual commits via KafkaManualCommit. If this option is enabled then an instance of KafkaManualCommit is stored on the Exchange message header, which allows end users to access this API and perform manual offset commits via the Kafka consumer.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "autoCommitEnable": {
        "title": "Auto Commit Enable",
        "description": "If true, periodically commit to ZooKeeper the offset of messages already fetched by the consumer. This committed offset will be used when the process fails as the position from which the new consumer will begin.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "autoCommitIntervalMs": {
        "title": "Auto Commit Interval Ms",
        "description": "The frequency in ms that the consumer offsets are committed to zookeeper.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 5000,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "autoOffsetReset": {
        "title": "Auto Offset Reset",
        "description": "What to do when there is no initial offset in ZooKeeper or if an offset is out of range: earliest : automatically reset the offset to the earliest offset latest : automatically reset the offset to the latest offset fail: throw exception to the consumer",
        "datatype": "string",
        "defaultValue": "latest",
        "secret": false,
        "required": false,
        "group": "consumer",
        "enum": [
          "latest",
          "earliest",
          "none"
        ]
      },
      "breakOnFirstError": {
        "title": "Break On First Error",
        "description": "This options controls what happens when a consumer is processing an exchange and it fails. If the option is false then the consumer continues to the next message and processes it. If the option is true then the consumer breaks out, and will seek back to offset of the message that caused a failure, and then re-attempt to process this message. However this can lead to endless processing of the same message if its bound to fail every time, eg a poison message. Therefore it is recommended to deal with that for example by using Camel's error handler.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "checkCrcs": {
        "title": "Check Crcs",
        "description": "Automatically check the CRC32 of the records consumed. This ensures no on-the-wire or on-disk corruption to the messages occurred. This check adds some overhead, so it may be disabled in cases seeking extreme performance.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "commitTimeoutMs": {
        "title": "Commit Timeout Ms",
        "description": "The maximum time, in milliseconds, that the code will wait for a synchronous commit to complete",
        "datatype": "number",
        "format": "duration",
        "defaultValue": 5000,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "consumerRequestTimeoutMs": {
        "title": "Consumer Request Timeout Ms",
        "description": "The configuration controls the maximum amount of time the client will wait for the response of a request. If the response is not received before the timeout elapses the client will resend the request if necessary or fail the request if retries are exhausted.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 40000,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "consumersCount": {
        "title": "Consumers Count",
        "description": "The number of consumers that connect to kafka server. Each consumer is run on a separate thread, that retrieves and process the incoming data.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 1,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "fetchMaxBytes": {
        "title": "Fetch Max Bytes",
        "description": "The maximum amount of data the server should return for a fetch request This is not an absolute maximum, if the first message in the first non-empty partition of the fetch is larger than this value, the message will still be returned to ensure that the consumer can make progress. The maximum message size accepted by the broker is defined via message.max.bytes (broker config) or max.message.bytes (topic config). Note that the consumer performs multiple fetches in parallel.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 52428800,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "fetchMinBytes": {
        "title": "Fetch Min Bytes",
        "description": "The minimum amount of data the server should return for a fetch request. If insufficient data is available the request will wait for that much data to accumulate before answering the request.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 1,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "fetchWaitMaxMs": {
        "title": "Fetch Wait Max Ms",
        "description": "The maximum amount of time the server will block before answering the fetch request if there isn't sufficient data to immediately satisfy fetch.min.bytes",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 500,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "groupId": {
        "title": "Group Id",
        "description": "A string that uniquely identifies the group of consumer processes to which this consumer belongs. By setting the same group id multiple processes indicate that they are all part of the same consumer group. This option is required for consumers.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "groupInstanceId": {
        "title": "Group Instance Id",
        "description": "A unique identifier of the consumer instance provided by the end user. Only non-empty strings are permitted. If set, the consumer is treated as a static member, which means that only one instance with this ID is allowed in the consumer group at any time. This can be used in combination with a larger session timeout to avoid group rebalances caused by transient unavailability (e.g. process restarts). If not set, the consumer will join the group as a dynamic member, which is the traditional behavior.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "heartbeatIntervalMs": {
        "title": "Heartbeat Interval Ms",
        "description": "The expected time between heartbeats to the consumer coordinator when using Kafka's group management facilities. Heartbeats are used to ensure that the consumer's session stays active and to facilitate rebalancing when new consumers join or leave the group. The value must be set lower than session.timeout.ms, but typically should be set no higher than 1/3 of that value. It can be adjusted even lower to control the expected time for normal rebalances.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 3000,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "keyDeserializer": {
        "title": "Key Deserializer",
        "description": "Deserializer class for the key that implements the Deserializer interface.",
        "datatype": "string",
        "defaultValue": "org.apache.kafka.common.serialization.StringDeserializer",
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "maxPartitionFetchBytes": {
        "title": "Max Partition Fetch Bytes",
        "description": "The maximum amount of data per-partition the server will return. The maximum total memory used for a request will be #partitions max.partition.fetch.bytes. This size must be at least as large as the maximum message size the server allows or else it is possible for the producer to send messages larger than the consumer can fetch. If that happens, the consumer can get stuck trying to fetch a large message on a certain partition.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 1048576,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "maxPollIntervalMs": {
        "title": "Max Poll Interval Ms",
        "description": "The maximum delay between invocations of poll() when using consumer group management. This places an upper bound on the amount of time that the consumer can be idle before fetching more records. If poll() is not called before expiration of this timeout, then the consumer is considered failed and the group will rebalance in order to reassign the partitions to another member.",
        "datatype": "number",
        "format": "duration",
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "maxPollRecords": {
        "title": "Max Poll Records",
        "description": "The maximum number of records returned in a single call to poll()",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 500,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "partitionAssignor": {
        "title": "Partition Assignor",
        "description": "The class name of the partition assignment strategy that the client will use to distribute partition ownership amongst consumer instances when group management is used",
        "datatype": "string",
        "defaultValue": "org.apache.kafka.clients.consumer.RangeAssignor",
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "pollOnError": {
        "title": "Poll On Error",
        "description": "What to do if kafka threw an exception while polling for new messages. Will by default use the value from the component configuration unless an explicit value has been configured on the endpoint level. DISCARD will discard the message and continue to poll next message. ERROR_HANDLER will use Camel's error handler to process the exception, and afterwards continue to poll next message. RECONNECT will re-connect the consumer and try poll the message again RETRY will let the consumer retry polling the same message again STOP will stop the consumer (have to be manually started/restarted if the consumer should be able to consume messages again)",
        "datatype": "string",
        "defaultValue": "ERROR_HANDLER",
        "secret": false,
        "required": false,
        "group": "consumer",
        "enum": [
          "DISCARD",
          "ERROR_HANDLER",
          "RECONNECT",
          "RETRY",
          "STOP"
        ]
      },
      "pollTimeoutMs": {
        "title": "Poll Timeout Ms",
        "description": "The timeout used when polling the KafkaConsumer.",
        "datatype": "number",
        "format": "duration",
        "defaultValue": 5000,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "seekTo": {
        "title": "Seek To",
        "description": "Set if KafkaConsumer will read from the beginning or the end on startup: SeekPolicy.BEGINNING: read from the beginning. SeekPolicy.END: read from the end.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer",
        "enum": [
          "BEGINNING",
          "END"
        ]
      },
      "sessionTimeoutMs": {
        "title": "Session Timeout Ms",
        "description": "The timeout used to detect failures when using Kafka's group management facilities.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 10000,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "specificAvroReader": {
        "title": "Specific Avro Reader",
        "description": "This enables the use of a specific Avro reader for use with the Confluent Platform schema registry and the io.confluent.kafka.serializers.KafkaAvroDeserializer. This option is only available in the Confluent Platform (not standard Apache Kafka)",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "topicIsPattern": {
        "title": "Topic Is Pattern",
        "description": "Whether the topic is a pattern (regular expression). This can be used to subscribe to dynamic number of topics matching the pattern.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "valueDeserializer": {
        "title": "Value Deserializer",
        "description": "Deserializer class for value that implements the Deserializer interface.",
        "datatype": "string",
        "defaultValue": "org.apache.kafka.common.serialization.StringDeserializer",
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "bridgeErrorHandler": {
        "title": "Bridge Error Handler",
        "description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "createConsumerBackoffInterval": {
        "title": "Create Consumer Backoff Interval",
        "description": "The delay in millis seconds to wait before trying again to create the kafka consumer (kafka-client).",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 5000,
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "exchangePattern": {
        "title": "Exchange Pattern",
        "description": "Sets the exchange pattern when the consumer creates an exchange.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer (advanced)",
        "enum": [
          "InOnly",
          "InOut"
        ]
      },
      "isolationLevel": {
        "title": "Isolation Level",
        "description": "Controls how to read messages written transactionally. If set to read_committed, consumer.poll() will only return transactional messages which have been committed. If set to read_uncommitted (the default), consumer.poll() will return all messages, even transactional messages which have been aborted. Non-transactional messages will be returned unconditionally in either mode. Messages will always be returned in offset order. Hence, in read_committed mode, consumer.poll() will only return messages up to the last stable offset (LSO), which is the one less than the offset of the first open transaction. In particular any messages appearing after messages belonging to ongoing transactions will be withheld until the relevant transaction has been completed. As a result, read_committed consumers will not be able to read up to the high watermark when there are in flight transactions. Further, when in read_committed the seekToEnd method will return the LSO",
        "datatype": "string",
        "defaultValue": "read_uncommitted",
        "secret": false,
        "required": false,
        "group": "consumer (advanced)",
        "enum": [
          "read_uncommitted",
          "read_committed"
        ]
      },
      "batchWithIndividualHeaders": {
        "title": "Batch With Individual Headers",
        "description": "If this feature is enabled and a single element of a batch is an Exchange or Message, the producer will generate individual kafka header values for it by using the batch Message to determine the values. Normal behaviour consists in always using the same header values (which are determined by the parent Exchange which contains the Iterable or Iterator).",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "bufferMemorySize": {
        "title": "Buffer Memory Size",
        "description": "The total bytes of memory the producer can use to buffer records waiting to be sent to the server. If records are sent faster than they can be delivered to the server the producer will either block or throw an exception based on the preference specified by block.on.buffer.full.This setting should correspond roughly to the total memory the producer will use, but is not a hard bound since not all memory the producer uses is used for buffering. Some additional memory will be used for compression (if compression is enabled) as well as for maintaining in-flight requests.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 33554432,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "compressionCodec": {
        "title": "Compression Codec",
        "description": "This parameter allows you to specify the compression codec for all data generated by this producer. Valid values are none, gzip, snappy, lz4 and zstd.",
        "datatype": "string",
        "defaultValue": "none",
        "secret": false,
        "required": false,
        "group": "producer",
        "enum": [
          "none",
          "gzip",
          "snappy",
          "lz4",
          "zstd"
        ]
      },
      "connectionMaxIdleMs": {
        "title": "Connection Max Idle Ms",
        "description": "Close idle connections after the number of milliseconds specified by this config.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 540000,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "deliveryTimeoutMs": {
        "title": "Delivery Timeout Ms",
        "description": "An upper bound on the time to report success or failure after a call to send() returns. This limits the total time that a record will be delayed prior to sending, the time to await acknowledgement from the broker (if expected), and the time allowed for retriable send failures.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 120000,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "enableIdempotence": {
        "title": "Enable Idempotence",
        "description": "When set to 'true', the producer will ensure that exactly one copy of each message is written in the stream. If 'false', producer retries due to broker failures, etc., may write duplicates of the retried message in the stream. Note that enabling idempotence requires max.in.flight.requests.per.connection to be less than or equal to 5 (with message ordering preserved for any allowable value), retries to be greater than 0, and acks must be 'all'. Idempotence is enabled by default if no conflicting configurations are set. If conflicting configurations are set and idempotence is not explicitly enabled, idempotence is disabled. If idempotence is explicitly enabled and conflicting configurations are set, a ConfigException is thrown.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "key": {
        "title": "Key",
        "description": "The record key (or null if no key is specified). If this option has been configured then it take precedence over header KafkaConstants#KEY",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "keySerializer": {
        "title": "Key Serializer",
        "description": "The serializer class for keys (defaults to the same as for messages if nothing is given).",
        "datatype": "string",
        "defaultValue": "org.apache.kafka.common.serialization.StringSerializer",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "lingerMs": {
        "title": "Linger Ms",
        "description": "The producer groups together any records that arrive in between request transmissions into a single batched request. Normally this occurs only under load when records arrive faster than they can be sent out. However in some circumstances the client may want to reduce the number of requests even under moderate load. This setting accomplishes this by adding a small amount of artificial delay that is, rather than immediately sending out a record the producer will wait for up to the given delay to allow other records to be sent so that they can be batched together. This can be thought of as analogous to Nagle's algorithm in TCP. This setting gives the upper bound on the delay for batching: once we get batch.size worth of records for a partition it will be sent immediately regardless of this setting, however if we have fewer than this many bytes accumulated for this partition we will 'linger' for the specified time waiting for more records to show up. This setting defaults to 0 (i.e. no delay). Setting linger.ms=5, for example, would have the effect of reducing the number of requests sent but would add up to 5ms of latency to records sent in the absense of load.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 0,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "maxBlockMs": {
        "title": "Max Block Ms",
        "description": "The configuration controls how long the KafkaProducer's send(), partitionsFor(), initTransactions(), sendOffsetsToTransaction(), commitTransaction() and abortTransaction() methods will block. For send() this timeout bounds the total time waiting for both metadata fetch and buffer allocation (blocking in the user-supplied serializers or partitioner is not counted against this timeout). For partitionsFor() this timeout bounds the time spent waiting for metadata if it is unavailable. The transaction-related methods always block, but may time out if the transaction coordinator could not be discovered or did not respond within the timeout.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 60000,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "maxInFlightRequest": {
        "title": "Max In Flight Request",
        "description": "The maximum number of unacknowledged requests the client will send on a single connection before blocking. Note that if this setting is set to be greater than 1 and there are failed sends, there is a risk of message re-ordering due to retries (i.e., if retries are enabled).",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 5,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "maxRequestSize": {
        "title": "Max Request Size",
        "description": "The maximum size of a request. This is also effectively a cap on the maximum record size. Note that the server has its own cap on record size which may be different from this. This setting will limit the number of record batches the producer will send in a single request to avoid sending huge requests.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 1048576,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "metadataMaxAgeMs": {
        "title": "Metadata Max Age Ms",
        "description": "The period of time in milliseconds after which we force a refresh of metadata even if we haven't seen any partition leadership changes to proactively discover any new brokers or partitions.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 300000,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "metricReporters": {
        "title": "Metric Reporters",
        "description": "A list of classes to use as metrics reporters. Implementing the MetricReporter interface allows plugging in classes that will be notified of new metric creation. The JmxReporter is always included to register JMX statistics.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "metricsSampleWindowMs": {
        "title": "Metrics Sample Window Ms",
        "description": "The window of time a metrics sample is computed over.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 30000,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "noOfMetricsSample": {
        "title": "No Of Metrics Sample",
        "description": "The number of samples maintained to compute metrics.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 2,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "partitioner": {
        "title": "Partitioner",
        "description": "The partitioner class for partitioning messages amongst sub-topics. The default partitioner is based on the hash of the key.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "partitionerIgnoreKeys": {
        "title": "Partitioner Ignore Keys",
        "description": "Whether the message keys should be ignored when computing partition. This setting has effect only when partitioner is not set",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "partitionKey": {
        "title": "Partition Key",
        "description": "The partition to which the record will be sent (or null if no partition was specified). If this option has been configured then it take precedence over header KafkaConstants#PARTITION_KEY",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "producerBatchSize": {
        "title": "Producer Batch Size",
        "description": "The producer will attempt to batch records together into fewer requests whenever multiple records are being sent to the same partition. This helps performance on both the client and the server. This configuration controls the default batch size in bytes. No attempt will be made to batch records larger than this size. Requests sent to brokers will contain multiple batches, one for each partition with data available to be sent. A small batch size will make batching less common and may reduce throughput (a batch size of zero will disable batching entirely). A very large batch size may use memory a bit more wastefully as we will always allocate a buffer of the specified batch size in anticipation of additional records.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 16384,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "queueBufferingMaxMessages": {
        "title": "Queue Buffering Max Messages",
        "description": "The maximum number of unsent messages that can be queued up the producer when using async mode before either the producer must be blocked or data must be dropped.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 10000,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "receiveBufferBytes": {
        "title": "Receive Buffer Bytes",
        "description": "The size of the TCP receive buffer (SO_RCVBUF) to use when reading data.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 65536,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "reconnectBackoffMs": {
        "title": "Reconnect Backoff Ms",
        "description": "The amount of time to wait before attempting to reconnect to a given host. This avoids repeatedly connecting to a host in a tight loop. This backoff applies to all requests sent by the consumer to the broker.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 50,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "recordMetadata": {
        "title": "Record Metadata",
        "description": "Whether the producer should store the RecordMetadata results from sending to Kafka. The results are stored in a List containing the RecordMetadata metadata's. The list is stored on a header with the key KafkaConstants#KAFKA_RECORDMETA",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "requestRequiredAcks": {
        "title": "Request Required Acks",
        "description": "The number of acknowledgments the producer requires the leader to have received before considering a request complete. This controls the durability of records that are sent. The following settings are allowed: acks=0 If set to zero then the producer will not wait for any acknowledgment from the server at all. The record will be immediately added to the socket buffer and considered sent. No guarantee can be made that the server has received the record in this case, and the retries configuration will not take effect (as the client won't generally know of any failures). The offset given back for each record will always be set to -1. acks=1 This will mean the leader will write the record to its local log but will respond without awaiting full acknowledgement from all followers. In this case should the leader fail immediately after acknowledging the record but before the followers have replicated it then the record will be lost. acks=all This means the leader will wait for the full set of in-sync replicas to acknowledge the record. This guarantees that the record will not be lost as long as at least one in-sync replica remains alive. This is the strongest available guarantee. This is equivalent to the acks=-1 setting. Note that enabling idempotence requires this config value to be 'all'. If conflicting configurations are set and idempotence is not explicitly enabled, idempotence is disabled.",
        "datatype": "string",
        "defaultValue": "all",
        "secret": false,
        "required": false,
        "group": "producer",
        "enum": [
          "all",
          "-1",
          "0",
          "1"
        ]
      },
      "requestTimeoutMs": {
        "title": "Request Timeout Ms",
        "description": "The amount of time the broker will wait trying to meet the request.required.acks requirement before sending back an error to the client.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 30000,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "retries": {
        "title": "Retries",
        "description": "Setting a value greater than zero will cause the client to resend any record whose send fails with a potentially transient error. Note that this retry is no different than if the client resent the record upon receiving the error. Produce requests will be failed before the number of retries has been exhausted if the timeout configured by delivery.timeout.ms expires first before successful acknowledgement. Users should generally prefer to leave this config unset and instead use delivery.timeout.ms to control retry behavior. Enabling idempotence requires this config value to be greater than 0. If conflicting configurations are set and idempotence is not explicitly enabled, idempotence is disabled. Allowing retries while setting enable.idempotence to false and max.in.flight.requests.per.connection to 1 will potentially change the ordering of records because if two batches are sent to a single partition, and the first fails and is retried but the second succeeds, then the records in the second batch may appear first.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "retryBackoffMs": {
        "title": "Retry Backoff Ms",
        "description": "Before each retry, the producer refreshes the metadata of relevant topics to see if a new leader has been elected. Since the leader election takes a bit of time, this property specifies the amount of time that the producer waits before refreshing the metadata.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 100,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "sendBufferBytes": {
        "title": "Send Buffer Bytes",
        "description": "Socket write buffer size",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 131072,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "valueSerializer": {
        "title": "Value Serializer",
        "description": "The serializer class for messages.",
        "datatype": "string",
        "defaultValue": "org.apache.kafka.common.serialization.StringSerializer",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "workerPoolCoreSize": {
        "title": "Worker Pool Core Size",
        "description": "Number of core threads for the worker pool for continue routing Exchange after kafka server has acknowledge the message that was sent to it from KafkaProducer using asynchronous non-blocking processing.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 10,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "workerPoolMaxSize": {
        "title": "Worker Pool Max Size",
        "description": "Maximum number of threads for the worker pool for continue routing Exchange after kafka server has acknowledge the message that was sent to it from KafkaProducer using asynchronous non-blocking processing.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 20,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "lazyStartProducer": {
        "title": "Lazy Start Producer",
        "description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "synchronous": {
        "title": "Synchronous",
        "description": "Sets whether synchronous processing should be strictly used",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "schemaRegistryURL": {
        "title": "Schema Registry URL",
        "description": "URL of the Confluent Platform schema registry servers to use. The format is host1:port1,host2:port2. This is known as schema.registry.url in the Confluent Platform documentation. This option is only available in the Confluent Platform (not standard Apache Kafka)",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "confluent"
      },
      "interceptorClasses": {
        "title": "Interceptor Classes",
        "description": "Sets interceptors for producer or consumers. Producer interceptors have to be classes implementing org.apache.kafka.clients.producer.ProducerInterceptor Consumer interceptors have to be classes implementing org.apache.kafka.clients.consumer.ConsumerInterceptor Note that if you use Producer interceptor on a consumer it will throw a class cast exception in runtime",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "monitoring"
      },
      "kerberosBeforeReloginMinTime": {
        "title": "Kerberos Before Relogin Min Time",
        "description": "Login thread sleep time between refresh attempts.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 60000,
        "secret": false,
        "required": false,
        "group": "security"
      },
      "kerberosConfigLocation": {
        "title": "Kerberos Config Location",
        "description": "Location of the kerberos config file.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "security"
      },
      "kerberosInitCmd": {
        "title": "Kerberos Init Cmd",
        "description": "Kerberos kinit command path. Default is /usr/bin/kinit",
        "datatype": "string",
        "defaultValue": "/usr/bin/kinit",
        "secret": false,
        "required": false,
        "group": "security"
      },
      "kerberosPrincipalToLocalRules": {
        "title": "Kerberos Principal To Local Rules",
        "description": "A list of rules for mapping from principal names to short names (typically operating system usernames). The rules are evaluated in order and the first rule that matches a principal name is used to map it to a short name. Any later rules in the list are ignored. By default, principal names of the form {username}/{hostname}{REALM} are mapped to {username}. For more details on the format please see the security authorization and acls documentation (at the Apache Kafka project). Multiple values can be separated by comma",
        "datatype": "string",
        "defaultValue": "DEFAULT",
        "secret": false,
        "required": false,
        "group": "security"
      },
      "kerberosRenewJitter": {
        "title": "Kerberos Renew Jitter",
        "description": "Percentage of random jitter added to the renewal time.",
        "datatype": "number",
        "defaultValue": 0.05,
        "secret": false,
        "required": false,
        "group": "security"
      },
      "kerberosRenewWindowFactor": {
        "title": "Kerberos Renew Window Factor",
        "description": "Login thread will sleep until the specified window factor of time from last refresh to ticket's expiry has been reached, at which time it will try to renew the ticket.",
        "datatype": "number",
        "defaultValue": 0.8,
        "secret": false,
        "required": false,
        "group": "security"
      },
      "saslJaasConfig": {
        "title": "Sasl Jaas Config",
        "description": "Expose the kafka sasl.jaas.config parameter Example: org.apache.kafka.common.security.plain.PlainLoginModule required username=USERNAME password=PASSWORD;",
        "datatype": "string",
        "secret": true,
        "required": false,
        "group": "security"
      },
      "saslKerberosServiceName": {
        "title": "Sasl Kerberos Service Name",
        "description": "The Kerberos principal name that Kafka runs as. This can be defined either in Kafka's JAAS config or in Kafka's config.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "security"
      },
      "saslMechanism": {
        "title": "Sasl Mechanism",
        "description": "The Simple Authentication and Security Layer (SASL) Mechanism used. For the valid values see http://www.iana.org/assignments/sasl-mechanisms/sasl-mechanisms.xhtml",
        "datatype": "string",
        "defaultValue": "GSSAPI",
        "secret": false,
        "required": false,
        "group": "security"
      },
      "securityProtocol": {
        "title": "Security Protocol",
        "description": "Protocol used to communicate with brokers. SASL_PLAINTEXT, PLAINTEXT, SASL_SSL and SSL are supported",
        "datatype": "string",
        "defaultValue": "PLAINTEXT",
        "secret": false,
        "required": false,
        "group": "security"
      },
      "sslCipherSuites": {
        "title": "Ssl Cipher Suites",
        "description": "A list of cipher suites. This is a named combination of authentication, encryption, MAC and key exchange algorithm used to negotiate the security settings for a network connection using TLS or SSL network protocol. By default all the available cipher suites are supported.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "security"
      },
      "sslEnabledProtocols": {
        "title": "Ssl Enabled Protocols",
        "description": "The list of protocols enabled for SSL connections. The default is TLSv1.2,TLSv1.3 when running with Java 11 or newer, TLSv1.2 otherwise. With the default value for Java 11, clients and servers will prefer TLSv1.3 if both support it and fallback to TLSv1.2 otherwise (assuming both support at least TLSv1.2). This default should be fine for most cases. Also see the config documentation for SslProtocol.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "security"
      },
      "sslEndpointAlgorithm": {
        "title": "Ssl Endpoint Algorithm",
        "description": "The endpoint identification algorithm to validate server hostname using server certificate. Use none or false to disable server hostname verification.",
        "datatype": "string",
        "defaultValue": "https",
        "secret": false,
        "required": false,
        "group": "security"
      },
      "sslKeymanagerAlgorithm": {
        "title": "Ssl Keymanager Algorithm",
        "description": "The algorithm used by key manager factory for SSL connections. Default value is the key manager factory algorithm configured for the Java Virtual Machine.",
        "datatype": "string",
        "defaultValue": "SunX509",
        "secret": false,
        "required": false,
        "group": "security"
      },
      "sslKeyPassword": {
        "title": "Ssl Key Password",
        "description": "The password of the private key in the key store file or the PEM key specified in sslKeystoreKey. This is required for clients only if two-way authentication is configured.",
        "datatype": "string",
        "secret": true,
        "required": false,
        "group": "security"
      },
      "sslKeystoreLocation": {
        "title": "Ssl Keystore Location",
        "description": "The location of the key store file. This is optional for the client and can be used for two-way authentication for the client.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "security"
      },
      "sslKeystorePassword": {
        "title": "Ssl Keystore Password",
        "description": "The store password for the key store file. This is optional for the client and only needed if sslKeystoreLocation' is configured. Key store password is not supported for PEM format.",
        "datatype": "string",
        "secret": true,
        "required": false,
        "group": "security"
      },
      "sslKeystoreType": {
        "title": "Ssl Keystore Type",
        "description": "The file format of the key store file. This is optional for client. Default value is JKS",
        "datatype": "string",
        "defaultValue": "JKS",
        "secret": false,
        "required": false,
        "group": "security"
      },
      "sslProtocol": {
        "title": "Ssl Protocol",
        "description": "The SSL protocol used to generate the SSLContext. The default is TLSv1.3 when running with Java 11 or newer, TLSv1.2 otherwise. This value should be fine for most use cases. Allowed values in recent JVMs are TLSv1.2 and TLSv1.3. TLS, TLSv1.1, SSL, SSLv2 and SSLv3 may be supported in older JVMs, but their usage is discouraged due to known security vulnerabilities. With the default value for this config and sslEnabledProtocols, clients will downgrade to TLSv1.2 if the server does not support TLSv1.3. If this config is set to TLSv1.2, clients will not use TLSv1.3 even if it is one of the values in sslEnabledProtocols and the server only supports TLSv1.3.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "security"
      },
      "sslProvider": {
        "title": "Ssl Provider",
        "description": "The name of the security provider used for SSL connections. Default value is the default security provider of the JVM.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "security"
      },
      "sslTrustmanagerAlgorithm": {
        "title": "Ssl Trustmanager Algorithm",
        "description": "The algorithm used by trust manager factory for SSL connections. Default value is the trust manager factory algorithm configured for the Java Virtual Machine.",
        "datatype": "string",
        "defaultValue": "PKIX",
        "secret": false,
        "required": false,
        "group": "security"
      },
      "sslTruststoreLocation": {
        "title": "Ssl Truststore Location",
        "description": "The location of the trust store file.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "security"
      },
      "sslTruststorePassword": {
        "title": "Ssl Truststore Password",
        "description": "The password for the trust store file. If a password is not set, trust store file configured will still be used, but integrity checking is disabled. Trust store password is not supported for PEM format.",
        "datatype": "string",
        "secret": true,
        "required": false,
        "group": "security"
      },
      "sslTruststoreType": {
        "title": "Ssl Truststore Type",
        "description": "The file format of the trust store file. Default value is JKS.",
        "datatype": "string",
        "defaultValue": "JKS",
        "secret": false,
        "required": false,
        "group": "security"
      },
      "useGlobalSslContextParameters": {
        "title": "Use Global Ssl Context Parameters",
        "description": "Enable usage of global SSL context parameters.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "security"
      }
    },
    "pathProperties": {
      "topic": {
        "title": "Topic",
        "description": "Name of the topic to use. On the consumer you can use comma to separate multiple topics. A producer can only send a message to a single topic.",
        "datatype": "string",
        "secret": false,
        "required": true
      }
    },
    "producer": true,
    "consumer": true
  },
  {
    "name": "log",
    "title": "Log",
    "description": "Log messages to the underlying logging mechanism.",
    "iconUrl": "https://tst-ipaas-public-assets.s3.us-east-1.amazonaws.com/images/components/log.svg",
    "syntax": "log:loggerName",
    "properties": {
      "loggerName": {
        "title": "Logger Name",
        "description": "Name of the logging category to use",
        "datatype": "string",
        "secret": false,
        "required": true,
        "group": "producer"
      },
      "groupActiveOnly": {
        "title": "Group Active Only",
        "description": "If true, will hide stats when no new messages have been received for a time interval, if false, show stats regardless of message traffic.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "groupDelay": {
        "title": "Group Delay",
        "description": "Set the initial delay for stats (in millis)",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "groupInterval": {
        "title": "Group Interval",
        "description": "If specified will group message stats by this time interval (in millis)",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "groupSize": {
        "title": "Group Size",
        "description": "An integer that specifies a group size for throughput logging.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "level": {
        "title": "Level",
        "description": "Logging level to use. The default value is INFO.",
        "datatype": "string",
        "defaultValue": "INFO",
        "secret": false,
        "required": false,
        "group": "producer",
        "enum": [
          "TRACE",
          "DEBUG",
          "INFO",
          "WARN",
          "ERROR",
          "OFF"
        ]
      },
      "logMask": {
        "title": "Log Mask",
        "description": "If true, mask sensitive information like password or passphrase in the log.",
        "datatype": "boolean",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "marker": {
        "title": "Marker",
        "description": "An optional Marker name to use.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "plain": {
        "title": "Plain",
        "description": "If enabled only the body will be printed out",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "sourceLocationLoggerName": {
        "title": "Source Location Logger Name",
        "description": "If enabled then the source location of where the log endpoint is used in Camel routes, would be used as logger name, instead of the given name. However, if the source location is disabled or not possible to resolve then the existing logger name will be used.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "lazyStartProducer": {
        "title": "Lazy Start Producer",
        "description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "maxChars": {
        "title": "Max Chars",
        "description": "Limits the number of characters logged per line.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 10000,
        "secret": false,
        "required": false,
        "group": "formatting"
      },
      "multiline": {
        "title": "Multiline",
        "description": "If enabled then each information is outputted on a newline.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "formatting"
      },
      "showAll": {
        "title": "Show All",
        "description": "Quick option for turning all options on. (multiline, maxChars has to be manually set if to be used)",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "formatting"
      },
      "showAllProperties": {
        "title": "Show All Properties",
        "description": "Show all of the exchange properties (both internal and custom).",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "formatting"
      },
      "showBody": {
        "title": "Show Body",
        "description": "Show the message body.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "formatting"
      },
      "showBodyType": {
        "title": "Show Body Type",
        "description": "Show the body Java type.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "formatting"
      },
      "showCachedStreams": {
        "title": "Show Cached Streams",
        "description": "Whether Camel should show cached stream bodies or not (org.apache.camel.StreamCache).",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "formatting"
      },
      "showCaughtException": {
        "title": "Show Caught Exception",
        "description": "If the exchange has a caught exception, show the exception message (no stack trace). A caught exception is stored as a property on the exchange (using the key org.apache.camel.Exchange#EXCEPTION_CAUGHT) and for instance a doCatch can catch exceptions.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "formatting"
      },
      "showException": {
        "title": "Show Exception",
        "description": "If the exchange has an exception, show the exception message (no stacktrace)",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "formatting"
      },
      "showExchangeId": {
        "title": "Show Exchange Id",
        "description": "Show the unique exchange ID.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "formatting"
      },
      "showExchangePattern": {
        "title": "Show Exchange Pattern",
        "description": "Shows the Message Exchange Pattern (or MEP for short).",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "formatting"
      },
      "showFiles": {
        "title": "Show Files",
        "description": "If enabled Camel will output files",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "formatting"
      },
      "showFuture": {
        "title": "Show Future",
        "description": "If enabled Camel will on Future objects wait for it to complete to obtain the payload to be logged.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "formatting"
      },
      "showHeaders": {
        "title": "Show Headers",
        "description": "Show the message headers.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "formatting"
      },
      "showProperties": {
        "title": "Show Properties",
        "description": "Show the exchange properties (only custom). Use showAllProperties to show both internal and custom properties.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "formatting"
      },
      "showStackTrace": {
        "title": "Show Stack Trace",
        "description": "Show the stack trace, if an exchange has an exception. Only effective if one of showAll, showException or showCaughtException are enabled.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "formatting"
      },
      "showStreams": {
        "title": "Show Streams",
        "description": "Whether Camel should show stream bodies or not (eg such as java.io.InputStream). Beware if you enable this option then you may not be able later to access the message body as the stream have already been read by this logger. To remedy this you will have to use Stream Caching.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "formatting"
      },
      "skipBodyLineSeparator": {
        "title": "Skip Body Line Separator",
        "description": "Whether to skip line separators when logging the message body. This allows to log the message body in one line, setting this option to false will preserve any line separators from the body, which then will log the body as is.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "formatting"
      },
      "style": {
        "title": "Style",
        "description": "Sets the outputs style to use.",
        "datatype": "string",
        "defaultValue": "Default",
        "secret": false,
        "required": false,
        "group": "formatting",
        "enum": [
          "Default",
          "Tab",
          "Fixed"
        ]
      }
    },
    "pathProperties": {
      "loggerName": {
        "title": "Logger Name",
        "description": "Name of the logging category to use",
        "datatype": "string",
        "secret": false,
        "required": true
      }
    },
    "producer": true,
    "consumer": false
  },
  {
    "name": "paho",
    "title": "Paho",
    "description": "Communicate with MQTT message brokers using Eclipse Paho MQTT Client.",
    "iconUrl": "https://tst-ipaas-public-assets.s3.us-east-1.amazonaws.com/images/components/paho.svg",
    "syntax": "paho:topic",
    "properties": {
      "topic": {
        "title": "Topic",
        "description": "Name of the topic",
        "datatype": "string",
        "secret": false,
        "required": true,
        "group": "common"
      },
      "automaticReconnect": {
        "title": "Automatic Reconnect",
        "description": "Sets whether the client will automatically attempt to reconnect to the server if the connection is lost. If set to false, the client will not attempt to automatically reconnect to the server in the event that the connection is lost. If set to true, in the event that the connection is lost, the client will attempt to reconnect to the server. It will initially wait 1 second before it attempts to reconnect, for every failed reconnect attempt, the delay will double until it is at 2 minutes at which point the delay will stay at 2 minutes.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "common"
      },
      "brokerUrl": {
        "title": "Broker Url",
        "description": "The URL of the MQTT broker.",
        "datatype": "string",
        "defaultValue": "tcp://localhost:1883",
        "secret": false,
        "required": false,
        "group": "common"
      },
      "cleanSession": {
        "title": "Clean Session",
        "description": "Sets whether the client and server should remember state across restarts and reconnects. If set to false both the client and server will maintain state across restarts of the client, the server and the connection. As state is maintained: Message delivery will be reliable meeting the specified QOS even if the client, server or connection are restarted. The server will treat a subscription as durable. If set to true the client and server will not maintain state across restarts of the client, the server or the connection. This means Message delivery to the specified QOS cannot be maintained if the client, server or connection are restarted The server will treat a subscription as non-durable",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "common"
      },
      "clientId": {
        "title": "Client Id",
        "description": "MQTT client identifier. The identifier must be unique.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "common"
      },
      "connectionTimeout": {
        "title": "Connection Timeout",
        "description": "Sets the connection timeout value. This value, measured in seconds, defines the maximum time interval the client will wait for the network connection to the MQTT server to be established. The default timeout is 30 seconds. A value of 0 disables timeout processing meaning the client will wait until the network connection is made successfully or fails.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 30,
        "secret": false,
        "required": false,
        "group": "common"
      },
      "filePersistenceDirectory": {
        "title": "File Persistence Directory",
        "description": "Base directory used by file persistence. Will by default use user directory.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "common"
      },
      "keepAliveInterval": {
        "title": "Keep Alive Interval",
        "description": "Sets the keep alive interval. This value, measured in seconds, defines the maximum time interval between messages sent or received. It enables the client to detect if the server is no longer available, without having to wait for the TCP/IP timeout. The client will ensure that at least one message travels across the network within each keep alive period. In the absence of a data-related message during the time period, the client sends a very small ping message, which the server will acknowledge. A value of 0 disables keepalive processing in the client. The default value is 60 seconds",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 60,
        "secret": false,
        "required": false,
        "group": "common"
      },
      "maxInflight": {
        "title": "Max Inflight",
        "description": "Sets the max inflight. please increase this value in a high traffic environment. The default value is 10",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 10,
        "secret": false,
        "required": false,
        "group": "common"
      },
      "maxReconnectDelay": {
        "title": "Max Reconnect Delay",
        "description": "Get the maximum time (in millis) to wait between reconnects",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 128000,
        "secret": false,
        "required": false,
        "group": "common"
      },
      "mqttVersion": {
        "title": "Mqtt Version",
        "description": "Sets the MQTT version. The default action is to connect with version 3.1.1, and to fall back to 3.1 if that fails. Version 3.1.1 or 3.1 can be selected specifically, with no fall back, by using the MQTT_VERSION_3_1_1 or MQTT_VERSION_3_1 options respectively.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "common"
      },
      "persistence": {
        "title": "Persistence",
        "description": "Client persistence to be used - memory or file.",
        "datatype": "string",
        "defaultValue": "MEMORY",
        "secret": false,
        "required": false,
        "group": "common",
        "enum": [
          "FILE",
          "MEMORY"
        ]
      },
      "qos": {
        "title": "Qos",
        "description": "Client quality of service level (0-2).",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 2,
        "secret": false,
        "required": false,
        "group": "common"
      },
      "retained": {
        "title": "Retained",
        "description": "Retain option",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "common"
      },
      "serverURIs": {
        "title": "Server URIs",
        "description": "Set a list of one or more serverURIs the client may connect to. Multiple servers can be separated by comma. Each serverURI specifies the address of a server that the client may connect to. Two types of connection are supported tcp:// for a TCP connection and ssl:// for a TCP connection secured by SSL/TLS. For example: tcp://localhost:1883 ssl://localhost:8883 If the port is not specified, it will default to 1883 for tcp:// URIs, and 8883 for ssl:// URIs. If serverURIs is set then it overrides the serverURI parameter passed in on the constructor of the MQTT client. When an attempt to connect is initiated the client will start with the first serverURI in the list and work through the list until a connection is established with a server. If a connection cannot be made to any of the servers then the connect attempt fails. Specifying a list of servers that a client may connect to has several uses: High Availability and reliable message delivery Some MQTT servers support a high availability feature where two or more equal MQTT servers share state. An MQTT client can connect to any of the equal servers and be assured that messages are reliably delivered and durable subscriptions are maintained no matter which server the client connects to. The cleansession flag must be set to false if durable subscriptions and/or reliable message delivery is required. Hunt List A set of servers may be specified that are not equal (as in the high availability option). As no state is shared across the servers reliable message delivery and durable subscriptions are not valid. The cleansession flag must be set to true if the hunt list mode is used",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "common"
      },
      "willPayload": {
        "title": "Will Payload",
        "description": "Sets the Last Will and Testament (LWT) for the connection. In the event that this client unexpectedly loses its connection to the server, the server will publish a message to itself using the supplied details. Sets the message for the LWT.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "common"
      },
      "willQos": {
        "title": "Will Qos",
        "description": "Sets the Last Will and Testament (LWT) for the connection. In the event that this client unexpectedly loses its connection to the server, the server will publish a message to itself using the supplied details. Sets the quality of service to publish the message at (0, 1 or 2).",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "common"
      },
      "willRetained": {
        "title": "Will Retained",
        "description": "Sets the Last Will and Testament (LWT) for the connection. In the event that this client unexpectedly loses its connection to the server, the server will publish a message to itself using the supplied details. Sets whether or not the message should be retained.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "common"
      },
      "willTopic": {
        "title": "Will Topic",
        "description": "Sets the Last Will and Testament (LWT) for the connection. In the event that this client unexpectedly loses its connection to the server, the server will publish a message to itself using the supplied details. Sets the topic that the willPayload will be published to.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "common"
      },
      "bridgeErrorHandler": {
        "title": "Bridge Error Handler",
        "description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "exchangePattern": {
        "title": "Exchange Pattern",
        "description": "Sets the exchange pattern when the consumer creates an exchange.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer (advanced)",
        "enum": [
          "InOnly",
          "InOut"
        ]
      },
      "lazyStartProducer": {
        "title": "Lazy Start Producer",
        "description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "executorServiceTimeout": {
        "title": "Executor Service Timeout",
        "description": "Set the time in seconds that the executor service should wait when terminating before forcefully terminating. It is not recommended to change this value unless you are absolutely sure that you need to.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 1,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "httpsHostnameVerificationEnabled": {
        "title": "Https Hostname Verification Enabled",
        "description": "Whether SSL HostnameVerifier is enabled or not. The default value is true.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "security"
      },
      "password": {
        "title": "Password",
        "description": "Password to be used for authentication against the MQTT broker",
        "datatype": "string",
        "secret": true,
        "required": false,
        "group": "security"
      },
      "userName": {
        "title": "User Name",
        "description": "Username to be used for authentication against the MQTT broker",
        "datatype": "string",
        "secret": true,
        "required": false,
        "group": "security"
      }
    },
    "pathProperties": {
      "topic": {
        "title": "Topic",
        "description": "Name of the topic",
        "datatype": "string",
        "secret": false,
        "required": true
      }
    },
    "producer": true,
    "consumer": true
  },
  {
    "name": "paho-mqtt5",
    "title": "Paho MQTT 5",
    "description": "Communicate with MQTT message brokers using Eclipse Paho MQTT v5 Client.",
    "iconUrl": "https://tst-ipaas-public-assets.s3.us-east-1.amazonaws.com/images/components/paho-mqtt5.svg",
    "syntax": "paho-mqtt5:topic",
    "properties": {
      "topic": {
        "title": "Topic",
        "description": "Name of the topic",
        "datatype": "string",
        "secret": false,
        "required": true,
        "group": "common"
      },
      "automaticReconnect": {
        "title": "Automatic Reconnect",
        "description": "Sets whether the client will automatically attempt to reconnect to the server if the connection is lost. If set to false, the client will not attempt to automatically reconnect to the server in the event that the connection is lost. If set to true, in the event that the connection is lost, the client will attempt to reconnect to the server. It will initially wait 1 second before it attempts to reconnect, for every failed reconnect attempt, the delay will double until it is at 2 minutes at which point the delay will stay at 2 minutes.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "common"
      },
      "brokerUrl": {
        "title": "Broker Url",
        "description": "The URL of the MQTT broker.",
        "datatype": "string",
        "defaultValue": "tcp://localhost:1883",
        "secret": false,
        "required": false,
        "group": "common"
      },
      "cleanStart": {
        "title": "Clean Start",
        "description": "Sets whether the client and server should remember state across restarts and reconnects. If set to false both the client and server will maintain state across restarts of the client, the server and the connection. As state is maintained: Message delivery will be reliable meeting the specified QOS even if the client, server or connection are restarted. The server will treat a subscription as durable. If set to true the client and server will not maintain state across restarts of the client, the server or the connection. This means Message delivery to the specified QOS cannot be maintained if the client, server or connection are restarted The server will treat a subscription as non-durable",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "common"
      },
      "clientId": {
        "title": "Client Id",
        "description": "MQTT client identifier. The identifier must be unique.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "common"
      },
      "connectionTimeout": {
        "title": "Connection Timeout",
        "description": "Sets the connection timeout value. This value, measured in seconds, defines the maximum time interval the client will wait for the network connection to the MQTT server to be established. The default timeout is 30 seconds. A value of 0 disables timeout processing meaning the client will wait until the network connection is made successfully or fails.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 30,
        "secret": false,
        "required": false,
        "group": "common"
      },
      "filePersistenceDirectory": {
        "title": "File Persistence Directory",
        "description": "Base directory used by file persistence. Will by default use user directory.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "common"
      },
      "keepAliveInterval": {
        "title": "Keep Alive Interval",
        "description": "Sets the keep alive interval. This value, measured in seconds, defines the maximum time interval between messages sent or received. It enables the client to detect if the server is no longer available, without having to wait for the TCP/IP timeout. The client will ensure that at least one message travels across the network within each keep alive period. In the absence of a data-related message during the time period, the client sends a very small ping message, which the server will acknowledge. A value of 0 disables keepalive processing in the client. The default value is 60 seconds",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 60,
        "secret": false,
        "required": false,
        "group": "common"
      },
      "maxReconnectDelay": {
        "title": "Max Reconnect Delay",
        "description": "Get the maximum time (in millis) to wait between reconnects",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 128000,
        "secret": false,
        "required": false,
        "group": "common"
      },
      "persistence": {
        "title": "Persistence",
        "description": "Client persistence to be used - memory or file.",
        "datatype": "string",
        "defaultValue": "MEMORY",
        "secret": false,
        "required": false,
        "group": "common",
        "enum": [
          "FILE",
          "MEMORY"
        ]
      },
      "qos": {
        "title": "Qos",
        "description": "Client quality of service level (0-2).",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 2,
        "secret": false,
        "required": false,
        "group": "common"
      },
      "receiveMaximum": {
        "title": "Receive Maximum",
        "description": "Sets the Receive Maximum. This value represents the limit of QoS 1 and QoS 2 publications that the client is willing to process concurrently. There is no mechanism to limit the number of QoS 0 publications that the Server might try to send. The default value is 65535",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 65535,
        "secret": false,
        "required": false,
        "group": "common"
      },
      "retained": {
        "title": "Retained",
        "description": "Retain option",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "common"
      },
      "serverURIs": {
        "title": "Server URIs",
        "description": "Set a list of one or more serverURIs the client may connect to. Multiple servers can be separated by comma. Each serverURI specifies the address of a server that the client may connect to. Two types of connection are supported tcp:// for a TCP connection and ssl:// for a TCP connection secured by SSL/TLS. For example: tcp://localhost:1883 ssl://localhost:8883 If the port is not specified, it will default to 1883 for tcp:// URIs, and 8883 for ssl:// URIs. If serverURIs is set then it overrides the serverURI parameter passed in on the constructor of the MQTT client. When an attempt to connect is initiated the client will start with the first serverURI in the list and work through the list until a connection is established with a server. If a connection cannot be made to any of the servers then the connect attempt fails. Specifying a list of servers that a client may connect to has several uses: High Availability and reliable message delivery Some MQTT servers support a high availability feature where two or more equal MQTT servers share state. An MQTT client can connect to any of the equal servers and be assured that messages are reliably delivered and durable subscriptions are maintained no matter which server the client connects to. The cleansession flag must be set to false if durable subscriptions and/or reliable message delivery is required. Hunt List A set of servers may be specified that are not equal (as in the high availability option). As no state is shared across the servers reliable message delivery and durable subscriptions are not valid. The cleansession flag must be set to true if the hunt list mode is used",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "common"
      },
      "sessionExpiryInterval": {
        "title": "Session Expiry Interval",
        "description": "Sets the Session Expiry Interval. This value, measured in seconds, defines the maximum time that the broker will maintain the session for once the client disconnects. Clients should only connect with a long Session Expiry interval if they intend to connect to the server at some later point in time. By default this value is -1 and so will not be sent, in this case, the session will not expire. If a 0 is sent, the session will end immediately once the Network Connection is closed. When the client has determined that it has no longer any use for the session, it should disconnect with a Session Expiry Interval set to 0.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": -1,
        "secret": false,
        "required": false,
        "group": "common"
      },
      "willPayload": {
        "title": "Will Payload",
        "description": "Sets the Last Will and Testament (LWT) for the connection. In the event that this client unexpectedly loses its connection to the server, the server will publish a message to itself using the supplied details. The byte payload for the message.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "common"
      },
      "willQos": {
        "title": "Will Qos",
        "description": "Sets the Last Will and Testament (LWT) for the connection. In the event that this client unexpectedly loses its connection to the server, the server will publish a message to itself using the supplied details. The quality of service to publish the message at (0, 1 or 2).",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 1,
        "secret": false,
        "required": false,
        "group": "common"
      },
      "willRetained": {
        "title": "Will Retained",
        "description": "Sets the Last Will and Testament (LWT) for the connection. In the event that this client unexpectedly loses its connection to the server, the server will publish a message to itself using the supplied details. Whether or not the message should be retained.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "common"
      },
      "willTopic": {
        "title": "Will Topic",
        "description": "Sets the Last Will and Testament (LWT) for the connection. In the event that this client unexpectedly loses its connection to the server, the server will publish a message to itself using the supplied details. The topic to publish to.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "common"
      },
      "bridgeErrorHandler": {
        "title": "Bridge Error Handler",
        "description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "exchangePattern": {
        "title": "Exchange Pattern",
        "description": "Sets the exchange pattern when the consumer creates an exchange.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer (advanced)",
        "enum": [
          "InOnly",
          "InOut"
        ]
      },
      "lazyStartProducer": {
        "title": "Lazy Start Producer",
        "description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "executorServiceTimeout": {
        "title": "Executor Service Timeout",
        "description": "Set the time in seconds that the executor service should wait when terminating before forcefully terminating. It is not recommended to change this value unless you are absolutely sure that you need to.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 1,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "httpsHostnameVerificationEnabled": {
        "title": "Https Hostname Verification Enabled",
        "description": "Whether SSL HostnameVerifier is enabled or not. The default value is true.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "security"
      },
      "password": {
        "title": "Password",
        "description": "Password to be used for authentication against the MQTT broker",
        "datatype": "string",
        "secret": true,
        "required": false,
        "group": "security"
      },
      "userName": {
        "title": "User Name",
        "description": "Username to be used for authentication against the MQTT broker",
        "datatype": "string",
        "secret": true,
        "required": false,
        "group": "security"
      }
    },
    "pathProperties": {
      "topic": {
        "title": "Topic",
        "description": "Name of the topic",
        "datatype": "string",
        "secret": false,
        "required": true
      }
    },
    "producer": true,
    "consumer": true
  },
  {
    "name": "pop3",
    "title": "POP3",
    "description": "Send and receive emails using imap, pop3 and smtp protocols.",
    "iconUrl": "https://tst-ipaas-public-assets.s3.us-east-1.amazonaws.com/images/components/pop3.svg",
    "syntax": "pop3:host:port",
    "properties": {
      "host": {
        "title": "Host",
        "description": "The mail server host name",
        "datatype": "string",
        "secret": false,
        "required": true,
        "group": "common"
      },
      "port": {
        "title": "Port",
        "description": "The port number of the mail server",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "common"
      },
      "closeFolder": {
        "title": "Close Folder",
        "description": "Whether the consumer should close the folder after polling. Setting this option to false and having disconnect=false as well, then the consumer keep the folder open between polls.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "copyTo": {
        "title": "Copy To",
        "description": "After processing a mail message, it can be copied to a mail folder with the given name. You can override this configuration value, with a header with the key copyTo, allowing you to copy messages to folder names configured at runtime.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "decodeFilename": {
        "title": "Decode Filename",
        "description": "If set to true, the MimeUtility.decodeText method will be used to decode the filename. This is similar to setting JVM system property mail.mime.encodefilename.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "delete": {
        "title": "Delete",
        "description": "Deletes the messages after they have been processed. This is done by setting the DELETED flag on the mail message. If false, the SEEN flag is set instead. As of Camel 2.10 you can override this configuration option by setting a header with the key delete to determine if the mail should be deleted or not.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "disconnect": {
        "title": "Disconnect",
        "description": "Whether the consumer should disconnect after polling. If enabled this forces Camel to connect on each poll.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "handleFailedMessage": {
        "title": "Handle Failed Message",
        "description": "If the mail consumer cannot retrieve a given mail message, then this option allows to handle the caused exception by the consumer's error handler. By enable the bridge error handler on the consumer, then the Camel routing error handler can handle the exception instead. The default behavior would be the consumer throws an exception and no mails from the batch would be able to be routed by Camel.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "maxMessagesPerPoll": {
        "title": "Max Messages Per Poll",
        "description": "Specifies the maximum number of messages to gather per poll. By default, no maximum is set. Can be used to set a limit of e.g. 1000 to avoid downloading thousands of files when the server starts up. Set a value of 0 or negative to disable this option.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "mimeDecodeHeaders": {
        "title": "Mime Decode Headers",
        "description": "This option enables transparent MIME decoding and unfolding for mail headers.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "moveTo": {
        "title": "Move To",
        "description": "After processing a mail message, it can be moved to a mail folder with the given name. You can override this configuration value, with a header with the key moveTo, allowing you to move messages to folder names configured at runtime.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "peek": {
        "title": "Peek",
        "description": "Will mark the jakarta.mail.Message as peeked before processing the mail message. This applies to IMAPMessage messages types only. By using peek the mail will not be eager marked as SEEN on the mail server, which allows us to rollback the mail message if there is an error processing in Camel.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "sendEmptyMessageWhenIdle": {
        "title": "Send Empty Message When Idle",
        "description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "skipFailedMessage": {
        "title": "Skip Failed Message",
        "description": "If the mail consumer cannot retrieve a given mail message, then this option allows to skip the message and move on to retrieve the next mail message. The default behavior would be the consumer throws an exception and no mails from the batch would be able to be routed by Camel.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "unseen": {
        "title": "Unseen",
        "description": "Whether to limit by unseen mails only.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "bridgeErrorHandler": {
        "title": "Bridge Error Handler",
        "description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "exchangePattern": {
        "title": "Exchange Pattern",
        "description": "Sets the exchange pattern when the consumer creates an exchange.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer (advanced)",
        "enum": [
          "InOnly",
          "InOut"
        ]
      },
      "failOnDuplicateFileAttachment": {
        "title": "Fail On Duplicate File Attachment",
        "description": "Whether to fail processing the mail if the mail message contains attachments with duplicate file names. If set to false, then the duplicate attachment is skipped and a WARN is logged. If set to true then an exception is thrown failing to process the mail message.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "fetchSize": {
        "title": "Fetch Size",
        "description": "Sets the maximum number of messages to consume during a poll. This can be used to avoid overloading a mail server, if a mailbox folder contains a lot of messages. Default value of -1 means no fetch size and all messages will be consumed. Setting the value to 0 is a special corner case, where Camel will not consume any messages at all.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": -1,
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "folderName": {
        "title": "Folder Name",
        "description": "The folder to poll.",
        "datatype": "string",
        "defaultValue": "INBOX",
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "generateMissingAttachmentNames": {
        "title": "Generate Missing Attachment Names",
        "description": "Set this to 'uuid' to set a UUID for the filename of the attachment if no filename was set",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "handleDuplicateAttachmentNames": {
        "title": "Handle Duplicate Attachment Names",
        "description": "Set the strategy to handle duplicate filenames of attachments never: attachments that have a filename which is already present in the attachments will be ignored unless failOnDuplicateFileAttachment is set to true. uuidPrefix: this will prefix the duplicate attachment filenames each with a uuid and underscore (uuid_filename.fileextension). uuidSuffix: this will suffix the duplicate attachment filenames each with a underscore and uuid (filename_uuid.fileextension).",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "mapMailMessage": {
        "title": "Map Mail Message",
        "description": "Specifies whether Camel should map the received mail message to Camel body/headers/attachments. If set to true, the body of the mail message is mapped to the body of the Camel IN message, the mail headers are mapped to IN headers, and the attachments to Camel IN attachment message. If this option is set to false then the IN message contains a raw jakarta.mail.Message. You can retrieve this raw message by calling exchange.getIn().getBody(jakarta.mail.Message.class).",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "bcc": {
        "title": "Bcc",
        "description": "Sets the BCC email address. Separate multiple email addresses with comma.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "cc": {
        "title": "Cc",
        "description": "Sets the CC email address. Separate multiple email addresses with comma.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "from": {
        "title": "From",
        "description": "The from email address",
        "datatype": "string",
        "defaultValue": "camel@localhost",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "replyTo": {
        "title": "Reply To",
        "description": "The Reply-To recipients (the receivers of the response mail). Separate multiple email addresses with a comma.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "subject": {
        "title": "Subject",
        "description": "The Subject of the message being sent. Note: Setting the subject in the header takes precedence over this option.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "to": {
        "title": "To",
        "description": "Sets the To email address. Separate multiple email addresses with comma.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "lazyStartProducer": {
        "title": "Lazy Start Producer",
        "description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "alternativeBodyHeader": {
        "title": "Alternative Body Header",
        "description": "Specifies the key to an IN message header that contains an alternative email body. For example, if you send emails in text/html format and want to provide an alternative mail body for non-HTML email clients, set the alternative mail body with this key as a header.",
        "datatype": "string",
        "defaultValue": "CamelMailAlternativeBody",
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "connectionTimeout": {
        "title": "Connection Timeout",
        "description": "The connection timeout in milliseconds.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 30000,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "contentType": {
        "title": "Content Type",
        "description": "The mail message content type. Use text/html for HTML mails.",
        "datatype": "string",
        "defaultValue": "text/plain",
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "healthCheckConsumerEnabled": {
        "title": "Health Check Consumer Enabled",
        "description": "Used for enabling or disabling all consumer based health checks from this component",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "health"
      },
      "debugMode": {
        "title": "Debug Mode",
        "description": "Enable debug mode on the underlying mail framework. The SUN Mail framework logs the debug messages to System.out by default.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "ignoreUnsupportedCharset": {
        "title": "Ignore Unsupported Charset",
        "description": "Option to let Camel ignore unsupported charset in the local JVM when sending mails. If the charset is unsupported then charset=XXX (where XXX represents the unsupported charset) is removed from the content-type and it relies on the platform default instead.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "ignoreUriScheme": {
        "title": "Ignore Uri Scheme",
        "description": "Option to let Camel ignore unsupported charset in the local JVM when sending mails. If the charset is unsupported then charset=XXX (where XXX represents the unsupported charset) is removed from the content-type and it relies on the platform default instead.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "useInlineAttachments": {
        "title": "Use Inline Attachments",
        "description": "Whether to use disposition inline or attachment.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "idempotentRepositoryRemoveOnCommit": {
        "title": "Idempotent Repository Remove On Commit",
        "description": "When using idempotent repository, then when the mail message has been successfully processed and is committed, should the message id be removed from the idempotent repository (default) or be kept in the repository. By default its assumed the message id is unique and has no value to be kept in the repository, because the mail message will be marked as seen/moved or deleted to prevent it from being consumed again. And therefore having the message id stored in the idempotent repository has little value. However this option allows to store the message id, for whatever reason you may have.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "filter"
      },
      "backoffErrorThreshold": {
        "title": "Backoff Error Threshold",
        "description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "backoffIdleThreshold": {
        "title": "Backoff Idle Threshold",
        "description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "backoffMultiplier": {
        "title": "Backoff Multiplier",
        "description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "delay": {
        "title": "Delay",
        "description": "Milliseconds before the next poll.",
        "datatype": "number",
        "format": "duration",
        "defaultValue": 60000,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "greedy": {
        "title": "Greedy",
        "description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "initialDelay": {
        "title": "Initial Delay",
        "description": "Milliseconds before the first poll starts.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 1000,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "repeatCount": {
        "title": "Repeat Count",
        "description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 0,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "runLoggingLevel": {
        "title": "Run Logging Level",
        "description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
        "datatype": "string",
        "defaultValue": "TRACE",
        "secret": false,
        "required": false,
        "group": "scheduler",
        "enum": [
          "TRACE",
          "DEBUG",
          "INFO",
          "WARN",
          "ERROR",
          "OFF"
        ]
      },
      "startScheduler": {
        "title": "Start Scheduler",
        "description": "Whether the scheduler should be auto started.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "timeUnit": {
        "title": "Time Unit",
        "description": "Time unit for initialDelay and delay options.",
        "datatype": "string",
        "defaultValue": "MILLISECONDS",
        "secret": false,
        "required": false,
        "group": "scheduler",
        "enum": [
          "NANOSECONDS",
          "MICROSECONDS",
          "MILLISECONDS",
          "SECONDS",
          "MINUTES",
          "HOURS",
          "DAYS"
        ]
      },
      "useFixedDelay": {
        "title": "Use Fixed Delay",
        "description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "password": {
        "title": "Password",
        "description": "The password for login. See also setAuthenticator(MailAuthenticator).",
        "datatype": "string",
        "secret": true,
        "required": false,
        "group": "security"
      },
      "username": {
        "title": "Username",
        "description": "The username for login. See also setAuthenticator(MailAuthenticator).",
        "datatype": "string",
        "secret": true,
        "required": false,
        "group": "security"
      }
    },
    "pathProperties": {
      "host": {
        "title": "Host",
        "description": "The mail server host name",
        "datatype": "string",
        "secret": false,
        "required": true
      },
      "port": {
        "title": "Port",
        "description": "The port number of the mail server",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false
      }
    },
    "producer": true,
    "consumer": true
  },
  {
    "name": "pop3s",
    "title": "POP3S",
    "description": "Send and receive emails using imap, pop3 and smtp protocols.",
    "iconUrl": "https://tst-ipaas-public-assets.s3.us-east-1.amazonaws.com/images/components/pop3s.svg",
    "syntax": "pop3s:host:port",
    "properties": {
      "host": {
        "title": "Host",
        "description": "The mail server host name",
        "datatype": "string",
        "secret": false,
        "required": true,
        "group": "common"
      },
      "port": {
        "title": "Port",
        "description": "The port number of the mail server",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "common"
      },
      "closeFolder": {
        "title": "Close Folder",
        "description": "Whether the consumer should close the folder after polling. Setting this option to false and having disconnect=false as well, then the consumer keep the folder open between polls.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "copyTo": {
        "title": "Copy To",
        "description": "After processing a mail message, it can be copied to a mail folder with the given name. You can override this configuration value, with a header with the key copyTo, allowing you to copy messages to folder names configured at runtime.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "decodeFilename": {
        "title": "Decode Filename",
        "description": "If set to true, the MimeUtility.decodeText method will be used to decode the filename. This is similar to setting JVM system property mail.mime.encodefilename.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "delete": {
        "title": "Delete",
        "description": "Deletes the messages after they have been processed. This is done by setting the DELETED flag on the mail message. If false, the SEEN flag is set instead. As of Camel 2.10 you can override this configuration option by setting a header with the key delete to determine if the mail should be deleted or not.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "disconnect": {
        "title": "Disconnect",
        "description": "Whether the consumer should disconnect after polling. If enabled this forces Camel to connect on each poll.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "handleFailedMessage": {
        "title": "Handle Failed Message",
        "description": "If the mail consumer cannot retrieve a given mail message, then this option allows to handle the caused exception by the consumer's error handler. By enable the bridge error handler on the consumer, then the Camel routing error handler can handle the exception instead. The default behavior would be the consumer throws an exception and no mails from the batch would be able to be routed by Camel.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "maxMessagesPerPoll": {
        "title": "Max Messages Per Poll",
        "description": "Specifies the maximum number of messages to gather per poll. By default, no maximum is set. Can be used to set a limit of e.g. 1000 to avoid downloading thousands of files when the server starts up. Set a value of 0 or negative to disable this option.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "mimeDecodeHeaders": {
        "title": "Mime Decode Headers",
        "description": "This option enables transparent MIME decoding and unfolding for mail headers.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "moveTo": {
        "title": "Move To",
        "description": "After processing a mail message, it can be moved to a mail folder with the given name. You can override this configuration value, with a header with the key moveTo, allowing you to move messages to folder names configured at runtime.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "peek": {
        "title": "Peek",
        "description": "Will mark the jakarta.mail.Message as peeked before processing the mail message. This applies to IMAPMessage messages types only. By using peek the mail will not be eager marked as SEEN on the mail server, which allows us to rollback the mail message if there is an error processing in Camel.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "sendEmptyMessageWhenIdle": {
        "title": "Send Empty Message When Idle",
        "description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "skipFailedMessage": {
        "title": "Skip Failed Message",
        "description": "If the mail consumer cannot retrieve a given mail message, then this option allows to skip the message and move on to retrieve the next mail message. The default behavior would be the consumer throws an exception and no mails from the batch would be able to be routed by Camel.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "unseen": {
        "title": "Unseen",
        "description": "Whether to limit by unseen mails only.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "bridgeErrorHandler": {
        "title": "Bridge Error Handler",
        "description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "exchangePattern": {
        "title": "Exchange Pattern",
        "description": "Sets the exchange pattern when the consumer creates an exchange.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer (advanced)",
        "enum": [
          "InOnly",
          "InOut"
        ]
      },
      "failOnDuplicateFileAttachment": {
        "title": "Fail On Duplicate File Attachment",
        "description": "Whether to fail processing the mail if the mail message contains attachments with duplicate file names. If set to false, then the duplicate attachment is skipped and a WARN is logged. If set to true then an exception is thrown failing to process the mail message.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "fetchSize": {
        "title": "Fetch Size",
        "description": "Sets the maximum number of messages to consume during a poll. This can be used to avoid overloading a mail server, if a mailbox folder contains a lot of messages. Default value of -1 means no fetch size and all messages will be consumed. Setting the value to 0 is a special corner case, where Camel will not consume any messages at all.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": -1,
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "folderName": {
        "title": "Folder Name",
        "description": "The folder to poll.",
        "datatype": "string",
        "defaultValue": "INBOX",
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "generateMissingAttachmentNames": {
        "title": "Generate Missing Attachment Names",
        "description": "Set this to 'uuid' to set a UUID for the filename of the attachment if no filename was set",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "handleDuplicateAttachmentNames": {
        "title": "Handle Duplicate Attachment Names",
        "description": "Set the strategy to handle duplicate filenames of attachments never: attachments that have a filename which is already present in the attachments will be ignored unless failOnDuplicateFileAttachment is set to true. uuidPrefix: this will prefix the duplicate attachment filenames each with a uuid and underscore (uuid_filename.fileextension). uuidSuffix: this will suffix the duplicate attachment filenames each with a underscore and uuid (filename_uuid.fileextension).",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "mapMailMessage": {
        "title": "Map Mail Message",
        "description": "Specifies whether Camel should map the received mail message to Camel body/headers/attachments. If set to true, the body of the mail message is mapped to the body of the Camel IN message, the mail headers are mapped to IN headers, and the attachments to Camel IN attachment message. If this option is set to false then the IN message contains a raw jakarta.mail.Message. You can retrieve this raw message by calling exchange.getIn().getBody(jakarta.mail.Message.class).",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "bcc": {
        "title": "Bcc",
        "description": "Sets the BCC email address. Separate multiple email addresses with comma.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "cc": {
        "title": "Cc",
        "description": "Sets the CC email address. Separate multiple email addresses with comma.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "from": {
        "title": "From",
        "description": "The from email address",
        "datatype": "string",
        "defaultValue": "camel@localhost",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "replyTo": {
        "title": "Reply To",
        "description": "The Reply-To recipients (the receivers of the response mail). Separate multiple email addresses with a comma.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "subject": {
        "title": "Subject",
        "description": "The Subject of the message being sent. Note: Setting the subject in the header takes precedence over this option.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "to": {
        "title": "To",
        "description": "Sets the To email address. Separate multiple email addresses with comma.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "lazyStartProducer": {
        "title": "Lazy Start Producer",
        "description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "alternativeBodyHeader": {
        "title": "Alternative Body Header",
        "description": "Specifies the key to an IN message header that contains an alternative email body. For example, if you send emails in text/html format and want to provide an alternative mail body for non-HTML email clients, set the alternative mail body with this key as a header.",
        "datatype": "string",
        "defaultValue": "CamelMailAlternativeBody",
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "connectionTimeout": {
        "title": "Connection Timeout",
        "description": "The connection timeout in milliseconds.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 30000,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "contentType": {
        "title": "Content Type",
        "description": "The mail message content type. Use text/html for HTML mails.",
        "datatype": "string",
        "defaultValue": "text/plain",
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "healthCheckConsumerEnabled": {
        "title": "Health Check Consumer Enabled",
        "description": "Used for enabling or disabling all consumer based health checks from this component",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "health"
      },
      "debugMode": {
        "title": "Debug Mode",
        "description": "Enable debug mode on the underlying mail framework. The SUN Mail framework logs the debug messages to System.out by default.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "ignoreUnsupportedCharset": {
        "title": "Ignore Unsupported Charset",
        "description": "Option to let Camel ignore unsupported charset in the local JVM when sending mails. If the charset is unsupported then charset=XXX (where XXX represents the unsupported charset) is removed from the content-type and it relies on the platform default instead.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "ignoreUriScheme": {
        "title": "Ignore Uri Scheme",
        "description": "Option to let Camel ignore unsupported charset in the local JVM when sending mails. If the charset is unsupported then charset=XXX (where XXX represents the unsupported charset) is removed from the content-type and it relies on the platform default instead.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "useInlineAttachments": {
        "title": "Use Inline Attachments",
        "description": "Whether to use disposition inline or attachment.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "idempotentRepositoryRemoveOnCommit": {
        "title": "Idempotent Repository Remove On Commit",
        "description": "When using idempotent repository, then when the mail message has been successfully processed and is committed, should the message id be removed from the idempotent repository (default) or be kept in the repository. By default its assumed the message id is unique and has no value to be kept in the repository, because the mail message will be marked as seen/moved or deleted to prevent it from being consumed again. And therefore having the message id stored in the idempotent repository has little value. However this option allows to store the message id, for whatever reason you may have.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "filter"
      },
      "backoffErrorThreshold": {
        "title": "Backoff Error Threshold",
        "description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "backoffIdleThreshold": {
        "title": "Backoff Idle Threshold",
        "description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "backoffMultiplier": {
        "title": "Backoff Multiplier",
        "description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "delay": {
        "title": "Delay",
        "description": "Milliseconds before the next poll.",
        "datatype": "number",
        "format": "duration",
        "defaultValue": 60000,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "greedy": {
        "title": "Greedy",
        "description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "initialDelay": {
        "title": "Initial Delay",
        "description": "Milliseconds before the first poll starts.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 1000,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "repeatCount": {
        "title": "Repeat Count",
        "description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 0,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "runLoggingLevel": {
        "title": "Run Logging Level",
        "description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
        "datatype": "string",
        "defaultValue": "TRACE",
        "secret": false,
        "required": false,
        "group": "scheduler",
        "enum": [
          "TRACE",
          "DEBUG",
          "INFO",
          "WARN",
          "ERROR",
          "OFF"
        ]
      },
      "startScheduler": {
        "title": "Start Scheduler",
        "description": "Whether the scheduler should be auto started.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "timeUnit": {
        "title": "Time Unit",
        "description": "Time unit for initialDelay and delay options.",
        "datatype": "string",
        "defaultValue": "MILLISECONDS",
        "secret": false,
        "required": false,
        "group": "scheduler",
        "enum": [
          "NANOSECONDS",
          "MICROSECONDS",
          "MILLISECONDS",
          "SECONDS",
          "MINUTES",
          "HOURS",
          "DAYS"
        ]
      },
      "useFixedDelay": {
        "title": "Use Fixed Delay",
        "description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "password": {
        "title": "Password",
        "description": "The password for login. See also setAuthenticator(MailAuthenticator).",
        "datatype": "string",
        "secret": true,
        "required": false,
        "group": "security"
      },
      "username": {
        "title": "Username",
        "description": "The username for login. See also setAuthenticator(MailAuthenticator).",
        "datatype": "string",
        "secret": true,
        "required": false,
        "group": "security"
      }
    },
    "pathProperties": {
      "host": {
        "title": "Host",
        "description": "The mail server host name",
        "datatype": "string",
        "secret": false,
        "required": true
      },
      "port": {
        "title": "Port",
        "description": "The port number of the mail server",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false
      }
    },
    "producer": true,
    "consumer": true
  },
  {
    "name": "quartz",
    "title": "Quartz",
    "description": "Schedule sending of messages using the Quartz 2.x scheduler.",
    "iconUrl": "https://tst-ipaas-public-assets.s3.us-east-1.amazonaws.com/images/components/quartz.svg",
    "syntax": "quartz:groupName/triggerName",
    "properties": {
      "groupName": {
        "title": "Group Name",
        "description": "The quartz group name to use. The combination of group name and trigger name should be unique.",
        "datatype": "string",
        "defaultValue": "Camel",
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "triggerName": {
        "title": "Trigger Name",
        "description": "The quartz trigger name to use. The combination of group name and trigger name should be unique.",
        "datatype": "string",
        "secret": false,
        "required": true,
        "group": "consumer"
      },
      "cron": {
        "title": "Cron",
        "description": "Specifies a cron expression to define when to trigger.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "deleteJob": {
        "title": "Delete Job",
        "description": "If set to true, then the trigger automatically delete when route stop. Else if set to false, it will remain in scheduler. When set to false, it will also mean user may reuse pre-configured trigger with camel Uri. Just ensure the names match. Notice you cannot have both deleteJob and pauseJob set to true.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "durableJob": {
        "title": "Durable Job",
        "description": "Whether or not the job should remain stored after it is orphaned (no triggers point to it).",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "pauseJob": {
        "title": "Pause Job",
        "description": "If set to true, then the trigger automatically pauses when route stop. Else if set to false, it will remain in scheduler. When set to false, it will also mean user may reuse pre-configured trigger with camel Uri. Just ensure the names match. Notice you cannot have both deleteJob and pauseJob set to true.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "recoverableJob": {
        "title": "Recoverable Job",
        "description": "Instructs the scheduler whether or not the job should be re-executed if a 'recovery' or 'fail-over' situation is encountered.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "stateful": {
        "title": "Stateful",
        "description": "Uses a Quartz PersistJobDataAfterExecution and DisallowConcurrentExecution instead of the default job.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "bridgeErrorHandler": {
        "title": "Bridge Error Handler",
        "description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "exchangePattern": {
        "title": "Exchange Pattern",
        "description": "Sets the exchange pattern when the consumer creates an exchange.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer (advanced)",
        "enum": [
          "InOnly",
          "InOut"
        ]
      },
      "interruptJobsOnShutdown": {
        "title": "Interrupt Jobs On Shutdown",
        "description": "Whether to interrupt jobs on shutdown which forces the scheduler to shutdown quicker and attempt to interrupt any running jobs. If this is enabled then any running jobs can fail due to being interrupted. When a job is interrupted then Camel will mark the exchange to stop continue routing and set java.util.concurrent.RejectedExecutionException as caused exception. Therefore use this with care, as its often better to allow Camel jobs to complete and shutdown gracefully.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "ignoreExpiredNextFireTime": {
        "title": "Ignore Expired Next Fire Time",
        "description": "Whether to ignore quartz cannot schedule a trigger because the trigger will never fire in the future. This can happen when using a cron trigger that are configured to only run in the past. By default, Quartz will fail to schedule the trigger and therefore fail to start the Camel route. You can set this to true which then logs a WARN and then ignore the problem, meaning that the route will never fire in the future.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "prefixJobNameWithEndpointId": {
        "title": "Prefix Job Name With Endpoint Id",
        "description": "Whether the job name should be prefixed with endpoint id",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "usingFixedCamelContextName": {
        "title": "Using Fixed Camel Context Name",
        "description": "If it is true, JobDataMap uses the CamelContext name directly to reference the CamelContext, if it is false, JobDataMap uses use the CamelContext management name which could be changed during the deploy time.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "autoStartScheduler": {
        "title": "Auto Start Scheduler",
        "description": "Whether or not the scheduler should be auto started.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "triggerStartDelay": {
        "title": "Trigger Start Delay",
        "description": "In case of scheduler has already started, we want the trigger start slightly after current time to ensure endpoint is fully started before the job kicks in. Negative value shifts trigger start time in the past.",
        "datatype": "number",
        "format": "duration",
        "defaultValue": 500,
        "secret": false,
        "required": false,
        "group": "scheduler"
      }
    },
    "pathProperties": {
      "groupName": {
        "title": "Group Name",
        "description": "The quartz group name to use. The combination of group name and trigger name should be unique.",
        "datatype": "string",
        "secret": false,
        "required": false
      },
      "triggerName": {
        "title": "Trigger Name",
        "description": "The quartz trigger name to use. The combination of group name and trigger name should be unique.",
        "datatype": "string",
        "secret": false,
        "required": true
      }
    },
    "producer": false,
    "consumer": true
  },
  {
    "name": "rest",
    "title": "REST",
    "description": "Expose REST services or call external REST services.",
    "iconUrl": "https://tst-ipaas-public-assets.s3.us-east-1.amazonaws.com/images/components/rest.svg",
    "syntax": "rest:method:path:uriTemplate",
    "properties": {
      "method": {
        "title": "Method",
        "description": "HTTP method to use.",
        "datatype": "string",
        "secret": false,
        "required": true,
        "group": "common",
        "enum": [
          "get",
          "post",
          "put",
          "delete",
          "patch",
          "head",
          "trace",
          "connect",
          "options"
        ]
      },
      "path": {
        "title": "Path",
        "description": "The base path",
        "datatype": "string",
        "secret": false,
        "required": true,
        "group": "common"
      },
      "uriTemplate": {
        "title": "Uri Template",
        "description": "The uri template",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "common"
      },
      "consumes": {
        "title": "Consumes",
        "description": "Media type such as: 'text/xml', or 'application/json' this REST service accepts. By default we accept all kinds of types.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "common"
      },
      "inType": {
        "title": "In Type",
        "description": "To declare the incoming POJO binding type as a FQN class name",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "common"
      },
      "outType": {
        "title": "Out Type",
        "description": "To declare the outgoing POJO binding type as a FQN class name",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "common"
      },
      "produces": {
        "title": "Produces",
        "description": "Media type such as: 'text/xml', or 'application/json' this REST service returns.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "common"
      },
      "routeId": {
        "title": "Route Id",
        "description": "Name of the route this REST services creates",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "common"
      },
      "consumerComponentName": {
        "title": "Consumer Component Name",
        "description": "The Camel Rest component to use for the consumer REST transport, such as jetty, servlet, undertow. If no component has been explicitly configured, then Camel will lookup if there is a Camel component that integrates with the Rest DSL, or if a org.apache.camel.spi.RestConsumerFactory is registered in the registry. If either one is found, then that is being used.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "description": {
        "title": "Description",
        "description": "Human description to document this REST service",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "bridgeErrorHandler": {
        "title": "Bridge Error Handler",
        "description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "exchangePattern": {
        "title": "Exchange Pattern",
        "description": "Sets the exchange pattern when the consumer creates an exchange.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer (advanced)",
        "enum": [
          "InOnly",
          "InOut"
        ]
      },
      "apiDoc": {
        "title": "Api Doc",
        "description": "The openapi api doc resource to use. The resource is loaded from classpath by default and must be in JSON format.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "bindingMode": {
        "title": "Binding Mode",
        "description": "Configures the binding mode for the producer. If set to anything other than 'off' the producer will try to convert the body of the incoming message from inType to the json or xml, and the response from json or xml to outType.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer",
        "enum": [
          "auto",
          "off",
          "json",
          "xml",
          "json_xml"
        ]
      },
      "host": {
        "title": "Host",
        "description": "Host and port of HTTP service to use (override host in openapi schema)",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "producerComponentName": {
        "title": "Producer Component Name",
        "description": "The Camel Rest component to use for the producer REST transport, such as http, undertow. If no component has been explicitly configured, then Camel will lookup if there is a Camel component that integrates with the Rest DSL, or if a org.apache.camel.spi.RestProducerFactory is registered in the registry. If either one is found, then that is being used.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "queryParameters": {
        "title": "Query Parameters",
        "description": "Query parameters for the HTTP service to call. The query parameters can contain multiple parameters separated by ampersand such such as foo=123&bar=456.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "lazyStartProducer": {
        "title": "Lazy Start Producer",
        "description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      }
    },
    "pathProperties": {
      "method": {
        "title": "Method",
        "description": "HTTP method to use.",
        "datatype": "string",
        "secret": false,
        "required": true,
        "enum": [
          "get",
          "post",
          "put",
          "delete",
          "patch",
          "head",
          "trace",
          "connect",
          "options"
        ]
      },
      "path": {
        "title": "Path",
        "description": "The base path",
        "datatype": "string",
        "secret": false,
        "required": true
      },
      "uriTemplate": {
        "title": "Uri Template",
        "description": "The uri template",
        "datatype": "string",
        "secret": false,
        "required": false
      }
    },
    "producer": true,
    "consumer": true
  },
  {
    "name": "scheduler",
    "title": "Scheduler",
    "description": "Generate messages in specified intervals using java.util.concurrent.ScheduledExecutorService.",
    "iconUrl": "https://tst-ipaas-public-assets.s3.us-east-1.amazonaws.com/images/components/scheduler.svg",
    "syntax": "scheduler:name",
    "properties": {
      "name": {
        "title": "Name",
        "description": "The name of the scheduler",
        "datatype": "string",
        "secret": false,
        "required": true,
        "group": "consumer"
      },
      "sendEmptyMessageWhenIdle": {
        "title": "Send Empty Message When Idle",
        "description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "bridgeErrorHandler": {
        "title": "Bridge Error Handler",
        "description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "healthCheckProducerEnabled": {
        "title": "Health Check Producer Enabled",
        "description": "Used for enabling or disabling all producer based health checks from this component. Notice: Camel has by default disabled all producer based health-checks. You can turn on producer checks globally by setting camel.health.producersEnabled=true.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "health"
      },
      "exchangePattern": {
        "title": "Exchange Pattern",
        "description": "Sets the exchange pattern when the consumer creates an exchange.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer (advanced)",
        "enum": [
          "InOnly",
          "InOut"
        ]
      },
      "synchronous": {
        "title": "Synchronous",
        "description": "Sets whether synchronous processing should be strictly used",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "backoffErrorThreshold": {
        "title": "Backoff Error Threshold",
        "description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "backoffIdleThreshold": {
        "title": "Backoff Idle Threshold",
        "description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "backoffMultiplier": {
        "title": "Backoff Multiplier",
        "description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "delay": {
        "title": "Delay",
        "description": "Milliseconds before the next poll.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 500,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "greedy": {
        "title": "Greedy",
        "description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "initialDelay": {
        "title": "Initial Delay",
        "description": "Milliseconds before the first poll starts.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 1000,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "poolSize": {
        "title": "Pool Size",
        "description": "Number of core threads in the thread pool used by the scheduling thread pool. Is by default using a single thread",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 1,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "repeatCount": {
        "title": "Repeat Count",
        "description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 0,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "runLoggingLevel": {
        "title": "Run Logging Level",
        "description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
        "datatype": "string",
        "defaultValue": "TRACE",
        "secret": false,
        "required": false,
        "group": "scheduler",
        "enum": [
          "TRACE",
          "DEBUG",
          "INFO",
          "WARN",
          "ERROR",
          "OFF"
        ]
      },
      "startScheduler": {
        "title": "Start Scheduler",
        "description": "Whether the scheduler should be auto started.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "timeUnit": {
        "title": "Time Unit",
        "description": "Time unit for initialDelay and delay options.",
        "datatype": "string",
        "defaultValue": "MILLISECONDS",
        "secret": false,
        "required": false,
        "group": "scheduler",
        "enum": [
          "NANOSECONDS",
          "MICROSECONDS",
          "MILLISECONDS",
          "SECONDS",
          "MINUTES",
          "HOURS",
          "DAYS"
        ]
      },
      "useFixedDelay": {
        "title": "Use Fixed Delay",
        "description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "scheduler"
      }
    },
    "pathProperties": {
      "name": {
        "title": "Name",
        "description": "The name of the scheduler",
        "datatype": "string",
        "secret": false,
        "required": true
      }
    },
    "producer": false,
    "consumer": true
  },
  {
    "name": "sftp",
    "title": "SFTP",
    "description": "Upload and download files to/from SFTP servers.",
    "iconUrl": "https://tst-ipaas-public-assets.s3.us-east-1.amazonaws.com/images/components/sftp.svg",
    "syntax": "sftp:host:port/directoryName",
    "properties": {
      "host": {
        "title": "Host",
        "description": "Hostname of the FTP server",
        "datatype": "string",
        "secret": false,
        "required": true,
        "group": "common"
      },
      "port": {
        "title": "Port",
        "description": "Port of the FTP server",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "common"
      },
      "directoryName": {
        "title": "Directory Name",
        "description": "The starting directory",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "common"
      },
      "binary": {
        "title": "Binary",
        "description": "Specifies the file transfer mode, BINARY or ASCII. Default is ASCII (false).",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "common"
      },
      "charset": {
        "title": "Charset",
        "description": "This option is used to specify the encoding of the file. You can use this on the consumer, to specify the encodings of the files, which allow Camel to know the charset it should load the file content in case the file content is being accessed. Likewise when writing a file, you can use this option to specify which charset to write the file as well. Do mind that when writing the file Camel may have to read the message content into memory to be able to convert the data into the configured charset, so do not use this if you have big messages.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "common"
      },
      "disconnect": {
        "title": "Disconnect",
        "description": "Whether or not to disconnect from remote FTP server right after use. Disconnect will only disconnect the current connection to the FTP server. If you have a consumer which you want to stop, then you need to stop the consumer/route instead.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "common"
      },
      "doneFileName": {
        "title": "Done File Name",
        "description": "Producer: If provided, then Camel will write a 2nd done file when the original file has been written. The done file will be empty. This option configures what file name to use. Either you can specify a fixed name. Or you can use dynamic placeholders. The done file will always be written in the same folder as the original file. Consumer: If provided, Camel will only consume files if a done file exists. This option configures what file name to use. Either you can specify a fixed name. Or you can use dynamic placeholders.The done file is always expected in the same folder as the original file. Only ${file.name} and ${file.name.next} is supported as dynamic placeholders.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "common"
      },
      "fileName": {
        "title": "File Name",
        "description": "Use Expression such as File Language to dynamically set the filename. For consumers, it's used as a filename filter. For producers, it's used to evaluate the filename to write. If an expression is set, it take precedence over the CamelFileName header. (Note: The header itself can also be an Expression). The expression options support both String and Expression types. If the expression is a String type, it is always evaluated using the File Language. If the expression is an Expression type, the specified Expression type is used - this allows you, for instance, to use OGNL expressions. For the consumer, you can use it to filter filenames, so you can for instance consume today's file using the File Language syntax: mydata-${date:now:yyyyMMdd}.txt. The producers support the CamelOverruleFileName header which takes precedence over any existing CamelFileName header; the CamelOverruleFileName is a header that is used only once, and makes it easier as this avoids to temporary store CamelFileName and have to restore it afterwards.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "common"
      },
      "jschLoggingLevel": {
        "title": "Jsch Logging Level",
        "description": "The logging level to use for JSCH activity logging. As JSCH is verbose at by default at INFO level the threshold is WARN by default.",
        "datatype": "string",
        "defaultValue": "WARN",
        "secret": false,
        "required": false,
        "group": "common",
        "enum": [
          "TRACE",
          "DEBUG",
          "INFO",
          "WARN",
          "ERROR",
          "OFF"
        ]
      },
      "passiveMode": {
        "title": "Passive Mode",
        "description": "Sets passive mode connections. Default is active mode connections.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "common"
      },
      "separator": {
        "title": "Separator",
        "description": "Sets the path separator to be used. UNIX = Uses unix style path separator Windows = Uses windows style path separator Auto = (is default) Use existing path separator in file name",
        "datatype": "string",
        "defaultValue": "UNIX",
        "secret": false,
        "required": false,
        "group": "common",
        "enum": [
          "UNIX",
          "Windows",
          "Auto"
        ]
      },
      "fastExistsCheck": {
        "title": "Fast Exists Check",
        "description": "If set this option to be true, camel-ftp will use the list file directly to check if the file exists. Since some FTP server may not support to list the file directly, if the option is false, camel-ftp will use the old way to list the directory and check if the file exists. This option also influences readLock=changed to control whether it performs a fast check to update file information or not. This can be used to speed up the process if the FTP server has a lot of files.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "common (advanced)"
      },
      "delete": {
        "title": "Delete",
        "description": "If true, the file will be deleted after it is processed successfully.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "moveFailed": {
        "title": "Move Failed",
        "description": "Sets the move failure expression based on Simple language. For example, to move files into a .error subdirectory use: .error. Note: When moving the files to the fail location Camel will handle the error and will not pick up the file again.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "noop": {
        "title": "Noop",
        "description": "If true, the file is not moved or deleted in any way. This option is good for readonly data, or for ETL type requirements. If noop=true, Camel will set idempotent=true as well, to avoid consuming the same files over and over again.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "preMove": {
        "title": "Pre Move",
        "description": "Expression (such as File Language) used to dynamically set the filename when moving it before processing. For example to move in-progress files into the order directory set this value to order.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "preSort": {
        "title": "Pre Sort",
        "description": "When pre-sort is enabled then the consumer will sort the file and directory names during polling, that was retrieved from the file system. You may want to do this in case you need to operate on the files in a sorted order. The pre-sort is executed before the consumer starts to filter, and accept files to process by Camel. This option is default=false meaning disabled.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "recursive": {
        "title": "Recursive",
        "description": "If a directory, will look for files in all the sub-directories as well.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "sendEmptyMessageWhenIdle": {
        "title": "Send Empty Message When Idle",
        "description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "streamDownload": {
        "title": "Stream Download",
        "description": "Sets the download method to use when not using a local working directory. If set to true, the remote files are streamed to the route as they are read. When set to false, the remote files are loaded into memory before being sent into the route. If enabling this option then you must set stepwise=false as both cannot be enabled at the same time.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "bridgeErrorHandler": {
        "title": "Bridge Error Handler",
        "description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "download": {
        "title": "Download",
        "description": "Whether the FTP consumer should download the file. If this option is set to false, then the message body will be null, but the consumer will still trigger a Camel Exchange that has details about the file such as file name, file size, etc. It's just that the file will not be downloaded.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "exchangePattern": {
        "title": "Exchange Pattern",
        "description": "Sets the exchange pattern when the consumer creates an exchange.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer (advanced)",
        "enum": [
          "InOnly",
          "InOut"
        ]
      },
      "ignoreFileNotFoundOrPermissionError": {
        "title": "Ignore File Not Found Or Permission Error",
        "description": "Whether to ignore when (trying to list files in directories or when downloading a file), which does not exist or due to permission error. By default when a directory or file does not exists or insufficient permission, then an exception is thrown. Setting this option to true allows to ignore that instead.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "localWorkDirectory": {
        "title": "Local Work Directory",
        "description": "When consuming, a local work directory can be used to store the remote file content directly in local files, to avoid loading the content into memory. This is beneficial, if you consume a very big remote file and thus can conserve memory.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "useList": {
        "title": "Use List",
        "description": "Whether to allow using LIST command when downloading a file. Default is true. In some use cases you may want to download a specific file and are not allowed to use the LIST command, and therefore you can set this option to false. Notice when using this option, then the specific file to download does not include meta-data information such as file size, timestamp, permissions etc, because those information is only possible to retrieve when LIST command is in use.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "fileExist": {
        "title": "File Exist",
        "description": "What to do if a file already exists with the same name. Override, which is the default, replaces the existing file. - Append - adds content to the existing file. - Fail - throws a GenericFileOperationException, indicating that there is already an existing file. - Ignore - silently ignores the problem and does not override the existing file, but assumes everything is okay. - Move - option requires to use the moveExisting option to be configured as well. The option eagerDeleteTargetFile can be used to control what to do if an moving the file, and there exists already an existing file, otherwise causing the move operation to fail. The Move option will move any existing files, before writing the target file. - TryRename is only applicable if tempFileName option is in use. This allows to try renaming the file from the temporary name to the actual name, without doing any exists check. This check may be faster on some file systems and especially FTP servers.",
        "datatype": "string",
        "defaultValue": "Override",
        "secret": false,
        "required": false,
        "group": "producer",
        "enum": [
          "Override",
          "Append",
          "Fail",
          "Ignore",
          "Move",
          "TryRename"
        ]
      },
      "flatten": {
        "title": "Flatten",
        "description": "Flatten is used to flatten the file name path to strip any leading paths, so it's just the file name. This allows you to consume recursively into sub-directories, but when you eg write the files to another directory they will be written in a single directory. Setting this to true on the producer enforces that any file name in CamelFileName header will be stripped for any leading paths.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "jailStartingDirectory": {
        "title": "Jail Starting Directory",
        "description": "Used for jailing (restricting) writing files to the starting directory (and sub) only. This is enabled by default to not allow Camel to write files to outside directories (to be more secured out of the box). You can turn this off to allow writing files to directories outside the starting directory, such as parent or root folders.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "moveExisting": {
        "title": "Move Existing",
        "description": "Expression (such as File Language) used to compute file name to use when fileExist=Move is configured. To move files into a backup subdirectory just enter backup. This option only supports the following File Language tokens: file:name, file:name.ext, file:name.noext, file:onlyname, file:onlyname.noext, file:ext, and file:parent. Notice the file:parent is not supported by the FTP component, as the FTP component can only move any existing files to a relative directory based on current dir as base.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "tempFileName": {
        "title": "Temp File Name",
        "description": "The same as tempPrefix option but offering a more fine grained control on the naming of the temporary filename as it uses the File Language. The location for tempFilename is relative to the final file location in the option 'fileName', not the target directory in the base uri. For example if option fileName includes a directory prefix: dir/finalFilename then tempFileName is relative to that subdirectory dir.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "tempPrefix": {
        "title": "Temp Prefix",
        "description": "This option is used to write the file using a temporary name and then, after the write is complete, rename it to the real name. Can be used to identify files being written and also avoid consumers (not using exclusive read locks) reading in progress files. Is often used by FTP when uploading big files.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "allowNullBody": {
        "title": "Allow Null Body",
        "description": "Used to specify if a null body is allowed during file writing. If set to true then an empty file will be created, when set to false, and attempting to send a null body to the file component, a GenericFileWriteException of 'Cannot write null body to file.' will be thrown. If the fileExist option is set to 'Override', then the file will be truncated, and if set to append the file will remain unchanged.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "chmod": {
        "title": "Chmod",
        "description": "Allows you to set chmod on the stored file. For example chmod=640.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "chmodDirectory": {
        "title": "Chmod Directory",
        "description": "Allows you to set chmod during path creation. For example chmod=640.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "disconnectOnBatchComplete": {
        "title": "Disconnect On Batch Complete",
        "description": "Whether or not to disconnect from remote FTP server right after a Batch upload is complete. disconnectOnBatchComplete will only disconnect the current connection to the FTP server.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "eagerDeleteTargetFile": {
        "title": "Eager Delete Target File",
        "description": "Whether or not to eagerly delete any existing target file. This option only applies when you use fileExists=Override and the tempFileName option as well. You can use this to disable (set it to false) deleting the target file before the temp file is written. For example you may write big files and want the target file to exists during the temp file is being written. This ensure the target file is only deleted until the very last moment, just before the temp file is being renamed to the target filename. This option is also used to control whether to delete any existing files when fileExist=Move is enabled, and an existing file exists. If this option copyAndDeleteOnRenameFails false, then an exception will be thrown if an existing file existed, if its true, then the existing file is deleted before the move operation.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "keepLastModified": {
        "title": "Keep Last Modified",
        "description": "Will keep the last modified timestamp from the source file (if any). Will use the FileConstants.FILE_LAST_MODIFIED header to located the timestamp. This header can contain either a java.util.Date or long with the timestamp. If the timestamp exists and the option is enabled it will set this timestamp on the written file. Note: This option only applies to the file producer. You cannot use this option with any of the ftp producers.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "lazyStartProducer": {
        "title": "Lazy Start Producer",
        "description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "sendNoop": {
        "title": "Send Noop",
        "description": "Whether to send a noop command as a pre-write check before uploading files to the FTP server. This is enabled by default as a validation of the connection is still valid, which allows to silently re-connect to be able to upload the file. However if this causes problems, you can turn this option off.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "autoCreate": {
        "title": "Auto Create",
        "description": "Automatically create missing directories in the file's pathname. For the file consumer, that means creating the starting directory. For the file producer, it means the directory the files should be written to.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "bindAddress": {
        "title": "Bind Address",
        "description": "Specifies the address of the local interface against which the connection should bind.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "bulkRequests": {
        "title": "Bulk Requests",
        "description": "Specifies how many requests may be outstanding at any one time. Increasing this value may slightly improve file transfer speed but will increase memory usage.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "compression": {
        "title": "Compression",
        "description": "To use compression. Specify a level from 1 to 10. Important: You must manually add the needed JSCH zlib JAR to the classpath for compression support.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "connectTimeout": {
        "title": "Connect Timeout",
        "description": "Sets the connect timeout for waiting for a connection to be established Used by both FTPClient and JSCH",
        "datatype": "number",
        "format": "duration",
        "defaultValue": 10000,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "existDirCheckUsingLs": {
        "title": "Exist Dir Check Using Ls",
        "description": "Whether to check for existing directory using LS command or CD. By default LS is used which is safer as otherwise Camel needs to change the directory back after checking. However LS has been reported to cause a problem on windows system in some situations and therefore you can disable this option to use CD.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "filenameEncoding": {
        "title": "Filename Encoding",
        "description": "Encoding to use for FTP client when parsing filenames. By default, UTF-8 is used.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "maximumReconnectAttempts": {
        "title": "Maximum Reconnect Attempts",
        "description": "Specifies the maximum reconnect attempts Camel performs when it tries to connect to the remote FTP server. Use 0 to disable this behavior.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "reconnectDelay": {
        "title": "Reconnect Delay",
        "description": "Delay in millis Camel will wait before performing a reconnect attempt.",
        "datatype": "number",
        "format": "duration",
        "defaultValue": 1000,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "serverAliveCountMax": {
        "title": "Server Alive Count Max",
        "description": "Sets the number of keep-alive messages which may be sent without receiving any messages back from the server. If this threshold is reached while keep-alive messages are being sent, the connection will be disconnected. The default value is one.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 1,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "serverAliveInterval": {
        "title": "Server Alive Interval",
        "description": "Sets the interval (millis) to send a keep-alive message. If zero is specified, any keep-alive message must not be sent. The default interval is zero.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "soTimeout": {
        "title": "So Timeout",
        "description": "Sets the so timeout FTP and FTPS Is the SocketOptions.SO_TIMEOUT value in millis. Recommended option is to set this to 300000 so as not have a hanged connection. On SFTP this option is set as timeout on the JSCH Session instance.",
        "datatype": "number",
        "format": "duration",
        "defaultValue": 300000,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "stepwise": {
        "title": "Stepwise",
        "description": "Sets whether we should stepwise change directories while traversing file structures when downloading files, or as well when uploading a file to a directory. You can disable this if you for example are in a situation where you cannot change directory on the FTP server due security reasons. Stepwise cannot be used together with streamDownload.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "throwExceptionOnConnectFailed": {
        "title": "Throw Exception On Connect Failed",
        "description": "Should an exception be thrown if connection failed (exhausted)By default exception is not thrown and a WARN is logged. You can use this to enable exception being thrown and handle the thrown exception from the org.apache.camel.spi.PollingConsumerPollStrategy rollback method.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "timeout": {
        "title": "Timeout",
        "description": "Sets the data timeout for waiting for reply Used only by FTPClient",
        "datatype": "number",
        "format": "duration",
        "defaultValue": 30000,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "antExclude": {
        "title": "Ant Exclude",
        "description": "Ant style filter exclusion. If both antInclude and antExclude are used, antExclude takes precedence over antInclude. Multiple exclusions may be specified in comma-delimited format.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "filter"
      },
      "antFilterCaseSensitive": {
        "title": "Ant Filter Case Sensitive",
        "description": "Sets case sensitive flag on ant filter.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "filter"
      },
      "antInclude": {
        "title": "Ant Include",
        "description": "Ant style filter inclusion. Multiple inclusions may be specified in comma-delimited format.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "filter"
      },
      "eagerMaxMessagesPerPoll": {
        "title": "Eager Max Messages Per Poll",
        "description": "Allows for controlling whether the limit from maxMessagesPerPoll is eager or not. If eager then the limit is during the scanning of files. Where as false would scan all files, and then perform sorting. Setting this option to false allows for sorting all files first, and then limit the poll. Mind that this requires a higher memory usage as all file details are in memory to perform the sorting.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "filter"
      },
      "exclude": {
        "title": "Exclude",
        "description": "Is used to exclude files, if filename matches the regex pattern (matching is case in-sensitive). Notice if you use symbols such as plus sign and others you would need to configure this using the RAW() syntax if configuring this as an endpoint uri. See more details at configuring endpoint uris",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "filter"
      },
      "excludeExt": {
        "title": "Exclude Ext",
        "description": "Is used to exclude files matching file extension name (case insensitive). For example to exclude bak files, then use excludeExt=bak. Multiple extensions can be separated by comma, for example to exclude bak and dat files, use excludeExt=bak,dat. Note that the file extension includes all parts, for example having a file named mydata.tar.gz will have extension as tar.gz. For more flexibility then use the include/exclude options.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "filter"
      },
      "filterDirectory": {
        "title": "Filter Directory",
        "description": "Filters the directory based on Simple language. For example to filter on current date, you can use a simple date pattern such as ${date:now:yyyMMdd}",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "filter"
      },
      "filterFile": {
        "title": "Filter File",
        "description": "Filters the file based on Simple language. For example to filter on file size, you can use ${file:size} 5000",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "filter"
      },
      "idempotent": {
        "title": "Idempotent",
        "description": "Option to use the Idempotent Consumer EIP pattern to let Camel skip already processed files. Will by default use a memory based LRUCache that holds 1000 entries. If noop=true then idempotent will be enabled as well to avoid consuming the same files over and over again.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "filter"
      },
      "idempotentKey": {
        "title": "Idempotent Key",
        "description": "To use a custom idempotent key. By default the absolute path of the file is used. You can use the File Language, for example to use the file name and file size, you can do: idempotentKey=${file:name}-${file:size}",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "filter"
      },
      "include": {
        "title": "Include",
        "description": "Is used to include files, if filename matches the regex pattern (matching is case in-sensitive). Notice if you use symbols such as plus sign and others you would need to configure this using the RAW() syntax if configuring this as an endpoint uri. See more details at configuring endpoint uris",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "filter"
      },
      "includeExt": {
        "title": "Include Ext",
        "description": "Is used to include files matching file extension name (case insensitive). For example to include txt files, then use includeExt=txt. Multiple extensions can be separated by comma, for example to include txt and xml files, use includeExt=txt,xml. Note that the file extension includes all parts, for example having a file named mydata.tar.gz will have extension as tar.gz. For more flexibility then use the include/exclude options.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "filter"
      },
      "maxDepth": {
        "title": "Max Depth",
        "description": "The maximum depth to traverse when recursively processing a directory.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 2147483647,
        "secret": false,
        "required": false,
        "group": "filter"
      },
      "maxMessagesPerPoll": {
        "title": "Max Messages Per Poll",
        "description": "To define a maximum messages to gather per poll. By default no maximum is set. Can be used to set a limit of e.g. 1000 to avoid when starting up the server that there are thousands of files. Set a value of 0 or negative to disabled it. Notice: If this option is in use then the File and FTP components will limit before any sorting. For example if you have 100000 files and use maxMessagesPerPoll=500, then only the first 500 files will be picked up, and then sorted. You can use the eagerMaxMessagesPerPoll option and set this to false to allow to scan all files first and then sort afterwards.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "filter"
      },
      "minDepth": {
        "title": "Min Depth",
        "description": "The minimum depth to start processing when recursively processing a directory. Using minDepth=1 means the base directory. Using minDepth=2 means the first sub directory.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "filter"
      },
      "move": {
        "title": "Move",
        "description": "Expression (such as Simple Language) used to dynamically set the filename when moving it after processing. To move files into a .done subdirectory just enter .done.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "filter"
      },
      "readLock": {
        "title": "Read Lock",
        "description": "Used by consumer, to only poll the files if it has exclusive read-lock on the file (i.e. the file is not in-progress or being written). Camel will wait until the file lock is granted. This option provides the build in strategies: - none - No read lock is in use - markerFile - Camel creates a marker file (fileName.camelLock) and then holds a lock on it. This option is not available for the FTP component - changed - Changed is using file length/modification timestamp to detect whether the file is currently being copied or not. Will at least use 1 sec to determine this, so this option cannot consume files as fast as the others, but can be more reliable as the JDK IO API cannot always determine whether a file is currently being used by another process. The option readLockCheckInterval can be used to set the check frequency. - fileLock - is for using java.nio.channels.FileLock. This option is not avail for Windows OS and the FTP component. This approach should be avoided when accessing a remote file system via a mount/share unless that file system supports distributed file locks. - rename - rename is for using a try to rename the file as a test if we can get exclusive read-lock. - idempotent - (only for file component) idempotent is for using a idempotentRepository as the read-lock. This allows to use read locks that supports clustering if the idempotent repository implementation supports that. - idempotent-changed - (only for file component) idempotent-changed is for using a idempotentRepository and changed as the combined read-lock. This allows to use read locks that supports clustering if the idempotent repository implementation supports that. - idempotent-rename - (only for file component) idempotent-rename is for using a idempotentRepository and rename as the combined read-lock. This allows to use read locks that supports clustering if the idempotent repository implementation supports that.Notice: The various read locks is not all suited to work in clustered mode, where concurrent consumers on different nodes is competing for the same files on a shared file system. The markerFile using a close to atomic operation to create the empty marker file, but its not guaranteed to work in a cluster. The fileLock may work better but then the file system need to support distributed file locks, and so on. Using the idempotent read lock can support clustering if the idempotent repository supports clustering, such as Hazelcast Component or Infinispan.",
        "datatype": "string",
        "defaultValue": "none",
        "secret": false,
        "required": false,
        "group": "lock",
        "enum": [
          "none",
          "markerFile",
          "fileLock",
          "rename",
          "changed",
          "idempotent",
          "idempotent-changed",
          "idempotent-rename"
        ]
      },
      "readLockCheckInterval": {
        "title": "Read Lock Check Interval",
        "description": "Interval in millis for the read-lock, if supported by the read lock. This interval is used for sleeping between attempts to acquire the read lock. For example when using the changed read lock, you can set a higher interval period to cater for slow writes. The default of 1 sec. may be too fast if the producer is very slow writing the file. Notice: For FTP the default readLockCheckInterval is 5000. The readLockTimeout value must be higher than readLockCheckInterval, but a rule of thumb is to have a timeout that is at least 2 or more times higher than the readLockCheckInterval. This is needed to ensure that amble time is allowed for the read lock process to try to grab the lock before the timeout was hit.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 1000,
        "secret": false,
        "required": false,
        "group": "lock"
      },
      "readLockDeleteOrphanLockFiles": {
        "title": "Read Lock Delete Orphan Lock Files",
        "description": "Whether or not read lock with marker files should upon startup delete any orphan read lock files, which may have been left on the file system, if Camel was not properly shutdown (such as a JVM crash). If turning this option to false then any orphaned lock file will cause Camel to not attempt to pickup that file, this could also be due another node is concurrently reading files from the same shared directory.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "lock"
      },
      "readLockIdempotentReleaseAsync": {
        "title": "Read Lock Idempotent Release Async",
        "description": "Whether the delayed release task should be synchronous or asynchronous. See more details at the readLockIdempotentReleaseDelay option.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "lock"
      },
      "readLockIdempotentReleaseAsyncPoolSize": {
        "title": "Read Lock Idempotent Release Async Pool Size",
        "description": "The number of threads in the scheduled thread pool when using asynchronous release tasks. Using a default of 1 core threads should be sufficient in almost all use-cases, only set this to a higher value if either updating the idempotent repository is slow, or there are a lot of files to process. This option is not in-use if you use a shared thread pool by configuring the readLockIdempotentReleaseExecutorService option. See more details at the readLockIdempotentReleaseDelay option.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "lock"
      },
      "readLockIdempotentReleaseDelay": {
        "title": "Read Lock Idempotent Release Delay",
        "description": "Whether to delay the release task for a period of millis. This can be used to delay the release tasks to expand the window when a file is regarded as read-locked, in an active/active cluster scenario with a shared idempotent repository, to ensure other nodes cannot potentially scan and acquire the same file, due to race-conditions. By expanding the time-window of the release tasks helps prevents these situations. Note delaying is only needed if you have configured readLockRemoveOnCommit to true.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "lock"
      },
      "readLockLoggingLevel": {
        "title": "Read Lock Logging Level",
        "description": "Logging level used when a read lock could not be acquired. By default a DEBUG is logged. You can change this level, for example to OFF to not have any logging. This option is only applicable for readLock of types: changed, fileLock, idempotent, idempotent-changed, idempotent-rename, rename.",
        "datatype": "string",
        "defaultValue": "DEBUG",
        "secret": false,
        "required": false,
        "group": "lock",
        "enum": [
          "TRACE",
          "DEBUG",
          "INFO",
          "WARN",
          "ERROR",
          "OFF"
        ]
      },
      "readLockMarkerFile": {
        "title": "Read Lock Marker File",
        "description": "Whether to use marker file with the changed, rename, or exclusive read lock types. By default a marker file is used as well to guard against other processes picking up the same files. This behavior can be turned off by setting this option to false. For example if you do not want to write marker files to the file systems by the Camel application.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "lock"
      },
      "readLockMinAge": {
        "title": "Read Lock Min Age",
        "description": "This option is applied only for readLock=changed. It allows to specify a minimum age the file must be before attempting to acquire the read lock. For example use readLockMinAge=300s to require the file is at last 5 minutes old. This can speedup the changed read lock as it will only attempt to acquire files which are at least that given age.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 0,
        "secret": false,
        "required": false,
        "group": "lock"
      },
      "readLockMinLength": {
        "title": "Read Lock Min Length",
        "description": "This option is applied only for readLock=changed. It allows you to configure a minimum file length. By default Camel expects the file to contain data, and thus the default value is 1. You can set this option to zero, to allow consuming zero-length files.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 1,
        "secret": false,
        "required": false,
        "group": "lock"
      },
      "readLockRemoveOnCommit": {
        "title": "Read Lock Remove On Commit",
        "description": "This option is applied only for readLock=idempotent. It allows to specify whether to remove the file name entry from the idempotent repository when processing the file is succeeded and a commit happens. By default the file is not removed which ensures that any race-condition do not occur so another active node may attempt to grab the file. Instead the idempotent repository may support eviction strategies that you can configure to evict the file name entry after X minutes - this ensures no problems with race conditions. See more details at the readLockIdempotentReleaseDelay option.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "lock"
      },
      "readLockRemoveOnRollback": {
        "title": "Read Lock Remove On Rollback",
        "description": "This option is applied only for readLock=idempotent. It allows to specify whether to remove the file name entry from the idempotent repository when processing the file failed and a rollback happens. If this option is false, then the file name entry is confirmed (as if the file did a commit).",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "lock"
      },
      "readLockTimeout": {
        "title": "Read Lock Timeout",
        "description": "Optional timeout in millis for the read-lock, if supported by the read-lock. If the read-lock could not be granted and the timeout triggered, then Camel will skip the file. At next poll Camel, will try the file again, and this time maybe the read-lock could be granted. Use a value of 0 or lower to indicate forever. Currently fileLock, changed and rename support the timeout. Notice: For FTP the default readLockTimeout value is 20000 instead of 10000. The readLockTimeout value must be higher than readLockCheckInterval, but a rule of thumb is to have a timeout that is at least 2 or more times higher than the readLockCheckInterval. This is needed to ensure that amble time is allowed for the read lock process to try to grab the lock before the timeout was hit.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 10000,
        "secret": false,
        "required": false,
        "group": "lock"
      },
      "backoffErrorThreshold": {
        "title": "Backoff Error Threshold",
        "description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "backoffIdleThreshold": {
        "title": "Backoff Idle Threshold",
        "description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "backoffMultiplier": {
        "title": "Backoff Multiplier",
        "description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "delay": {
        "title": "Delay",
        "description": "Milliseconds before the next poll.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 500,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "greedy": {
        "title": "Greedy",
        "description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "initialDelay": {
        "title": "Initial Delay",
        "description": "Milliseconds before the first poll starts.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 1000,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "repeatCount": {
        "title": "Repeat Count",
        "description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 0,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "runLoggingLevel": {
        "title": "Run Logging Level",
        "description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
        "datatype": "string",
        "defaultValue": "TRACE",
        "secret": false,
        "required": false,
        "group": "scheduler",
        "enum": [
          "TRACE",
          "DEBUG",
          "INFO",
          "WARN",
          "ERROR",
          "OFF"
        ]
      },
      "startScheduler": {
        "title": "Start Scheduler",
        "description": "Whether the scheduler should be auto started.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "timeUnit": {
        "title": "Time Unit",
        "description": "Time unit for initialDelay and delay options.",
        "datatype": "string",
        "defaultValue": "MILLISECONDS",
        "secret": false,
        "required": false,
        "group": "scheduler",
        "enum": [
          "NANOSECONDS",
          "MICROSECONDS",
          "MILLISECONDS",
          "SECONDS",
          "MINUTES",
          "HOURS",
          "DAYS"
        ]
      },
      "useFixedDelay": {
        "title": "Use Fixed Delay",
        "description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "ciphers": {
        "title": "Ciphers",
        "description": "Set a comma separated list of ciphers that will be used in order of preference. Possible cipher names are defined by JCraft JSCH. Some examples include: aes128-ctr,aes128-cbc,3des-ctr,3des-cbc,blowfish-cbc,aes192-cbc,aes256-cbc. If not specified the default list from JSCH will be used.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "security"
      },
      "keyExchangeProtocols": {
        "title": "Key Exchange Protocols",
        "description": "Set a comma separated list of key exchange protocols that will be used in order of preference. Possible cipher names are defined by JCraft JSCH. Some examples include: diffie-hellman-group-exchange-sha1,diffie-hellman-group1-sha1,diffie-hellman-group14-sha1, diffie-hellman-group-exchange-sha256,ecdh-sha2-nistp256,ecdh-sha2-nistp384,ecdh-sha2-nistp521. If not specified the default list from JSCH will be used.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "security"
      },
      "knownHosts": {
        "title": "Known Hosts",
        "description": "Sets the known_hosts from the byte array, so that the SFTP endpoint can do host key verification.",
        "datatype": "string",
        "secret": true,
        "required": false,
        "group": "security"
      },
      "knownHostsFile": {
        "title": "Known Hosts File",
        "description": "Sets the known_hosts file, so that the SFTP endpoint can do host key verification.",
        "datatype": "string",
        "secret": true,
        "required": false,
        "group": "security"
      },
      "knownHostsUri": {
        "title": "Known Hosts Uri",
        "description": "Sets the known_hosts file (loaded from classpath by default), so that the SFTP endpoint can do host key verification.",
        "datatype": "string",
        "secret": true,
        "required": false,
        "group": "security"
      },
      "password": {
        "title": "Password",
        "description": "Password to use for login",
        "datatype": "string",
        "secret": true,
        "required": false,
        "group": "security"
      },
      "preferredAuthentications": {
        "title": "Preferred Authentications",
        "description": "Set the preferred authentications which SFTP endpoint will used. Some example include:password,publickey. If not specified the default list from JSCH will be used.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "security"
      },
      "privateKey": {
        "title": "Private Key",
        "description": "Set the private key as byte so that the SFTP endpoint can do private key verification.",
        "datatype": "string",
        "secret": true,
        "required": false,
        "group": "security"
      },
      "privateKeyFile": {
        "title": "Private Key File",
        "description": "Set the private key file so that the SFTP endpoint can do private key verification.",
        "datatype": "string",
        "secret": true,
        "required": false,
        "group": "security"
      },
      "privateKeyPassphrase": {
        "title": "Private Key Passphrase",
        "description": "Set the private key file passphrase so that the SFTP endpoint can do private key verification.",
        "datatype": "string",
        "secret": true,
        "required": false,
        "group": "security"
      },
      "privateKeyUri": {
        "title": "Private Key Uri",
        "description": "Set the private key file (loaded from classpath by default) so that the SFTP endpoint can do private key verification.",
        "datatype": "string",
        "secret": true,
        "required": false,
        "group": "security"
      },
      "publicKeyAcceptedAlgorithms": {
        "title": "Public Key Accepted Algorithms",
        "description": "Set a comma separated list of public key accepted algorithms. Some examples include: ssh-dss,ssh-rsa,ecdsa-sha2-nistp256,ecdsa-sha2-nistp384,ecdsa-sha2-nistp521. If not specified the default list from JSCH will be used.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "security"
      },
      "serverHostKeys": {
        "title": "Server Host Keys",
        "description": "Set a comma separated list of algorithms supported for the server host key. Some examples include: ssh-dss,ssh-rsa,ecdsa-sha2-nistp256,ecdsa-sha2-nistp384,ecdsa-sha2-nistp521. If not specified the default list from JSCH will be used.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "security"
      },
      "strictHostKeyChecking": {
        "title": "Strict Host Key Checking",
        "description": "Sets whether to use strict host key checking.",
        "datatype": "string",
        "defaultValue": "no",
        "secret": false,
        "required": false,
        "group": "security",
        "enum": [
          "no",
          "yes"
        ]
      },
      "username": {
        "title": "Username",
        "description": "Username to use for login",
        "datatype": "string",
        "secret": true,
        "required": false,
        "group": "security"
      },
      "useUserKnownHostsFile": {
        "title": "Use User Known Hosts File",
        "description": "If knownHostFile has not been explicit configured then use the host file from System.getProperty(user.home)/.ssh/known_hosts",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "security"
      },
      "shuffle": {
        "title": "Shuffle",
        "description": "To shuffle the list of files (sort in random order)",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "sort"
      },
      "sortBy": {
        "title": "Sort By",
        "description": "Built-in sort by using the File Language. Supports nested sorts, so you can have a sort by file name and as a 2nd group sort by modified date.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "sort"
      }
    },
    "pathProperties": {
      "host": {
        "title": "Host",
        "description": "Hostname of the FTP server",
        "datatype": "string",
        "secret": false,
        "required": true
      },
      "port": {
        "title": "Port",
        "description": "Port of the FTP server",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false
      },
      "directoryName": {
        "title": "Directory Name",
        "description": "The starting directory",
        "datatype": "string",
        "secret": false,
        "required": false
      }
    },
    "producer": true,
    "consumer": true
  },
  {
    "name": "slack",
    "title": "Slack",
    "description": "Send and receive messages to/from Slack.",
    "iconUrl": "https://tst-ipaas-public-assets.s3.us-east-1.amazonaws.com/images/components/slack.svg",
    "syntax": "slack:channel",
    "properties": {
      "channel": {
        "title": "Channel",
        "description": "The channel name (syntax #name) or slack user (syntax userName) to send a message directly to an user.",
        "datatype": "string",
        "secret": false,
        "required": true,
        "group": "common"
      },
      "token": {
        "title": "Token",
        "description": "The token to access Slack. This app needs to have channels:history, groups:history, im:history, mpim:history, channels:read, groups:read, im:read and mpim:read permissions. The User OAuth Token is the kind of token needed.",
        "datatype": "string",
        "secret": true,
        "required": false,
        "group": "common"
      },
      "conversationType": {
        "title": "Conversation Type",
        "description": "Type of conversation",
        "datatype": "string",
        "defaultValue": "PUBLIC_CHANNEL",
        "secret": false,
        "required": false,
        "group": "consumer",
        "enum": [
          "PUBLIC_CHANNEL",
          "PRIVATE_CHANNEL",
          "MPIM",
          "IM"
        ]
      },
      "maxResults": {
        "title": "Max Results",
        "description": "The Max Result for the poll",
        "datatype": "string",
        "defaultValue": "10",
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "naturalOrder": {
        "title": "Natural Order",
        "description": "Create exchanges in natural order (oldest to newest) or not",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "sendEmptyMessageWhenIdle": {
        "title": "Send Empty Message When Idle",
        "description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "serverUrl": {
        "title": "Server Url",
        "description": "The Server URL of the Slack instance",
        "datatype": "string",
        "defaultValue": "https://slack.com",
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "bridgeErrorHandler": {
        "title": "Bridge Error Handler",
        "description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "exchangePattern": {
        "title": "Exchange Pattern",
        "description": "Sets the exchange pattern when the consumer creates an exchange.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer (advanced)",
        "enum": [
          "InOnly",
          "InOut"
        ]
      },
      "iconEmoji": {
        "title": "Icon Emoji",
        "description": "Use a Slack emoji as an avatar",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "iconUrl": {
        "title": "Icon Url",
        "description": "The avatar that the component will use when sending message to a channel or user.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "username": {
        "title": "Username",
        "description": "This is the username that the bot will have when sending messages to a channel or user.",
        "datatype": "string",
        "secret": true,
        "required": false,
        "group": "producer"
      },
      "webhookUrl": {
        "title": "Webhook Url",
        "description": "The incoming webhook URL",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "lazyStartProducer": {
        "title": "Lazy Start Producer",
        "description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "backoffErrorThreshold": {
        "title": "Backoff Error Threshold",
        "description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "backoffIdleThreshold": {
        "title": "Backoff Idle Threshold",
        "description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "backoffMultiplier": {
        "title": "Backoff Multiplier",
        "description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "delay": {
        "title": "Delay",
        "description": "Milliseconds before the next poll.",
        "datatype": "number",
        "format": "duration",
        "defaultValue": 10000,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "greedy": {
        "title": "Greedy",
        "description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "initialDelay": {
        "title": "Initial Delay",
        "description": "Milliseconds before the first poll starts.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 1000,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "repeatCount": {
        "title": "Repeat Count",
        "description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 0,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "runLoggingLevel": {
        "title": "Run Logging Level",
        "description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
        "datatype": "string",
        "defaultValue": "TRACE",
        "secret": false,
        "required": false,
        "group": "scheduler",
        "enum": [
          "TRACE",
          "DEBUG",
          "INFO",
          "WARN",
          "ERROR",
          "OFF"
        ]
      },
      "startScheduler": {
        "title": "Start Scheduler",
        "description": "Whether the scheduler should be auto started.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "timeUnit": {
        "title": "Time Unit",
        "description": "Time unit for initialDelay and delay options.",
        "datatype": "string",
        "defaultValue": "MILLISECONDS",
        "secret": false,
        "required": false,
        "group": "scheduler",
        "enum": [
          "NANOSECONDS",
          "MICROSECONDS",
          "MILLISECONDS",
          "SECONDS",
          "MINUTES",
          "HOURS",
          "DAYS"
        ]
      },
      "useFixedDelay": {
        "title": "Use Fixed Delay",
        "description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "scheduler"
      }
    },
    "pathProperties": {
      "channel": {
        "title": "Channel",
        "description": "The channel name (syntax #name) or slack user (syntax userName) to send a message directly to an user.",
        "datatype": "string",
        "secret": false,
        "required": true
      }
    },
    "producer": true,
    "consumer": true
  },
  {
    "name": "smtp",
    "title": "SMTP",
    "description": "Send and receive emails using imap, pop3 and smtp protocols.",
    "iconUrl": "https://tst-ipaas-public-assets.s3.us-east-1.amazonaws.com/images/components/smtp.svg",
    "syntax": "smtp:host:port",
    "properties": {
      "host": {
        "title": "Host",
        "description": "The mail server host name",
        "datatype": "string",
        "secret": false,
        "required": true,
        "group": "common"
      },
      "port": {
        "title": "Port",
        "description": "The port number of the mail server",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "common"
      },
      "closeFolder": {
        "title": "Close Folder",
        "description": "Whether the consumer should close the folder after polling. Setting this option to false and having disconnect=false as well, then the consumer keep the folder open between polls.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "copyTo": {
        "title": "Copy To",
        "description": "After processing a mail message, it can be copied to a mail folder with the given name. You can override this configuration value, with a header with the key copyTo, allowing you to copy messages to folder names configured at runtime.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "decodeFilename": {
        "title": "Decode Filename",
        "description": "If set to true, the MimeUtility.decodeText method will be used to decode the filename. This is similar to setting JVM system property mail.mime.encodefilename.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "delete": {
        "title": "Delete",
        "description": "Deletes the messages after they have been processed. This is done by setting the DELETED flag on the mail message. If false, the SEEN flag is set instead. As of Camel 2.10 you can override this configuration option by setting a header with the key delete to determine if the mail should be deleted or not.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "disconnect": {
        "title": "Disconnect",
        "description": "Whether the consumer should disconnect after polling. If enabled this forces Camel to connect on each poll.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "handleFailedMessage": {
        "title": "Handle Failed Message",
        "description": "If the mail consumer cannot retrieve a given mail message, then this option allows to handle the caused exception by the consumer's error handler. By enable the bridge error handler on the consumer, then the Camel routing error handler can handle the exception instead. The default behavior would be the consumer throws an exception and no mails from the batch would be able to be routed by Camel.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "maxMessagesPerPoll": {
        "title": "Max Messages Per Poll",
        "description": "Specifies the maximum number of messages to gather per poll. By default, no maximum is set. Can be used to set a limit of e.g. 1000 to avoid downloading thousands of files when the server starts up. Set a value of 0 or negative to disable this option.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "mimeDecodeHeaders": {
        "title": "Mime Decode Headers",
        "description": "This option enables transparent MIME decoding and unfolding for mail headers.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "moveTo": {
        "title": "Move To",
        "description": "After processing a mail message, it can be moved to a mail folder with the given name. You can override this configuration value, with a header with the key moveTo, allowing you to move messages to folder names configured at runtime.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "peek": {
        "title": "Peek",
        "description": "Will mark the jakarta.mail.Message as peeked before processing the mail message. This applies to IMAPMessage messages types only. By using peek the mail will not be eager marked as SEEN on the mail server, which allows us to rollback the mail message if there is an error processing in Camel.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "sendEmptyMessageWhenIdle": {
        "title": "Send Empty Message When Idle",
        "description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "skipFailedMessage": {
        "title": "Skip Failed Message",
        "description": "If the mail consumer cannot retrieve a given mail message, then this option allows to skip the message and move on to retrieve the next mail message. The default behavior would be the consumer throws an exception and no mails from the batch would be able to be routed by Camel.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "unseen": {
        "title": "Unseen",
        "description": "Whether to limit by unseen mails only.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "bridgeErrorHandler": {
        "title": "Bridge Error Handler",
        "description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "exchangePattern": {
        "title": "Exchange Pattern",
        "description": "Sets the exchange pattern when the consumer creates an exchange.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer (advanced)",
        "enum": [
          "InOnly",
          "InOut"
        ]
      },
      "failOnDuplicateFileAttachment": {
        "title": "Fail On Duplicate File Attachment",
        "description": "Whether to fail processing the mail if the mail message contains attachments with duplicate file names. If set to false, then the duplicate attachment is skipped and a WARN is logged. If set to true then an exception is thrown failing to process the mail message.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "fetchSize": {
        "title": "Fetch Size",
        "description": "Sets the maximum number of messages to consume during a poll. This can be used to avoid overloading a mail server, if a mailbox folder contains a lot of messages. Default value of -1 means no fetch size and all messages will be consumed. Setting the value to 0 is a special corner case, where Camel will not consume any messages at all.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": -1,
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "folderName": {
        "title": "Folder Name",
        "description": "The folder to poll.",
        "datatype": "string",
        "defaultValue": "INBOX",
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "generateMissingAttachmentNames": {
        "title": "Generate Missing Attachment Names",
        "description": "Set this to 'uuid' to set a UUID for the filename of the attachment if no filename was set",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "handleDuplicateAttachmentNames": {
        "title": "Handle Duplicate Attachment Names",
        "description": "Set the strategy to handle duplicate filenames of attachments never: attachments that have a filename which is already present in the attachments will be ignored unless failOnDuplicateFileAttachment is set to true. uuidPrefix: this will prefix the duplicate attachment filenames each with a uuid and underscore (uuid_filename.fileextension). uuidSuffix: this will suffix the duplicate attachment filenames each with a underscore and uuid (filename_uuid.fileextension).",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "mapMailMessage": {
        "title": "Map Mail Message",
        "description": "Specifies whether Camel should map the received mail message to Camel body/headers/attachments. If set to true, the body of the mail message is mapped to the body of the Camel IN message, the mail headers are mapped to IN headers, and the attachments to Camel IN attachment message. If this option is set to false then the IN message contains a raw jakarta.mail.Message. You can retrieve this raw message by calling exchange.getIn().getBody(jakarta.mail.Message.class).",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "bcc": {
        "title": "Bcc",
        "description": "Sets the BCC email address. Separate multiple email addresses with comma.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "cc": {
        "title": "Cc",
        "description": "Sets the CC email address. Separate multiple email addresses with comma.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "from": {
        "title": "From",
        "description": "The from email address",
        "datatype": "string",
        "defaultValue": "camel@localhost",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "replyTo": {
        "title": "Reply To",
        "description": "The Reply-To recipients (the receivers of the response mail). Separate multiple email addresses with a comma.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "subject": {
        "title": "Subject",
        "description": "The Subject of the message being sent. Note: Setting the subject in the header takes precedence over this option.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "to": {
        "title": "To",
        "description": "Sets the To email address. Separate multiple email addresses with comma.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "lazyStartProducer": {
        "title": "Lazy Start Producer",
        "description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "alternativeBodyHeader": {
        "title": "Alternative Body Header",
        "description": "Specifies the key to an IN message header that contains an alternative email body. For example, if you send emails in text/html format and want to provide an alternative mail body for non-HTML email clients, set the alternative mail body with this key as a header.",
        "datatype": "string",
        "defaultValue": "CamelMailAlternativeBody",
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "connectionTimeout": {
        "title": "Connection Timeout",
        "description": "The connection timeout in milliseconds.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 30000,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "contentType": {
        "title": "Content Type",
        "description": "The mail message content type. Use text/html for HTML mails.",
        "datatype": "string",
        "defaultValue": "text/plain",
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "healthCheckConsumerEnabled": {
        "title": "Health Check Consumer Enabled",
        "description": "Used for enabling or disabling all consumer based health checks from this component",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "health"
      },
      "debugMode": {
        "title": "Debug Mode",
        "description": "Enable debug mode on the underlying mail framework. The SUN Mail framework logs the debug messages to System.out by default.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "ignoreUnsupportedCharset": {
        "title": "Ignore Unsupported Charset",
        "description": "Option to let Camel ignore unsupported charset in the local JVM when sending mails. If the charset is unsupported then charset=XXX (where XXX represents the unsupported charset) is removed from the content-type and it relies on the platform default instead.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "ignoreUriScheme": {
        "title": "Ignore Uri Scheme",
        "description": "Option to let Camel ignore unsupported charset in the local JVM when sending mails. If the charset is unsupported then charset=XXX (where XXX represents the unsupported charset) is removed from the content-type and it relies on the platform default instead.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "useInlineAttachments": {
        "title": "Use Inline Attachments",
        "description": "Whether to use disposition inline or attachment.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "idempotentRepositoryRemoveOnCommit": {
        "title": "Idempotent Repository Remove On Commit",
        "description": "When using idempotent repository, then when the mail message has been successfully processed and is committed, should the message id be removed from the idempotent repository (default) or be kept in the repository. By default its assumed the message id is unique and has no value to be kept in the repository, because the mail message will be marked as seen/moved or deleted to prevent it from being consumed again. And therefore having the message id stored in the idempotent repository has little value. However this option allows to store the message id, for whatever reason you may have.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "filter"
      },
      "backoffErrorThreshold": {
        "title": "Backoff Error Threshold",
        "description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "backoffIdleThreshold": {
        "title": "Backoff Idle Threshold",
        "description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "backoffMultiplier": {
        "title": "Backoff Multiplier",
        "description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "delay": {
        "title": "Delay",
        "description": "Milliseconds before the next poll.",
        "datatype": "number",
        "format": "duration",
        "defaultValue": 60000,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "greedy": {
        "title": "Greedy",
        "description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "initialDelay": {
        "title": "Initial Delay",
        "description": "Milliseconds before the first poll starts.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 1000,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "repeatCount": {
        "title": "Repeat Count",
        "description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 0,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "runLoggingLevel": {
        "title": "Run Logging Level",
        "description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
        "datatype": "string",
        "defaultValue": "TRACE",
        "secret": false,
        "required": false,
        "group": "scheduler",
        "enum": [
          "TRACE",
          "DEBUG",
          "INFO",
          "WARN",
          "ERROR",
          "OFF"
        ]
      },
      "startScheduler": {
        "title": "Start Scheduler",
        "description": "Whether the scheduler should be auto started.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "timeUnit": {
        "title": "Time Unit",
        "description": "Time unit for initialDelay and delay options.",
        "datatype": "string",
        "defaultValue": "MILLISECONDS",
        "secret": false,
        "required": false,
        "group": "scheduler",
        "enum": [
          "NANOSECONDS",
          "MICROSECONDS",
          "MILLISECONDS",
          "SECONDS",
          "MINUTES",
          "HOURS",
          "DAYS"
        ]
      },
      "useFixedDelay": {
        "title": "Use Fixed Delay",
        "description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "password": {
        "title": "Password",
        "description": "The password for login. See also setAuthenticator(MailAuthenticator).",
        "datatype": "string",
        "secret": true,
        "required": false,
        "group": "security"
      },
      "username": {
        "title": "Username",
        "description": "The username for login. See also setAuthenticator(MailAuthenticator).",
        "datatype": "string",
        "secret": true,
        "required": false,
        "group": "security"
      }
    },
    "pathProperties": {
      "host": {
        "title": "Host",
        "description": "The mail server host name",
        "datatype": "string",
        "secret": false,
        "required": true
      },
      "port": {
        "title": "Port",
        "description": "The port number of the mail server",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false
      }
    },
    "producer": true,
    "consumer": true
  },
  {
    "name": "smtps",
    "title": "SMTPS",
    "description": "Send and receive emails using imap, pop3 and smtp protocols.",
    "iconUrl": "https://tst-ipaas-public-assets.s3.us-east-1.amazonaws.com/images/components/smtps.svg",
    "syntax": "smtps:host:port",
    "properties": {
      "host": {
        "title": "Host",
        "description": "The mail server host name",
        "datatype": "string",
        "secret": false,
        "required": true,
        "group": "common"
      },
      "port": {
        "title": "Port",
        "description": "The port number of the mail server",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "common"
      },
      "closeFolder": {
        "title": "Close Folder",
        "description": "Whether the consumer should close the folder after polling. Setting this option to false and having disconnect=false as well, then the consumer keep the folder open between polls.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "copyTo": {
        "title": "Copy To",
        "description": "After processing a mail message, it can be copied to a mail folder with the given name. You can override this configuration value, with a header with the key copyTo, allowing you to copy messages to folder names configured at runtime.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "decodeFilename": {
        "title": "Decode Filename",
        "description": "If set to true, the MimeUtility.decodeText method will be used to decode the filename. This is similar to setting JVM system property mail.mime.encodefilename.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "delete": {
        "title": "Delete",
        "description": "Deletes the messages after they have been processed. This is done by setting the DELETED flag on the mail message. If false, the SEEN flag is set instead. As of Camel 2.10 you can override this configuration option by setting a header with the key delete to determine if the mail should be deleted or not.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "disconnect": {
        "title": "Disconnect",
        "description": "Whether the consumer should disconnect after polling. If enabled this forces Camel to connect on each poll.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "handleFailedMessage": {
        "title": "Handle Failed Message",
        "description": "If the mail consumer cannot retrieve a given mail message, then this option allows to handle the caused exception by the consumer's error handler. By enable the bridge error handler on the consumer, then the Camel routing error handler can handle the exception instead. The default behavior would be the consumer throws an exception and no mails from the batch would be able to be routed by Camel.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "maxMessagesPerPoll": {
        "title": "Max Messages Per Poll",
        "description": "Specifies the maximum number of messages to gather per poll. By default, no maximum is set. Can be used to set a limit of e.g. 1000 to avoid downloading thousands of files when the server starts up. Set a value of 0 or negative to disable this option.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "mimeDecodeHeaders": {
        "title": "Mime Decode Headers",
        "description": "This option enables transparent MIME decoding and unfolding for mail headers.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "moveTo": {
        "title": "Move To",
        "description": "After processing a mail message, it can be moved to a mail folder with the given name. You can override this configuration value, with a header with the key moveTo, allowing you to move messages to folder names configured at runtime.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "peek": {
        "title": "Peek",
        "description": "Will mark the jakarta.mail.Message as peeked before processing the mail message. This applies to IMAPMessage messages types only. By using peek the mail will not be eager marked as SEEN on the mail server, which allows us to rollback the mail message if there is an error processing in Camel.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "sendEmptyMessageWhenIdle": {
        "title": "Send Empty Message When Idle",
        "description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "skipFailedMessage": {
        "title": "Skip Failed Message",
        "description": "If the mail consumer cannot retrieve a given mail message, then this option allows to skip the message and move on to retrieve the next mail message. The default behavior would be the consumer throws an exception and no mails from the batch would be able to be routed by Camel.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "unseen": {
        "title": "Unseen",
        "description": "Whether to limit by unseen mails only.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "bridgeErrorHandler": {
        "title": "Bridge Error Handler",
        "description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "exchangePattern": {
        "title": "Exchange Pattern",
        "description": "Sets the exchange pattern when the consumer creates an exchange.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer (advanced)",
        "enum": [
          "InOnly",
          "InOut"
        ]
      },
      "failOnDuplicateFileAttachment": {
        "title": "Fail On Duplicate File Attachment",
        "description": "Whether to fail processing the mail if the mail message contains attachments with duplicate file names. If set to false, then the duplicate attachment is skipped and a WARN is logged. If set to true then an exception is thrown failing to process the mail message.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "fetchSize": {
        "title": "Fetch Size",
        "description": "Sets the maximum number of messages to consume during a poll. This can be used to avoid overloading a mail server, if a mailbox folder contains a lot of messages. Default value of -1 means no fetch size and all messages will be consumed. Setting the value to 0 is a special corner case, where Camel will not consume any messages at all.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": -1,
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "folderName": {
        "title": "Folder Name",
        "description": "The folder to poll.",
        "datatype": "string",
        "defaultValue": "INBOX",
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "generateMissingAttachmentNames": {
        "title": "Generate Missing Attachment Names",
        "description": "Set this to 'uuid' to set a UUID for the filename of the attachment if no filename was set",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "handleDuplicateAttachmentNames": {
        "title": "Handle Duplicate Attachment Names",
        "description": "Set the strategy to handle duplicate filenames of attachments never: attachments that have a filename which is already present in the attachments will be ignored unless failOnDuplicateFileAttachment is set to true. uuidPrefix: this will prefix the duplicate attachment filenames each with a uuid and underscore (uuid_filename.fileextension). uuidSuffix: this will suffix the duplicate attachment filenames each with a underscore and uuid (filename_uuid.fileextension).",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "mapMailMessage": {
        "title": "Map Mail Message",
        "description": "Specifies whether Camel should map the received mail message to Camel body/headers/attachments. If set to true, the body of the mail message is mapped to the body of the Camel IN message, the mail headers are mapped to IN headers, and the attachments to Camel IN attachment message. If this option is set to false then the IN message contains a raw jakarta.mail.Message. You can retrieve this raw message by calling exchange.getIn().getBody(jakarta.mail.Message.class).",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "bcc": {
        "title": "Bcc",
        "description": "Sets the BCC email address. Separate multiple email addresses with comma.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "cc": {
        "title": "Cc",
        "description": "Sets the CC email address. Separate multiple email addresses with comma.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "from": {
        "title": "From",
        "description": "The from email address",
        "datatype": "string",
        "defaultValue": "camel@localhost",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "replyTo": {
        "title": "Reply To",
        "description": "The Reply-To recipients (the receivers of the response mail). Separate multiple email addresses with a comma.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "subject": {
        "title": "Subject",
        "description": "The Subject of the message being sent. Note: Setting the subject in the header takes precedence over this option.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "to": {
        "title": "To",
        "description": "Sets the To email address. Separate multiple email addresses with comma.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "lazyStartProducer": {
        "title": "Lazy Start Producer",
        "description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "alternativeBodyHeader": {
        "title": "Alternative Body Header",
        "description": "Specifies the key to an IN message header that contains an alternative email body. For example, if you send emails in text/html format and want to provide an alternative mail body for non-HTML email clients, set the alternative mail body with this key as a header.",
        "datatype": "string",
        "defaultValue": "CamelMailAlternativeBody",
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "connectionTimeout": {
        "title": "Connection Timeout",
        "description": "The connection timeout in milliseconds.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 30000,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "contentType": {
        "title": "Content Type",
        "description": "The mail message content type. Use text/html for HTML mails.",
        "datatype": "string",
        "defaultValue": "text/plain",
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "healthCheckConsumerEnabled": {
        "title": "Health Check Consumer Enabled",
        "description": "Used for enabling or disabling all consumer based health checks from this component",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "health"
      },
      "debugMode": {
        "title": "Debug Mode",
        "description": "Enable debug mode on the underlying mail framework. The SUN Mail framework logs the debug messages to System.out by default.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "ignoreUnsupportedCharset": {
        "title": "Ignore Unsupported Charset",
        "description": "Option to let Camel ignore unsupported charset in the local JVM when sending mails. If the charset is unsupported then charset=XXX (where XXX represents the unsupported charset) is removed from the content-type and it relies on the platform default instead.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "ignoreUriScheme": {
        "title": "Ignore Uri Scheme",
        "description": "Option to let Camel ignore unsupported charset in the local JVM when sending mails. If the charset is unsupported then charset=XXX (where XXX represents the unsupported charset) is removed from the content-type and it relies on the platform default instead.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "useInlineAttachments": {
        "title": "Use Inline Attachments",
        "description": "Whether to use disposition inline or attachment.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "idempotentRepositoryRemoveOnCommit": {
        "title": "Idempotent Repository Remove On Commit",
        "description": "When using idempotent repository, then when the mail message has been successfully processed and is committed, should the message id be removed from the idempotent repository (default) or be kept in the repository. By default its assumed the message id is unique and has no value to be kept in the repository, because the mail message will be marked as seen/moved or deleted to prevent it from being consumed again. And therefore having the message id stored in the idempotent repository has little value. However this option allows to store the message id, for whatever reason you may have.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "filter"
      },
      "backoffErrorThreshold": {
        "title": "Backoff Error Threshold",
        "description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "backoffIdleThreshold": {
        "title": "Backoff Idle Threshold",
        "description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "backoffMultiplier": {
        "title": "Backoff Multiplier",
        "description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "delay": {
        "title": "Delay",
        "description": "Milliseconds before the next poll.",
        "datatype": "number",
        "format": "duration",
        "defaultValue": 60000,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "greedy": {
        "title": "Greedy",
        "description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "initialDelay": {
        "title": "Initial Delay",
        "description": "Milliseconds before the first poll starts.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 1000,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "repeatCount": {
        "title": "Repeat Count",
        "description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 0,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "runLoggingLevel": {
        "title": "Run Logging Level",
        "description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
        "datatype": "string",
        "defaultValue": "TRACE",
        "secret": false,
        "required": false,
        "group": "scheduler",
        "enum": [
          "TRACE",
          "DEBUG",
          "INFO",
          "WARN",
          "ERROR",
          "OFF"
        ]
      },
      "startScheduler": {
        "title": "Start Scheduler",
        "description": "Whether the scheduler should be auto started.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "timeUnit": {
        "title": "Time Unit",
        "description": "Time unit for initialDelay and delay options.",
        "datatype": "string",
        "defaultValue": "MILLISECONDS",
        "secret": false,
        "required": false,
        "group": "scheduler",
        "enum": [
          "NANOSECONDS",
          "MICROSECONDS",
          "MILLISECONDS",
          "SECONDS",
          "MINUTES",
          "HOURS",
          "DAYS"
        ]
      },
      "useFixedDelay": {
        "title": "Use Fixed Delay",
        "description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "scheduler"
      },
      "password": {
        "title": "Password",
        "description": "The password for login. See also setAuthenticator(MailAuthenticator).",
        "datatype": "string",
        "secret": true,
        "required": false,
        "group": "security"
      },
      "username": {
        "title": "Username",
        "description": "The username for login. See also setAuthenticator(MailAuthenticator).",
        "datatype": "string",
        "secret": true,
        "required": false,
        "group": "security"
      }
    },
    "pathProperties": {
      "host": {
        "title": "Host",
        "description": "The mail server host name",
        "datatype": "string",
        "secret": false,
        "required": true
      },
      "port": {
        "title": "Port",
        "description": "The port number of the mail server",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false
      }
    },
    "producer": true,
    "consumer": true
  },
  {
    "name": "timer",
    "title": "Timer",
    "description": "Generate messages in specified intervals using java.util.Timer.",
    "iconUrl": "https://tst-ipaas-public-assets.s3.us-east-1.amazonaws.com/images/components/timer.svg",
    "syntax": "timer:timerName",
    "properties": {
      "timerName": {
        "title": "Timer Name",
        "description": "The name of the timer",
        "datatype": "string",
        "secret": false,
        "required": true,
        "group": "consumer"
      },
      "delay": {
        "title": "Delay",
        "description": "Delay before first event is triggered.",
        "datatype": "number",
        "format": "duration",
        "defaultValue": 1000,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "fixedRate": {
        "title": "Fixed Rate",
        "description": "Events take place at approximately regular intervals, separated by the specified period.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "includeMetadata": {
        "title": "Include Metadata",
        "description": "Whether to include metadata in the exchange such as fired time, timer name, timer count etc. This information is default included.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "period": {
        "title": "Period",
        "description": "If greater than 0, generate periodic events every period.",
        "datatype": "number",
        "format": "duration",
        "defaultValue": 1000,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "repeatCount": {
        "title": "Repeat Count",
        "description": "Specifies a maximum limit of number of fires. So if you set it to 1, the timer will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "bridgeErrorHandler": {
        "title": "Bridge Error Handler",
        "description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "exchangePattern": {
        "title": "Exchange Pattern",
        "description": "Sets the exchange pattern when the consumer creates an exchange.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer (advanced)",
        "enum": [
          "InOnly",
          "InOut"
        ]
      },
      "daemon": {
        "title": "Daemon",
        "description": "Specifies whether or not the thread associated with the timer endpoint runs as a daemon. The default value is true.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "pattern": {
        "title": "Pattern",
        "description": "Allows you to specify a custom Date pattern to use for setting the time option using URI syntax.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "synchronous": {
        "title": "Synchronous",
        "description": "Sets whether synchronous processing should be strictly used",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "time": {
        "title": "Time",
        "description": "A java.util.Date the first event should be generated. If using the URI, the pattern expected is: yyyy-MM-dd HH:mm:ss or yyyy-MM-dd'T'HH:mm:ss.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "advanced"
      }
    },
    "pathProperties": {
      "timerName": {
        "title": "Timer Name",
        "description": "The name of the timer",
        "datatype": "string",
        "secret": false,
        "required": true
      }
    },
    "producer": false,
    "consumer": true
  },
  {
    "name": "vertx-websocket",
    "title": "Vert.x WebSocket",
    "description": "Expose WebSocket endpoints and connect to remote WebSocket servers using Vert.x",
    "iconUrl": "https://tst-ipaas-public-assets.s3.us-east-1.amazonaws.com/images/components/vertx-websocket.svg",
    "syntax": "vertx-websocket:host:port/path",
    "properties": {
      "host": {
        "title": "Host",
        "description": "WebSocket hostname, such as localhost or a remote host when in client mode.",
        "datatype": "string",
        "secret": false,
        "required": true,
        "group": "common"
      },
      "port": {
        "title": "Port",
        "description": "WebSocket port number to use.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": true,
        "group": "common"
      },
      "path": {
        "title": "Path",
        "description": "WebSocket path to use.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "common"
      },
      "allowedOriginPattern": {
        "title": "Allowed Origin Pattern",
        "description": "Regex pattern to match the origin header sent by WebSocket clients",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "allowOriginHeader": {
        "title": "Allow Origin Header",
        "description": "Whether the WebSocket client should add the Origin header to the WebSocket handshake request.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "consumeAsClient": {
        "title": "Consume As Client",
        "description": "When set to true, the consumer acts as a WebSocket client, creating exchanges on each received WebSocket event.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "fireWebSocketConnectionEvents": {
        "title": "Fire Web Socket Connection Events",
        "description": "Whether the server consumer will create a message exchange when a new WebSocket peer connects or disconnects",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "maxReconnectAttempts": {
        "title": "Max Reconnect Attempts",
        "description": "When consumeAsClient is set to true this sets the maximum number of allowed reconnection attempts to a previously closed WebSocket. A value of 0 (the default) will attempt to reconnect indefinitely.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 0,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "originHeaderUrl": {
        "title": "Origin Header Url",
        "description": "The value of the Origin header that the WebSocket client should use on the WebSocket handshake request. When not specified, the WebSocket client will automatically determine the value for the Origin from the request URL.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "reconnectInitialDelay": {
        "title": "Reconnect Initial Delay",
        "description": "When consumeAsClient is set to true this sets the initial delay in milliseconds before attempting to reconnect to a previously closed WebSocket.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 0,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "reconnectInterval": {
        "title": "Reconnect Interval",
        "description": "When consumeAsClient is set to true this sets the interval in milliseconds at which reconnecting to a previously closed WebSocket occurs.",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 1000,
        "secret": false,
        "required": false,
        "group": "consumer"
      },
      "bridgeErrorHandler": {
        "title": "Bridge Error Handler",
        "description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "consumer (advanced)"
      },
      "exchangePattern": {
        "title": "Exchange Pattern",
        "description": "Sets the exchange pattern when the consumer creates an exchange.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "consumer (advanced)",
        "enum": [
          "InOnly",
          "InOut"
        ]
      },
      "clientSubProtocols": {
        "title": "Client Sub Protocols",
        "description": "Comma separated list of WebSocket subprotocols that the client should use for the Sec-WebSocket-Protocol header",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "sendToAll": {
        "title": "Send To All",
        "description": "To send to all websocket subscribers. Can be used to configure at the endpoint level, instead of providing the VertxWebsocketConstants.SEND_TO_ALL header on the message. Note that when using this option, the host name specified for the vertx-websocket producer URI must match one used for an existing vertx-websocket consumer. Note that this option only applies when producing messages to endpoints hosted by the vertx-websocket consumer and not to an externally hosted WebSocket.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "lazyStartProducer": {
        "title": "Lazy Start Producer",
        "description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      }
    },
    "pathProperties": {
      "host": {
        "title": "Host",
        "description": "WebSocket hostname, such as localhost or a remote host when in client mode.",
        "datatype": "string",
        "secret": false,
        "required": true
      },
      "port": {
        "title": "Port",
        "description": "WebSocket port number to use.",
        "datatype": "number",
        "format": "integer",
        "secret": false,
        "required": true
      },
      "path": {
        "title": "Path",
        "description": "WebSocket path to use.",
        "datatype": "string",
        "secret": false,
        "required": false
      }
    },
    "producer": true,
    "consumer": true
  },
  {
    "name": "xj",
    "title": "XJ",
    "description": "Transform JSON and XML message using a XSLT.",
    "iconUrl": "https://tst-ipaas-public-assets.s3.us-east-1.amazonaws.com/images/components/xj.svg",
    "syntax": "xj:resourceUri",
    "properties": {
      "resourceUri": {
        "title": "Resource Uri",
        "description": "Path to the template. The following is supported by the default URIResolver. You can prefix with: classpath, file, http, ref, or bean. classpath, file and http loads the resource using these protocols (classpath is default). ref will lookup the resource in the registry. bean will call a method on a bean to be used as the resource. For bean you can specify the method name after dot, eg bean:myBean.myMethod",
        "datatype": "string",
        "secret": false,
        "required": true,
        "group": "producer"
      },
      "allowStAX": {
        "title": "Allow StAX",
        "description": "Whether to allow using StAX as the javax.xml.transform.Source. You can enable this if the XSLT library supports StAX such as the Saxon library (camel-saxon). The Xalan library (default in JVM) does not support StAXSource.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "contentCache": {
        "title": "Content Cache",
        "description": "Cache for the resource content (the stylesheet file) when it is loaded. If set to false Camel will reload the stylesheet file on each message processing. This is good for development. A cached stylesheet can be forced to reload at runtime via JMX using the clearCachedStylesheet operation.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "deleteOutputFile": {
        "title": "Delete Output File",
        "description": "If you have output=file then this option dictates whether or not the output file should be deleted when the Exchange is done processing. For example suppose the output file is a temporary file, then it can be a good idea to delete it after use.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "failOnNullBody": {
        "title": "Fail On Null Body",
        "description": "Whether or not to throw an exception if the input body is null.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "output": {
        "title": "Output",
        "description": "Option to specify which output type to use. Possible values are: string, bytes, DOM, file. The first three options are all in memory based, where as file is streamed directly to a java.io.File. For file you must specify the filename in the IN header with the key XsltConstants.XSLT_FILE_NAME which is also CamelXsltFileName. Also any paths leading to the filename must be created beforehand, otherwise an exception is thrown at runtime.",
        "datatype": "string",
        "defaultValue": "string",
        "secret": false,
        "required": false,
        "group": "producer",
        "enum": [
          "string",
          "bytes",
          "DOM",
          "file"
        ]
      },
      "transformDirection": {
        "title": "Transform Direction",
        "description": "Transform direction. Either XML2JSON or JSON2XML",
        "datatype": "string",
        "secret": false,
        "required": true,
        "group": "producer",
        "enum": [
          "XML2JSON",
          "JSON2XML"
        ]
      },
      "transformerCacheSize": {
        "title": "Transformer Cache Size",
        "description": "The number of javax.xml.transform.Transformer object that are cached for reuse to avoid calls to Template.newTransformer().",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 0,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "lazyStartProducer": {
        "title": "Lazy Start Producer",
        "description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "saxonExtensionFunctions": {
        "title": "Saxon Extension Functions",
        "description": "Allows you to use a custom net.sf.saxon.lib.ExtensionFunctionDefinition. You would need to add camel-saxon to the classpath. The function is looked up in the registry, where you can comma to separate multiple values to lookup.",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "secureProcessing": {
        "title": "Secure Processing",
        "description": "Feature for XML secure processing (see javax.xml.XMLConstants). This is enabled by default. However, when using Saxon Professional you may need to turn this off to allow Saxon to be able to use Java extension functions.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "advanced"
      },
      "transformerFactoryClass": {
        "title": "Transformer Factory Class",
        "description": "To use a custom XSLT transformer factory, specified as a FQN class name",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "advanced"
      }
    },
    "pathProperties": {
      "resourceUri": {
        "title": "Resource Uri",
        "description": "Path to the template. The following is supported by the default URIResolver. You can prefix with: classpath, file, http, ref, or bean. classpath, file and http loads the resource using these protocols (classpath is default). ref will lookup the resource in the registry. bean will call a method on a bean to be used as the resource. For bean you can specify the method name after dot, eg bean:myBean.myMethod",
        "datatype": "string",
        "secret": false,
        "required": true
      }
    },
    "producer": true,
    "consumer": false
  },
  {
    "name": "xslt",
    "title": "XSLT",
    "description": "Transforms XML payload using an XSLT template.",
    "iconUrl": "https://tst-ipaas-public-assets.s3.us-east-1.amazonaws.com/images/components/xslt.svg",
    "syntax": "xslt:resourceUri",
    "properties": {
      "resourceUri": {
        "title": "Resource Uri",
        "description": "Path to the template. The following is supported by the default URIResolver. You can prefix with: classpath, file, http, ref, or bean. classpath, file and http loads the resource using these protocols (classpath is default). ref will lookup the resource in the registry. bean will call a method on a bean to be used as the resource. For bean you can specify the method name after dot, eg bean:myBean.myMethod",
        "datatype": "string",
        "secret": false,
        "required": true,
        "group": "producer"
      },
      "contentCache": {
        "title": "Content Cache",
        "description": "Cache for the resource content (the stylesheet file) when it is loaded. If set to false Camel will reload the stylesheet file on each message processing. This is good for development. A cached stylesheet can be forced to reload at runtime via JMX using the clearCachedStylesheet operation.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "deleteOutputFile": {
        "title": "Delete Output File",
        "description": "If you have output=file then this option dictates whether or not the output file should be deleted when the Exchange is done processing. For example suppose the output file is a temporary file, then it can be a good idea to delete it after use.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "failOnNullBody": {
        "title": "Fail On Null Body",
        "description": "Whether or not to throw an exception if the input body is null.",
        "datatype": "boolean",
        "defaultValue": true,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "output": {
        "title": "Output",
        "description": "Option to specify which output type to use. Possible values are: string, bytes, DOM, file. The first three options are all in memory based, where as file is streamed directly to a java.io.File. For file you must specify the filename in the IN header with the key XsltConstants.XSLT_FILE_NAME which is also CamelXsltFileName. Also any paths leading to the filename must be created beforehand, otherwise an exception is thrown at runtime.",
        "datatype": "string",
        "defaultValue": "string",
        "secret": false,
        "required": false,
        "group": "producer",
        "enum": [
          "string",
          "bytes",
          "DOM",
          "file"
        ]
      },
      "transformerCacheSize": {
        "title": "Transformer Cache Size",
        "description": "The number of javax.xml.transform.Transformer object that are cached for reuse to avoid calls to Template.newTransformer().",
        "datatype": "number",
        "format": "integer",
        "defaultValue": 0,
        "secret": false,
        "required": false,
        "group": "producer"
      },
      "lazyStartProducer": {
        "title": "Lazy Start Producer",
        "description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
        "datatype": "boolean",
        "defaultValue": false,
        "secret": false,
        "required": false,
        "group": "producer (advanced)"
      },
      "transformerFactoryClass": {
        "title": "Transformer Factory Class",
        "description": "To use a custom XSLT transformer factory, specified as a FQN class name",
        "datatype": "string",
        "secret": false,
        "required": false,
        "group": "advanced"
      }
    },
    "pathProperties": {
      "resourceUri": {
        "title": "Resource Uri",
        "description": "Path to the template. The following is supported by the default URIResolver. You can prefix with: classpath, file, http, ref, or bean. classpath, file and http loads the resource using these protocols (classpath is default). ref will lookup the resource in the registry. bean will call a method on a bean to be used as the resource. For bean you can specify the method name after dot, eg bean:myBean.myMethod",
        "datatype": "string",
        "secret": false,
        "required": true
      }
    },
    "producer": true,
    "consumer": false
  }
]